#BMS#->{"filename":"app.json","checksum":1543431083,"relativePath":"App.flexions\/App\/datasources\/app.json","size":5071}<-#BME#
{
    "swagger": "2.0 ++ Bartleby Metadata",
    "info": {
        "description": "... [https://www.bartleby.org/](https://www.bartleby.org/) ",
        "version": "0.9.beta1",
        "title": "Bartleby",
        "termsOfService": "https://www.bartleby.org/terms/",
        "contact": {
            "email": "nobody@bartleby.org"
        },
        "license": {
            "name": "Apache 2.0",
            "url": "http://www.apache.org/licenses/LICENSE-2.0"
        }
    },
    "host": "https://www.bartleby.org/",
    "basePath": "/api/v1",
    "tags": [],
    "schemes": [
        "https"
    ],
    "definitions": {
        "Message": {
            "description": "A message is a small piece of text associated to a communication context",
            "allOf": [
                {
                    "type": "object",
                    "properties": {
                        "creationDate": {
                            "type": "string",
                            "format": "date-time"
                        },
                        "title": {
                            "type": "String"
                        },
                        "body": {
                            "type": "String"
                        },
                        "parent": {
                            "$ref": "#/definitions/ExternalReference"
                        },
                        "childrens": {
                            "schema": {
                                "type": "array",
                                "items": {
                                    "description": "",
                                    "explicitType": "ExternalReference<Message>",
                                    "default": "ExternalReference<Message>()"
                                }
                            }
                        },
                        "tags": {
                            "schema": {
                                "type": "array",
                                "items": {
                                    "description": "The tags",
                                    "explicitType": "ExternalReference<Tag>",
                                    "default": "ExternalReference<Tag>()"
                                }
                            }
                        }
                    }
                }
            ],
            "metadata": {
                "urdMode": false,


            }
        },
        "AbstractContext": {
            "description": "A bunch of properties shared between multiple Entities used (DO NOT use allOF there is a Bug on Composition of Composition in SwaggerToFlexions)",
            "type": "object",
            "properties": {
                "name": {
                    "type": "String"
                },
                "informativeString": {
                    "type": "String"
                },
                "creationDate": {
                    "type": "string",
                    "format": "date-time"
                },
                "tags": {
                    "schema": {
                        "type": "array",
                        "items": {
                            "description": "The tags ExternalReferencees",
                            "explicitType": "ExternalReference<Tag>",
                            "default": "[ExternalReference<Tag>]()"
                        }
                    }
                }
            },
            "metadata": {
                "urdMode": false
            }
        },
        "Sample": {
            "description": "An Sample",
            "allOf": [
                {
                    "type": "object",
                    "properties": {
                        "firstName": {
                            "type": "string"
                        },
                        "lastName": {
                            "type": "string"
                        },
                        "status": {
                            "type": "string",
                            "description": "User Status",
                            "enum": [
                                "active",
                                "suspended"
                            ]
                        },
                        "tags": {
                            "schema": {
                                "type": "array",
                                "items": {
                                    "description": "The tags of the user",
                                    "explicitType": "ExternalReference<Tag>",
                                    "default": "[ExternalReference<Tag>]()"
                                }
                            }
                        }
                    }
                }
            ],
            "metadata": {
                "urdMode": false,


            }
        }
    },
    "paths":{},
    "securityDefinitions": [],
    "externalDocs": {
        "description": "Find out more about Bartleby",
        "url": "https://www.bartleby.org/"
    }
}#BMS#->{"filename":"post-processor.php","checksum":4208046175,"relativePath":"App.flexions\/App\/post-processor.php","size":2814}<-#BME#
<?php


/* @var $h Hypotypose */

// /////////////////////////////////////////
// #1 Save the hypotypose to files
// /////////////////////////////////////////

hypotyposeToFiles();

// /////////////////////////////////////////
// #2 generate some post generation files
// /////////////////////////////////////////

if(file_exists(realpath($destination))==false){
	throw new Exception("Unexisting destination ".realpath($destination));
}

$generated='';
$h=Hypotypose::Instance();

// Let's write the list of the files we have created
// We could iterate of each loop ( $h->flexedList)
$list = $h->getFlatFlexedList();
$counter = 0;

foreach ( $list as $flexed ) {
    /* @var $flexed Flexed */
	if ($flexed->exclude === false) {
		// Let's add a human readable log.
		$counter ++;
        $line='';
		if (VERBOSE_FLEXIONS)
			fLog ( $counter . " " . $flexed->fileName. cr() , false );
		// Let's list the file name
		$line .= $counter.'-> We have created "'.$flexed->package.$flexed->fileName . '"' . "".cr();
		$generated .= $line;
	}
}

// We save the file
$filePath= $destination .'ReadMe.txt';
$c='Those files that are recreated by YouDubApi-flexions-App should not be modified directly.'.cr().cr();
$c.=$generated;
file_put_contents ( $filePath, $c );


// /////////////////////////////////////////
// #3 Deploy
// /////////////////////////////////////////


// We can deploy the files per version and stage
// And keep a copy in the out.YouDubApi-flexions-App folder.

require_once FLEXIONS_MODULES_DIR . '/Deploy/FTPDeploy.php';
require_once FLEXIONS_MODULES_DIR . '/Deploy/LocalDeploy.php';

// DEVELOPMENT
if ($h->stage==DefaultStages::STAGE_DEVELOPMENT){
    $deploy=new LocalDeploy($h);

    $www=dirname(dirname(__DIR__)).'/'.APP_PUBLIC_ROOT_FOLDER.'/';
    $deploy->rmPath($www.'/api/v1/_generated/');
    $deploy->copyFiles('/php/api/v1/_generated/',$www,true);
    $deploy->copyFiles('/php/generated_destructiveInstaller.php',$www,true);
    
    // We want to copy the package 'ios/' files to the iOS sources
    $deploy->rmPath(xOS_APP_EXPORT_PATH);
    $deploy->copyFiles('/xOS/',xOS_APP_EXPORT_PATH,true);
}

// PRODUCTION
// Replace Host + <USER> & <PASSWORD>
if ($h->stage==DefaultStages::STAGE_BETA){
    // We want to copy the package 'php/' files to a valid FTP.
    $ftpDeploy=new FTPDeploy($h);
    $ftpDeploy->setUp("api.domain.com");
    if($ftpDeploy->login("xxx","xxx")==true){
        //$ftpDeploy->deleteFiles('php/','/home/dev/public_html/');
        $ftpDeploy->copyFiles('php/','/home/xxx/public_html/');
    }else{
        // There is may be an issue
    }
    // Local copies
    $deploy=new LocalDeploy($h);
    // We want to copy the package 'ios/' files to the iOS sources
    $deploy->rmPath(xOS_APP_EXPORT_PATH);
    $deploy->copyFiles('/xOS/',xOS_APP_EXPORT_PATH,true);
}#BMS#->{"filename":"pre-processor.php","checksum":1527417323,"relativePath":"App.flexions\/App\/pre-processor.php","size":1351}<-#BME#
<?php

// we load the shared variables
include  FLEXIONS_SOURCE_DIR.'/Shared.php';
require_once FLEXIONS_MODULES_DIR . 'SwaggerToFlexions/SwaggerToFlexionsRepresentations.php';
require_once FLEXIONS_MODULES_DIR . 'SwaggerToFlexions/SwaggerDelegate.php';

// we instanciate the Hypotypose singleton
$h = Hypotypose::instance();
$h->stage=DefaultStages::STAGE_DEVELOPMENT;
$h->version='1.0';
$h->classPrefix=$prefix;
if(isset($doNotGenerate)){
    $h->excludePath=$doNotGenerate;
}

$transformer=new SwaggerToFlexionsRepresentations();
$delegate=new SWaggerDelegate();
$r = $transformer->projectRepresentationFromSwaggerJson($descriptorFilePath, $prefix, $delegate);


/// Associate the entities to the loop name
if(! $h->setLoopDescriptor($r->entities,DefaultLoops::ENTITIES)){
    throw new Exception('Error when setting the loop descriptor '.DefaultLoops::ENTITIES);
}

/// Associate the global descriptor to the loop name
// Yoy must wrap it in an array
if(! $h->setLoopDescriptor($r->actions,DefaultLoops::ACTIONS)){
    throw new Exception('Error when setting the loop descriptor '.DefaultLoops::ACTIONS);
}

/// Associate the global descriptor to the loop name
// Yoy must wrap it in an array
if(! $h->setLoopDescriptor(array($r),DefaultLoops::PROJECT)){
    throw new Exception('Error when setting the loop descriptor '.DefaultLoops::PROJECT);
}#BMS#->{"filename":"run.php","checksum":115342129,"relativePath":"App.flexions\/App\/run.php","size":677}<-#BME#
<?php
/**
 * Created by PhpStorm.
 * User: bpds
 * Date: 09/07/15
 * Time: 14:56
 * You can call this little script from command line
 * php -f run.php
 * it is  equivalent to . globalflexions.sh
 * its main advantage is that it can be debugged directly more easily
 */

$arguments=array();
$arguments['source']="./";
$arguments['destination']="out.flexions/";
$arguments['descriptor']="datasources/youdub.json";
$arguments['templates']="*";
$arguments['preProcessors']="pre-processor.php";
$arguments['postProcessors']="post-processor.php";

define ( "COMMANDLINE_MODE", true );

// Invoke flexions
include_once dirname(dirname(__DIR__)).'/BartlebyFlexions/src/flexions.php';
#BMS#->{"filename":"Shared.php","checksum":828567861,"relativePath":"App.flexions\/App\/Shared.php","size":1276}<-#BME#
<?php

// DEFINE IN THIS FILE ANY SHARED GLOBAL SETUPS
// THIS FILE SHOULD BE INCLUDED IN YOUR TEMPLATES

/* @var $f Flexed */

require_once FLEXIONS_MODULES_DIR . 'Utils/Pluralization.php';
include_once dirname(dirname(__DIR__)). '/GenerativeConstants.php';

$isIncludeInBartlebysCommons=false;

$prefix = "";// No prefix
$modelsShouldConformToNSCoding=false; // (!) you can opt for NSCoding support (the model will not be pure swift models)
$excludeEntitiesWith=array("AbstractContext");//
$xOSIncludeCollectionControllerForEntityNamed=array();
$excludeActionsWith=array("LinkedDocument","Asset","AbstractContext","Reference","Tag","Scene","Shot","Sentence","TextPart","Sign","StringAttribute","TimeCode","TimeRange","MovieCharacter","Actor");//We generate only the entity
$unDeletableEntitiesWith=array();
$unModifiableEntitiesWith=array();
$doNotGenerate=array();


if (isset ( $f )) {
	$f->company = "LyLo Media group";
	$f->prefix = $prefix;
	$f->author = "benoit@pereira-da-silva.com";
	$f->projectName = "YouDub";
	//$f->license = FLEXIONS_MODULES_DIR."Licenses/LGPL.template.php";
}


/*
$parentClass = "";
$collectionParentClass="";
$protocols="";
$imports = "\n#import \"$parentClass.h\"\n"; // NOT NEEDED FOR SWIFT
$markAsDynamic = false;
$allowScalars = true;
*/
#BMS#->{"filename":"endpoint.cuds.swift.template.php","checksum":1357419024,"relativePath":"App.flexions\/App\/templates\/actions\/endpoint.cuds.swift.template.php","size":212}<-#BME#
<?php
/**
 * Injects the variable and injects the module template.
 */
include FLEXIONS_SOURCE_DIR.'/Shared.php';
include FLEXIONS_MODULES_DIR . 'Bartleby/templates/actions/cuds.withWeakLogic.swift.template.php';#BMS#->{"filename":"endpoint.php.template.php","checksum":2196702646,"relativePath":"App.flexions\/App\/templates\/actions\/endpoint.php.template.php","size":200}<-#BME#
<?php
/**
 * Injects the variable and injects the module template.
 */
include FLEXIONS_SOURCE_DIR.'/Shared.php';
include FLEXIONS_MODULES_DIR . 'Bartleby/templates/actions/endpoint.php.template.php';#BMS#->{"filename":"endpoint.swift.template.php","checksum":89320255,"relativePath":"App.flexions\/App\/templates\/actions\/endpoint.swift.template.php","size":202}<-#BME#
<?php
/**
 * Injects the variable and injects the module template.
 */
include FLEXIONS_SOURCE_DIR.'/Shared.php';
include FLEXIONS_MODULES_DIR . 'Bartleby/templates/actions/endpoint.swift.template.php';#BMS#->{"filename":"model.php.template.php","checksum":2736040291,"relativePath":"App.flexions\/App\/templates\/entities\/model.php.template.php","size":198}<-#BME#
<?php
/**
 * Injects the variable and injects the module template.
 */
include FLEXIONS_SOURCE_DIR.'/Shared.php';
include FLEXIONS_MODULES_DIR . 'Bartleby/templates/entities/model.php.template.php';#BMS#->{"filename":"model.swift.template.php","checksum":645731421,"relativePath":"App.flexions\/App\/templates\/entities\/model.swift.template.php","size":200}<-#BME#
<?php
/**
 * Injects the variable and injects the module template.
 */
include FLEXIONS_SOURCE_DIR.'/Shared.php';
include FLEXIONS_MODULES_DIR . 'Bartleby/templates/entities/model.swift.template.php';#BMS#->{"filename":"modelCollectionController.swift.template.php","checksum":279416835,"relativePath":"App.flexions\/App\/templates\/entities\/modelCollectionController.swift.template.php","size":220}<-#BME#
<?php
/**
 * Injects the variable and injects the module template.
 */
include FLEXIONS_SOURCE_DIR.'/Shared.php';
include FLEXIONS_MODULES_DIR . 'Bartleby/templates/entities/modelCollectionController.swift.template.php';#BMS#->{"filename":"baseDocument.swift.template.php","checksum":3185882183,"relativePath":"App.flexions\/App\/templates\/project\/baseDocument.swift.template.php","size":676}<-#BME#
<?php
/**
 * Injects the variable and injects the module template.
 */
include FLEXIONS_SOURCE_DIR.'/Shared.php';

// Configuration
require_once FLEXIONS_MODULES_DIR . 'Bartleby/templates/project/SwiftDocumentConfigurator.php';
$configurator=new SwiftDocumentConfigurator();
$configurator->filename="BaseDocument.swift";
$configurator->includeCollectionControllerForEntityContainingString=array("Episode","User","Group","Permission","Operation","Workspace","Project","Fragment","Note","Trigger");
$configurator->excludeCollectionControllerForEntityContainingString=array();
// Invocation
include FLEXIONS_MODULES_DIR . 'Bartleby/templates/project/document.swift.template.php';#BMS#->{"filename":"configuration.php.template.php","checksum":2686118568,"relativePath":"App.flexions\/App\/templates\/project\/configuration.php.template.php","size":207}<-#BME#
<?php
/**
 * Injects the variable and injects the module template.
 */
include FLEXIONS_SOURCE_DIR.'/Shared.php';
include FLEXIONS_MODULES_DIR . 'Bartleby/templates/project/configuration.php.template  .php';#BMS#->{"filename":"destructiveInstaller.template.php","checksum":1069868788,"relativePath":"App.flexions\/App\/templates\/project\/project\/destructiveInstaller.template.php","size":208}<-#BME#
<?php
/**
 * Injects the variable and injects the module template.
 */
include FLEXIONS_SOURCE_DIR.'/Shared.php';
include FLEXIONS_MODULES_DIR . 'Bartleby/templates/project/destructiveInstaller.template.php';#BMS#->{"filename":"endPoints.json.template.php","checksum":1409133785,"relativePath":"App.flexions\/App\/templates\/project\/project\/endPoints.json.template.php","size":216}<-#BME#
<?php
/**
 * Injects the variable and injects the module template.
 */
include FLEXIONS_SOURCE_DIR.'/Shared.php';
include FLEXIONS_MODULES_DIR . 'Bartleby/modeling-meta-templates/project/endPoints.json.template.php';#BMS#->{"filename":"post-processor.php","checksum":658985932,"relativePath":"App.flexions\/EndPointsFromDefinitions\/post-processor.php","size":1475}<-#BME#
<?php

require_once FLEXIONS_MODULES_DIR . '/Deploy/FTPDeploy.php';
require_once FLEXIONS_MODULES_DIR . '/Deploy/LocalDeploy.php';

/* @var $h Hypotypose */

// /////////////////////////////////////////
// #1 Save the hypotypose to files
// /////////////////////////////////////////

hypotyposeToFiles();

// DEVELOPMENT
if ($h->stage==DefaultStages::STAGE_DEVELOPMENT){
    $deploy=new LocalDeploy($h);
    $deploy->copyFiles('/php/',dirname(dirname(__DIR__)).'/'.APP_PUBLIC_ROOT_FOLDER.'/',true);

    // AGGREGATE THE PATHS IN youdub.json
    $decodedPaths=null;
    $fl=$h->flexedList[DefaultLoops::PROJECT];
    /* @var $flexed Flexed */
    foreach ($fl as $flexed) {
        if($flexed->fileName=='pathsFragment.json'){
            $json=$flexed->source;
            $decodedPaths=json_decode($json,true);
        }
    }
    if(isset($decodedPaths)){
        // We gonna update the json
        $dataSourcePath= dirname(__DIR__) . '/App/datasources/app.json';
        $dataSourceJSON=json_decode(file_get_contents($dataSourcePath),true);
        // $paths=$dataSourceJSON['paths']; <- if you want to preserve the paths
        $paths=array();
        
        foreach ($decodedPaths['paths'] as $path => $contentAtPath ) {
            $paths[$path]=$contentAtPath;
        }
        $dataSourceJSON['paths']=$paths;
        $encoded=json_encode($dataSourceJSON,JSON_UNESCAPED_SLASHES|JSON_PRETTY_PRINT);
        file_put_contents($dataSourcePath,$encoded);

    }


}#BMS#->{"filename":"pre-processor.php","checksum":1527417323,"relativePath":"App.flexions\/EndPointsFromDefinitions\/pre-processor.php","size":1351}<-#BME#
<?php

// we load the shared variables
include  FLEXIONS_SOURCE_DIR.'/Shared.php';
require_once FLEXIONS_MODULES_DIR . 'SwaggerToFlexions/SwaggerToFlexionsRepresentations.php';
require_once FLEXIONS_MODULES_DIR . 'SwaggerToFlexions/SwaggerDelegate.php';

// we instanciate the Hypotypose singleton
$h = Hypotypose::instance();
$h->stage=DefaultStages::STAGE_DEVELOPMENT;
$h->version='1.0';
$h->classPrefix=$prefix;
if(isset($doNotGenerate)){
    $h->excludePath=$doNotGenerate;
}

$transformer=new SwaggerToFlexionsRepresentations();
$delegate=new SWaggerDelegate();
$r = $transformer->projectRepresentationFromSwaggerJson($descriptorFilePath, $prefix, $delegate);


/// Associate the entities to the loop name
if(! $h->setLoopDescriptor($r->entities,DefaultLoops::ENTITIES)){
    throw new Exception('Error when setting the loop descriptor '.DefaultLoops::ENTITIES);
}

/// Associate the global descriptor to the loop name
// Yoy must wrap it in an array
if(! $h->setLoopDescriptor($r->actions,DefaultLoops::ACTIONS)){
    throw new Exception('Error when setting the loop descriptor '.DefaultLoops::ACTIONS);
}

/// Associate the global descriptor to the loop name
// Yoy must wrap it in an array
if(! $h->setLoopDescriptor(array($r),DefaultLoops::PROJECT)){
    throw new Exception('Error when setting the loop descriptor '.DefaultLoops::PROJECT);
}#BMS#->{"filename":"run.php","checksum":5835851,"relativePath":"App.flexions\/EndPointsFromDefinitions\/run.php","size":702}<-#BME#
<?php
/**
 * Created by PhpStorm.
 * User: bpds
 * Date: 09/07/15
 * Time: 14:56
 * You can call this little script from command line
 * php -f run.php
 * it is  equivalent to . globalflexions.sh
 * its main advantage is that it can be debugged directly more easily
 */

$arguments=array();
$arguments['source']="./";
$arguments['destination']="out.flexions/";
$arguments['descriptor']= dirname(__DIR__) . '/App/datasources/youdub.json';
$arguments['templates']="*";
$arguments['preProcessors']="pre-processor.php";
$arguments['postProcessors']="post-processor.php";

define ( "COMMANDLINE_MODE", true );

// Invoke flexions
include_once dirname(dirname(__DIR__)).'/BartlebyFlexions/src/flexions.php';
#BMS#->{"filename":"Shared.php","checksum":1889940453,"relativePath":"App.flexions\/EndPointsFromDefinitions\/Shared.php","size":1131}<-#BME#
<?php


// DEFINE IN THIS FILE ANY SHARED GLOBAL SETUPS
// THIS FILE SHOULD BE INCLUDED IN YOUR TEMPLATES

/* @var $f Flexed */

require_once FLEXIONS_MODULES_DIR . 'Utils/Pluralization.php';
include_once dirname(dirname(__DIR__)). '/GenerativeConstants.php';

$prefix = "Swagger";
$excludeEntitiesWith=array("AbstractContext");//
$excludeActionsWith=array("Asset","Datum","AbstractContext","Reference","Tag","Scene","Shot","Sentence","TextPart","Sign","StringAttribute","TimeCode","TimeRange","MovieCharacter","Actor");//We generate only the entity
$unDeletableEntitiesWith=array();
$unModifiableEntitiesWith=array();
$doNotGenerate=array("AbstractContext");// Used by the flexions script to reject a flexed content

if (isset ( $f )) {
	$f->package = "Models/";
	$f->company = "Chaosmos";
	$f->prefix = $prefix;
	$f->author = "benoit@chaosmos.fr";
	$f->projectName = "YouDub";
	//$f->license = FLEXIONS_MODULES_DIR."Licenses/LGPL.template.php";
}

/*
$parentClass = "";
$collectionParentClass="";
$protocols="";
$imports = "\n#import \"$parentClass.h\"\n"; // NOT NEEDED FOR SWIFT
$markAsDynamic = false;
$allowScalars = true;
*/#BMS#->{"filename":"README.md","checksum":3947348978,"relativePath":"App.flexions\/README.md","size":853}<-#BME#
## YouDub Api Generator

+ Generation of the server side api.
+ Generation of the xOS client side library 

## How to ? ##

Pre-generate the api descriptor 

    cd <path>/EndPointsFromDefinitions/
    php -f run.php


Generate the app

    cd <path>/App/
    php -f run.php

The generated files will be available in the folder out.flexions/
The logs will be written in BarltebyFlexions folder /out/

## Regenerate all the stack ##

You can create a global flexions script.

    #!/usr/bin/env bash
    
    cd ./Bartleby/Commons.flexions/EndPointsFromDefinitions/
    php -f run.php
    
    cd ../../../
    
    cd ./Bartleby/Commons.flexions/App/
    php -f run.php
    
    cd ../../../
    
    cd ./App.flexions/EndPointsFromDefinitions/
    php -f run.php
    
    cd ../../
    
    cd ./App.flexions/App/
    php -f run.php
    
    cd ../../
#BMS#->{"filename":"Auth.php","checksum":3027849029,"relativePath":"Bartleby\/Commons\/EndPoints\/Auth.php","size":8218}<-#BME#
<?php

namespace Bartleby\EndPoints;
require_once BARTLEBY_ROOT_FOLDER . 'Core/Configuration.php';
require_once BARTLEBY_ROOT_FOLDER . 'Commons/_generated/Models/User.php';
require_once BARTLEBY_ROOT_FOLDER . 'Mongo/MongoEndPoint.php';
require_once BARTLEBY_ROOT_FOLDER . 'Mongo/MongoCallDataRawWrapper.php';


use Bartleby\Core\Mode;
use Bartleby\mongo\MongoCallDataRawWrapper;
use Bartleby\Mongo\MongoConfiguration;
use Bartleby\Mongo\MongoEndPoint;
use Bartleby\Core\JsonResponse;
use Bartleby\Models\User;
use \MongoCursorException;
use \MongoClient;
use Bartleby\Configuration;


final class AuthCallData extends MongoCallDataRawWrapper {

    /**
     * The user instance
     */
    const userUID = 'userUID';

    /**
     * The spaceUID
     */
    const spaceUID = 'spaceUID';

    /**@
     * The sent password should be always salted with the shared salt key client side.
     * You should never transmit or store clear passwords.
     */
    const password = 'password';


    /***
     * The standard indentification mode is by "keys".
     *
     *  Auth::identificationByKey (the preferred method to permit massive multi-micro-auth on a same node.)
     *  or
     *  Auth::identificationByCookie (implicit this is the value if the method is undefined)
     */
    const identification = 'identification';

}

final class Auth extends MongoEndPoint {

    const identificationByKey = 'key';
    const identificationByCookie = 'cookie';
    const kvidKey = KVID_KEY;

    function POST() {
        /* @var AuthCallData */
        $parameters = $this->getModel();
        /* @var MongoConfiguration */
        $configuration = $this->getConfiguration();
        $currentUserUID = $parameters->getValueForKey(AuthCallData::userUID);
        $password = $parameters->getValueForKey(AuthCallData::password);
        $identification = $parameters->getValueForKey(AuthCallData::identification);
        if (!isset($identification)) {
            $identification = Auth::identificationByCookie;
        }

        if (!isset($password) || strlen($password) < 3) {
            return new JsonResponse("Password is not valid", 400);
        }
        $spaceUID = $this->getSpaceUID(false);

        /* @var MongoDB */
        $db = $this->getDB();

        $usersCollection = $configuration->MONGO_USERS_COLLECTION();

        if (!isset($currentUserUID) || strlen($currentUserUID) < 3 || !isset($spaceUID) || strlen($spaceUID) < 3) {
            return new JsonResponse(VOID_RESPONSE, 400);
        }

        $users = $db->{$usersCollection};

        try {
            $q = ["_id" => $currentUserUID,
                SPACE_UID_KEY => $spaceUID];

            $user = $users->findOne($q);
            if (isset($user)) {

                $passwordKey = $configuration->MONGO_USER_PASSWORD_KEY_PATH();
                $savedPassword = $user[$passwordKey];
                // We use a filter to salt passwords.
                if ($configuration->DISABLE_DATA_FILTERS() == true) {
                    $saltedPassword = $password;
                } else {
                    $saltedPassword = $configuration->salt($password);
                }

                $passwordMatches = (isset($password) && strlen($password) > 1 && $savedPassword === $saltedPassword);

                if ($passwordMatches) {

                    // Is the user "suspended" ?
                    if (array_key_exists('status', $user)) {
                        if ($user['status'] == User::Status_Suspended) {
                            $this->_context->consignIssue('This user is suspended', __FILE__, __LINE__);
                            return new JsonResponse($this->_context->issues, 423);
                        }
                    }

                    // Verify the conformity of the Dataspaces.
                    if (array_key_exists(SPACE_UID_KEY, $user)) {
                        if ($user[SPACE_UID_KEY] != $spaceUID) {
                            $this->_context->consignIssue('DataSpace conflict the space UID are not matching', __FILE__, __LINE__);
                            return new JsonResponse($this->_context->issues, 409);
                        }
                    } else {
                        $this->_context->consignIssue('DataSpace conflict the space UID of the user is not defined', __FILE__, __LINE__);
                        return new JsonResponse($this->_context->issues, 409);
                    }

                    // Everything is OK
                    if ($identification == Auth::identificationByCookie) {
                        // by Cookies
                        $cookieUID = $this->_openSessionWithCookies($spaceUID, $currentUserUID);
                        return new JsonResponse(VOID_RESPONSE, 200);
                    } else {
                        // by Keys
                        // There is no need to open a session
                        // The caller will resent this key value pair in a header on any identified call.
                        $identification = array($configuration->getCryptedKEYForSpaceUID($spaceUID), $configuration->encryptIdentificationValue($spaceUID, $currentUserUID));
                        return new JsonResponse($identification, 200);
                    }
                }else{
                    return new JsonResponse("Wrong password", 401);
                }
                return new JsonResponse("Undefined cause", 401);
            } else {
                if ($this->getConfiguration()->DEVELOPER_DEBUG_MODE() == true) {
                    return new JsonResponse(array("credentials" => $parameters), 404);
                } else {
                    return new JsonResponse(VOID_RESPONSE, 404);
                }

            }
        } catch (MongoCursorException $e) {
            return new JsonResponse('MongoCursorException' . $e->getCode() . ' ' . $e->getMessage(), 417);
        }
    }

    function DELETE() {
        /* @var AuthCallData */
        $parameters = $this->getModel();
        $spaceUID = $this->getSpaceUID(false);
        if ($this->_removeCookiesFor($spaceUID)) {
            return new JsonResponse(VOID_RESPONSE, 202);
        } else {
            return new JsonResponse(VOID_RESPONSE, 200);
        }
    }
    /////////////////////////
    // Session
    /////////////////////////

    /////////////
    // COOKIES
    ////////////

    /**
     * Open the session
     * @param $spaceUID
     * @param $userID
     * @return string
     */
    protected function _openSessionWithCookies($spaceUID, $userID) {
        return $this->_setCookie($spaceUID, $userID);
    }


    private function _removeCookiesFor($spaceUID) {
        $configuration = $this->getConfiguration();
        $cookieKey = $configuration->getCryptedKEYForSpaceUID($spaceUID);
        if (array_key_exists($cookieKey, $_COOKIE)) {
            // Cookie expiration
            setcookie($cookieKey, '', time() - 60, '/', null, false, false);
            if (array_key_exists(CURRENT_SPACE_UID_COOKIE_KEY, $_COOKIE)) {
                setcookie(CURRENT_SPACE_UID_COOKIE_KEY, '', time() - 60, '/', null, false, false);
            }
            return true;
        } else {
            return false;
        }
    }

    private function _setCookie($spaceUID, $userID, $nbOfHours = 240) {
        $time = time();
        $configuration = $this->getConfiguration();
        $cookieKey = $configuration->getCryptedKEYForSpaceUID($spaceUID);
        $cookieValue = $configuration->encryptIdentificationValue($spaceUID, $userID);
        $expires = $time + $nbOfHours * 60 * 60;
        //setcookie ($name, $value = null, $expire = null, $path = null, $domain = null, $secure = null, $httponly = null)
        if (setcookie($cookieKey, $cookieValue, $expires, '/', null, false, false) === false) {
            $this->_context->consignIssue('The setcookie for ' . $cookieKey . '  has failed!', __FILE__, __LINE__);
        }
        if (setcookie(CURRENT_SPACE_UID_COOKIE_KEY, $spaceUID, $expires, '/', null, false, false)) {
            $this->_context->consignIssue('The setcookie for ' . CURRENT_SPACE_UID_COOKIE_KEY . '  has failed!', __FILE__, __LINE__);
        };
        return $cookieValue;
    }

}#BMS#->{"filename":"EntityExistsById.php","checksum":2374062374,"relativePath":"Bartleby\/Commons\/EndPoints\/EntityExistsById.php","size":3062}<-#BME#
<?php

namespace Bartleby\EndPoints;

require_once BARTLEBY_ROOT_FOLDER . 'Mongo/MongoEndPoint.php';
require_once BARTLEBY_ROOT_FOLDER . 'Mongo/MongoCallDataRawWrapper.php';

use Bartleby\Mongo\MongoEndPoint;
use Bartleby\Mongo\MongoCallDataRawWrapper;
use Bartleby\Core\JsonResponse;
use \MongoCollection;
use \MongoRegex;

class  EntityExistsByIdCallData extends MongoCallDataRawWrapper {
    const id = 'id';
}

class  EntityExistsById extends MongoEndPoint {

    /**
     * We use the triggers to determine if an entity with this entity may have been deleted.
     * - If we don't find any Creation trigger we return 404
     * - If  the last trigger is creative we return http status 200 if it is destructive we return 404
     * @return JsonResponse
     */
    function call() {
        /* @var EntityExistsByIdCallData */
        $parameters=$this->getModel();
        $db = $this->getDB();
        /* @var \MongoCollection */

        $id = $parameters->getValueForKey(EntityExistsByIdCallData::id);
        if (!isset($id)) {
            return new JsonResponse("Id is undefined", 412);
        }

        $collection = $db->triggers;

        // https://docs.mongodb.com/manual/reference/operator/query/
        $q ['UIDS'] = [
            '$regex' => new MongoRegex("/^$id/i")
        ];

        ////////////////////////////////////////////
        // space UID confinements
        // but not observationUID
        // in case the operation came from a non observed zone
        ////////////////////////////////////////////

        try {
            // Restrict to this spaceUID
            $q[SPACE_UID_KEY] = $this->getSpaceUID(false);
        } catch (\Exception $e) {
            return new JsonResponse("spaceUID is undefined", 412);
        }

        try {
            $r = array();
            $cursor = $collection->find($q);
            // Sort ?
            if ($cursor->count(TRUE) > 0) {
                foreach ($cursor as $obj) {
                    $r[] = $obj;
                }
                $lastTrigger=$r[count($r)-1];
                if (array_key_exists('action',$lastTrigger)
                    && array_key_exists('index',$lastTrigger) ){
                    $action=$lastTrigger['action'];
                    if (strpos('Delete',$action)===false){
                        return new JsonResponse(
                        ['deletionIndex'=>$lastTrigger['index'],'UID'=>$lastTrigger['_id']], 404);
                    }else{
                        return new JsonResponse(
                            VOID_RESPONSE, 200);
                    }
                }
            }else{
                return new JsonResponse(
                    $r, 404);
            }
            } catch (\Exception $e) {
            return new JsonResponse(['code' => $e->getCode(),
                'message' => $e->getMessage(),
                'file' => $e->getFile(),
                'line' => $e->getLine(),
                'trace' => $e->getTraceAsString()
            ],
                417
            );
        }

    }
}

?>#BMS#->{"filename":"Export.php","checksum":4127731226,"relativePath":"Bartleby\/Commons\/EndPoints\/Export.php","size":2345}<-#BME#
<?php
/**
 * Created by PhpStorm.
 * User: bpds
 * Date: 08/07/2016
 * Time: 09:31
 */

namespace Bartleby\EndPoints;

require_once BARTLEBY_ROOT_FOLDER . 'Mongo/MongoEndPoint.php';
require_once BARTLEBY_ROOT_FOLDER . 'Mongo/MongoCallDataRawWrapper.php';

use Bartleby\Core\JsonResponse;
use Bartleby\mongo\MongoCallDataRawWrapper;
use Bartleby\Mongo\MongoEndPoint;


final class ExportCallData extends MongoCallDataRawWrapper {

    const filterByObservationUID='filterByObservationUID';

    const excludeTriggers='excludeTriggers';
    
}

final class Export extends MongoEndPoint{

    /**
     * Returns the whole data space.
     */
    function GET(){
        $collectionsNames=$this->getConfiguration()->getCollectionsNameList();
        $dataSet=["collections"=>[]];
        $spaceUID=$this->getSpaceUID(false);

        /* @var ExportCallData */
        $parameters=$this->getModel();
        $db=$this->getDB();

        $q = [SPACE_UID_KEY =>$spaceUID];
        $observationUID=$parameters->getValueForKey(ExportCallData::filterByObservationUID);
        $excludeTriggers=$parameters->getValueForKey(ExportCallData::excludeTriggers);
        $excludeTriggers=($excludeTriggers=="true");
        if (isset($rootObjectUID)){
            $q[OBSERVATION_UID_KEY]=$observationUID;
        }

        foreach ($collectionsNames as $collectionName) {
            if ($collectionName=="triggers" && $excludeTriggers){
                continue;
            }
            try {
                /* @var \MongoCollection */
                $collection = $db->{$collectionName};
                $cursor = $collection->find($q);
                if ($cursor->count ( TRUE ) > 0) {
                    $dataSet["collections"][$collectionName] = [];
                    foreach ( $cursor as $obj ) {
                        $dataSet["collections"][$collectionName][]= $obj;
                    }
                }
            } catch ( \Exception $e ) {
                return new JsonResponse( [  'code'=>$e->getCode(),
                    'message'=>$e->getMessage(),
                    'file'=>$e->getFile(),
                    'line'=>$e->getLine(),
                    'trace'=>$e->getTraceAsString()
                ],
                    417
                );
            }
        }

        return new JsonResponse($dataSet,200);
    }

}#BMS#->{"filename":"Import.php","checksum":3295589075,"relativePath":"Bartleby\/Commons\/EndPoints\/Import.php","size":390}<-#BME#
<?php


namespace Bartleby\EndPoints;

require_once BARTLEBY_ROOT_FOLDER . 'Mongo/MongoEndPoint.php';
require_once BARTLEBY_ROOT_FOLDER . 'Mongo/MongoCallDataRawWrapper.php';

use Bartleby\Core\JsonResponse;
use Bartleby\mongo\MongoCallDataRawWrapper;
use Bartleby\Mongo\MongoEndPoint;

final class ImportCallData extends MongoCallDataRawWrapper {

}

class Import extends MongoEndPoint{

}#BMS#->{"filename":"Infos.php","checksum":1825038495,"relativePath":"Bartleby\/Commons\/EndPoints\/Infos.php","size":2564}<-#BME#
<?php

namespace Bartleby\EndPoints;

require_once BARTLEBY_ROOT_FOLDER . 'Mongo/MongoEndPoint.php';
require_once BARTLEBY_ROOT_FOLDER . 'Mongo/MongoCallDataRawWrapper.php';
require_once BARTLEBY_ROOT_FOLDER . 'Core/KeyPath.php';

use Bartleby\Core\Configuration;
use Bartleby\Core\JsonResponse;
use Bartleby\Core\Mode;
use Bartleby\mongo\MongoCallDataRawWrapper;
use Bartleby\Mongo\MongoEndPoint;
use Bartleby\Core\KeyPath;


final class InfosCallData extends MongoCallDataRawWrapper {

    // Set a key if you want only that key.
    const k = "k";
}

/**
 * Class Infos
 *
 * You can grab :
 *
 * All the infos
 * http://localhost/api/v1/infos
 *
 * Unique key
 * http://localhost/api/v1/infos?k=acl_is_disabled
 *
 * Nested key path
 * http://localhost/api/v1/infos?k=configuration.STAGE
 * http://localhost/api/v1/infos?k=configuration.getPagesSearchPaths.0
 *
 *
 * @package Bartleby\EndPoints
 */
final class Infos extends MongoEndPoint {

    function GET(){
        /* @var InfosCallData */
        $parameters=$this->getModel();
        $infos=array();
        
        // Configuration

        $infos["version_of_Bartleby"]=Configuration::BARTLEBY_VERSION.'.'.Configuration::BARTLEBY_RELEASE;
        $infos["acl_is_disabled"] = $this->getConfiguration()->DISABLE_ACL();
        $infos["configuration"]=array();
        $infos["configuration"]["STAGE"]=$this->getConfiguration()->STAGE();
        $infos["configuration"]["VERSION"]=$this->getConfiguration()->VERSION();
        $infos["configuration"]["getBartlebyRootDirectory"]=$this->getConfiguration()->getBartlebyRootDirectory();
        $infos["configuration"]["getEndpointsSearchPaths"]=$this->getConfiguration()->getEndpointsSearchPaths();
        $infos["configuration"]["getPagesSearchPaths"]=$this->getConfiguration()->getPagesSearchPaths();
        $infos["configuration"]["getPermissionsRules"]=$this->getConfiguration()->getPermissionsRules();
        $infos["configuration"]["getRouteAliases(API)"]=$this->getConfiguration()->getRouteAliases(Mode::API)->getMapping();
        $infos["configuration"]["getRouteAliases(PAGES)"]=$this->getConfiguration()->getRouteAliases(Mode::PAGES)->getMapping();

        $key = $parameters->getValueForKey(InfosCallData::k);
        if (isset($key)) {
            $value = KeyPath::valueForKeyPath($infos, $key);
            if (isset($value)) {
                $infos = array($key => $value);
            } else {
                $infos = 'Key not found "' . $key . '"';
            }
        }

        return new JsonResponse($infos, 200);
    }


}#BMS#->{"filename":"ProtectedRun.php","checksum":1256186297,"relativePath":"Bartleby\/Commons\/EndPoints\/ProtectedRun.php","size":2107}<-#BME#
<?php
namespace Bartleby\Commons\EndPoints;
namespace Bartleby\EndPoints;

require_once BARTLEBY_ROOT_FOLDER . 'Mongo/MongoEndPoint.php';
require_once BARTLEBY_ROOT_FOLDER . 'Mongo/MongoCallDataRawWrapper.php';
require_once BARTLEBY_ROOT_FOLDER . 'Core/HTMLResponse.php';

use Bartleby\Commons\Pages\Bootstrap3XPage;use Bartleby\Core\Configuration;
use Bartleby\Core\HTMLResponse;
use Bartleby\Core\JsonResponse;
use Bartleby\Core\Mode;
use Bartleby\mongo\MongoCallDataRawWrapper;
use Bartleby\Mongo\MongoEndPoint;
use Bartleby\Core\KeyPath;


final class ProtectedRunCallData extends MongoCallDataRawWrapper {

    // Set a key if you want only that key.
    const fileToRun = "fileToRun";

    const  useText = "useText";
}

/**
 * Allow to run a script located in the protected Section
 * eg: http://localhost/api/v1/run?fileToRun=echo.php
 * http://localhost/api/v1/run?fileToRun=maintenance_ephemeralRemover.php
 */
final class ProtectedRun extends MongoEndPoint {

    function GET(){
        /* @var ProtectedRunCallData */
        $parameters=$this->getModel();
        $fileToRun=$parameters->getValueForKey(ProtectedRunCallData::fileToRun);
        $useText=$parameters->getValueForKey(ProtectedRunCallData::useText);
        if(!isset($useText)){
            $useText=false;// We use JSON
        }

        $result=null;
        $filePath=BARTLEBY_PUBLIC_FOLDER.'Protected/'.$fileToRun;
        if (file_exists($filePath)){
            // ( ! ) Template execution
            ob_start ();@include $filePath;$result = ob_get_clean ();
        }else{
            throw  new \Exception("Unexisting file ".$filePath);
        }

        if (!isset($result)){
            $result="Nothing";
        }
        if ($useText && strtolower($useText) == "true") {
            $response=new HTMLResponse();
            $response->document=$result;
            $response->statusCode=200;
            return $response;
        }else{
            $response=json_encode(["message"=>$result]);
            // (!) End of template execution
            return new JsonResponse($response, 200);
        }
    }


}#BMS#->{"filename":"Reachable.php","checksum":925214522,"relativePath":"Bartleby\/Commons\/EndPoints\/Reachable.php","size":1257}<-#BME#
<?php

namespace Bartleby\EndPoints;

require_once BARTLEBY_ROOT_FOLDER . 'Mongo/MongoEndPoint.php';
require_once BARTLEBY_ROOT_FOLDER . 'Mongo/MongoCallDataRawWrapper.php';

use Bartleby\Core\JsonResponse;
use Bartleby\mongo\MongoCallDataRawWrapper;
use Bartleby\Mongo\MongoEndPoint;


final class ReachableCallData extends MongoCallDataRawWrapper {

}

final class Reachable extends MongoEndPoint {

    /**
     * Return 200 if the api is reachable
     * Permission is set to: 'Reachable->GET'=> array('level'=> PERMISSION_NO_RESTRICTION)
     * @param ReachableCallData $parameters
     * @return JsonResponse
     */
    function GET(){
        /* @var ReachableCallData */
        $parameters=$this->getModel();
        return new JsonResponse(VOID_RESPONSE, 200);
    }

    // Auth is required
    /***
     * Return 200 if the api is reachable and the credentials of the user valid for the current context.
     * Permission  is set to: 'Reachable->verify'=> array('level'=> PERMISSION_BY_IDENTIFICATION),
     * @param ReachableCallData $parameters
     * @return JsonResponse
     */
    function verify(){
        /* @var ReachableCallData */
        $parameters=$this->getModel();
        return new JsonResponse(VOID_RESPONSE, 200);
    }


}#BMS#->{"filename":"SSETime.php","checksum":3334601762,"relativePath":"Bartleby\/Commons\/EndPoints\/SSETime.php","size":982}<-#BME#
<?php


namespace Bartleby\EndPoints;
require_once BARTLEBY_ROOT_FOLDER . 'Mongo/MongoEndPoint.php';
require_once BARTLEBY_ROOT_FOLDER . 'Mongo/MongoCallDataRawWrapper.php';
require_once BARTLEBY_ROOT_FOLDER . 'Core/ServerSentEvent.php';


use Bartleby\mongo\MongoCallDataRawWrapper;
use Bartleby\Mongo\MongoEndPoint;
use Bartleby\Core\ServerSentEvent;

final class SSETimeCallData extends MongoCallDataRawWrapper {
}

final class SSETime extends MongoEndPoint {

    function GET() {
        /* @var SSETimeCallData */
        $parameters=$this->getModel();
        // Creation of the SSE
        $sse = new ServerSentEvent(3600); // 1 time per second
        $s=$this;
        // Definition of the closure
        $f=function() use ($s,$sse,$parameters) {
            //$s->getDB();
            $serverTime = time();
            $sse->sendMsg($serverTime,'tic', '{"serverTime":"' . date("h:i:s", time()).'"}');
        };
        $sse->callBack=$f;
        return $sse;
    }

}

#BMS#->{"filename":"SSETriggers.php","checksum":256034214,"relativePath":"Bartleby\/Commons\/EndPoints\/SSETriggers.php","size":5584}<-#BME#
<?php


namespace Bartleby\EndPoints;
require_once BARTLEBY_ROOT_FOLDER . 'Core/JsonResponse.php';
require_once BARTLEBY_ROOT_FOLDER . 'Mongo/MongoEndPoint.php';
require_once BARTLEBY_ROOT_FOLDER . 'Mongo/MongoCallDataRawWrapper.php';
require_once BARTLEBY_ROOT_FOLDER . 'Core/ServerSentEvent.php';


use Bartleby\Core\JsonResponse;
use Bartleby\mongo\MongoCallDataRawWrapper;
use Bartleby\Mongo\MongoEndPoint;
use Bartleby\Core\ServerSentEvent;
use MongoDB;
use MongoCollection;

final class SSETriggersCallData extends MongoCallDataRawWrapper {

    const observationUID = 'observationUID';

    const spaceUID = 'spaceUID';

    const lastIndex = 'lastIndex';

    const runUID = 'runUID';

    const showDetails ='showDetails';

    const sort = 'sort';

}

final class SSETriggers extends MongoEndPoint {

    private $_counter = 0;

    /* @var \MongoDB */
    private $_db;

    /* @var MongoCollection */
    private  $_triggers;

    private $_lastIndex = -1;

    private $_observationUID = NULL;

    private $_runUID = NULL;

    private $_showDetails = false;

    private $_sort = NULL;

    function GET() {
        /* @var SSETriggersCallData */
        $parameters=$this->getModel();
        $s=$this;

        $this->_lastIndex = $parameters->getValueForKey(SSETriggersCallData::lastIndex);
        if (!isset($this->_lastIndex)){
            $this->_lastIndex = -1;
        }
        $this->_observationUID = $this->getObservationUID(true);
        $this->_runUID = $this->getRunUID(true);
        $this->_sort = $parameters->getValueForKey(SSETriggersCallData::sort);

        if ($parameters->keyExists(SSETriggersCallData::showDetails)){
           $showDetailsValue = $parameters->getValueForKey(SSETriggersCallData::showDetails);
            $this->_showDetails = (strtolower($showDetailsValue)=='true');
        }
        $this->_db=$this->getDB();
        $this->_triggers=$this->_db->triggers;

        // Creation of the SSE
        $sse = new ServerSentEvent(60*60); // 1 time per second

        // Definition of the closure
        $f=function() use ($s,$sse,$parameters) {

            try {

                $q = [];

                // Filter by SpaceUID
                $spaceUID=$this->getSpaceUID(true);
                if (isset($spaceUID) && $spaceUID!="") {
                    $q[SPACE_UID_KEY] = $spaceUID;
                }

                // Filter by Observation UID.
                if (isset($this->_observationUID) && $this->_observationUID!="" ) {
                    $q[OBSERVATION_UID_KEY] = $this->_observationUID;
                }

                // Filter by runUID (is essential to prevent data larsen).
                if (isset($this->_runUID) && $this->_runUID!="" ) {
                    $q [RUN_UID_KEY] = [
                        // Not equal
                        '$ne' => $this->_runUID
                    ];
                }

                $q ['index'] = [
                    '$gte' => $this->_lastIndex + 1
                ];

                $cursor = $this->_triggers->find($q);

                if (isset($this->_sort)){
                    $cursor = $cursor->sort([$this->_sort=>1]);
                }

                foreach ($cursor as $trigger) {
                    $serverTime = time();
                    $this->_counter++;
                    $this->_lastIndex = $trigger['index'];
                    $sender = $trigger['senderUID'];
                    $runUID = $trigger[RUN_UID_KEY];
                    $origin = $trigger['origin'];
                    $action = $trigger['action'];
                    $payloads = "";
                    if (array_key_exists('payloads',$trigger)){
                        $payloads = $trigger['payloads'];
                    }
                    $uids = $trigger['UIDS'];
                    $collectionName = $trigger['targetCollectionName'];
                    $observationUID = $trigger[OBSERVATION_UID_KEY];
                    if ($this->_showDetails == false) {
                        // Used by clients includes the payloads
                        $sse->sendMsg($serverTime, 'relay', '{"i":' . $this->_lastIndex .
                            ',"o":"' . $observationUID .
                            '","r":"' . $runUID .
                            '","c":"' . $collectionName .
                            '","a":"' . $action .
                            '","u":"' . $uids .
                            '","p":'.json_encode($payloads).'}');
                    } else {
                        // Used to display the trigger
                        $sse->sendMsg($serverTime, 'relay', '{"i":' . $this->_lastIndex .
                            ',"o":"' . $observationUID .
                            '","r":"' . $runUID .
                            '","c":"' . $collectionName .
                            '","s":"' . $sender .
                            '","n":"' . $origin .
                            '","a":"' . $action .
                            '","u":"' . $uids .
                            '","p":'.json_encode($payloads)
                            .'}');
                    }
                }

            } catch (\Exception $e) {
                $serverTime = time();
                $result=["e"=>$e->getMessage()];
                $sse->sendMsg($serverTime, 'exception', json_encode($result));
            }

        };

        $sse->callBack=$f;
        return $sse;
    }

    function encodeTrigger($trigger){
        $jsonEncoded=json_encode($trigger);
        return str_replace('"','',$jsonEncoded);
    }

}

#BMS#->{"filename":"TriggerAfterIndex.php","checksum":1396442396,"relativePath":"Bartleby\/Commons\/EndPoints\/TriggerAfterIndex.php","size":2690}<-#BME#
<?php

namespace Bartleby\EndPoints;

require_once BARTLEBY_ROOT_FOLDER . 'Mongo/MongoEndPoint.php';
require_once BARTLEBY_ROOT_FOLDER . 'Mongo/MongoCallDataRawWrapper.php';

use Bartleby\Mongo\MongoEndPoint;
use Bartleby\Mongo\MongoCallDataRawWrapper;
use Bartleby\Core\JsonResponse;
use \MongoCollection;

class  TriggerAfterIndexsCallData extends MongoCallDataRawWrapper {
    const lastIndex = 'lastIndex';
}

class  TriggerAfterIndex extends MongoEndPoint {

    function call() {
        /* @var TriggerAfterIndexCallData */
        $parameters=$this->getModel();
        $db = $this->getDB();
        /* @var \MongoCollection */

        $lastIndex = $parameters->getValueForKey(SSETriggersCallData::lastIndex);
        if (!isset($lastIndex)) {
            return new JsonResponse("lastIndex is undefined", 412);
        }

        $collection = $db->triggers;

        $q ['index'] = [
            '$gte' => ($lastIndex + 1)
        ];

        ////////////////////////////////////////////
        // space and Observation UID confinements
        // and runUID eviction
        ////////////////////////////////////////////
        
        try {
            // Restrict to this spaceUID
            $q[SPACE_UID_KEY] = $this->getSpaceUID(false);
        } catch (\Exception $e) {
            return new JsonResponse("spaceUID is undefined", 412);
        }

        try {
            // Restrict to this observationUID
            $q[OBSERVATION_UID_KEY] = $this->getObservationUID(false);
        } catch (\Exception $e) {
            return new JsonResponse("observationUID is undefined", 412);
        }
        try {
            // Filter owned Triggers
            $q [RUN_UID_KEY] = [
                // Not equal
                '$ne' => $this->getRunUID(false)
            ];
        } catch (\Exception $e) {
            return new JsonResponse("runUID is undefined", 412);
        }

        try {
            $r = array();
            $cursor = $collection->find($q);
            // Sort ?
            if ($cursor->count(TRUE) > 0) {
                foreach ($cursor as $obj) {
                    $r[] = $obj;
                }
            }

            if (count($r) > 0) {
                return new JsonResponse($r, 200);
            } else {
                return new JsonResponse(VOID_RESPONSE, 404);
            }
        } catch (\Exception $e) {
            return new JsonResponse(['code' => $e->getCode(),
                'message' => $e->getMessage(),
                'file' => $e->getFile(),
                'line' => $e->getLine(),
                'trace' => $e->getTraceAsString()
            ],
                417
            );
        }
    }
}

?>#BMS#->{"filename":"TriggerForIndexes.php","checksum":2951970534,"relativePath":"Bartleby\/Commons\/EndPoints\/TriggerForIndexes.php","size":2817}<-#BME#
<?php

namespace Bartleby\EndPoints;

require_once BARTLEBY_ROOT_FOLDER . 'Mongo/MongoEndPoint.php';
require_once BARTLEBY_PUBLIC_FOLDER . 'Configuration.php';

use Bartleby\Mongo\MongoEndPoint;
use Bartleby\Mongo\MongoCallDataRawWrapper;
use Bartleby\Core\JsonResponse;
use \MongoCollection;
use Bartleby\Configuration;

class  TriggerForIndexesCallData extends MongoCallDataRawWrapper {
    const indexes='indexes';
}

class  TriggerForIndexes extends MongoEndPoint {

    function call() {
        /* @var TriggerForIndexesCallData */
        $parameters=$this->getModel();
        $db=$this->getDB();
        /* @var \MongoCollection */
        $collection = $db->triggers;
        $indexes=$parameters->getValueForKey(TriggerForIndexesCallData::indexes);

        if(isset ($indexes) && is_array($indexes) && count($indexes)){

            $q = array( 'indexes'=>array( '$in' => $indexes ));

            ////////////////////////////////////////////
            // space and Observation UID confinements
            // and runUID eviction
            ////////////////////////////////////////////

            try {
                // Restrict to this spaceUID
                $q[SPACE_UID_KEY] = $this->getSpaceUID(false);
            } catch (\Exception $e) {
                return new JsonResponse("spaceUID is undefined", 412);
            }

            try {
                // Restrict to this observationUID
                $q[OBSERVATION_UID_KEY] = $this->getObservationUID(false);
            } catch (\Exception $e) {
                return new JsonResponse("observationUID is undefined", 412);
            }
            try {
                // Filter owned Triggers
                $q [RUN_UID_KEY] = [
                    // Not equal
                    '$ne' => $this->getRunUID(false)
                ];
            } catch (\Exception $e) {
                return new JsonResponse("runUID is undefined", 412);
            }
            

        }else{
            return new JsonResponse(VOID_RESPONSE,204);
        }
        try {
            
            $r=array();
            $cursor = $collection->find($q);
            if ($cursor->count ( TRUE ) > 0) {
                foreach ( $cursor as $obj ) {
                    $r[] = $obj;
                }
            }
            if (count($r)>0 ) {
                return new JsonResponse($r,200);
            } else {
                return new JsonResponse(VOID_RESPONSE,404);
            }
        } catch ( \Exception $e ) {
            return new JsonResponse( array ('code'=>$e->getCode(),
                'message'=>$e->getMessage(),
                'file'=>$e->getFile(),
                'line'=>$e->getLine(),
                'trace'=>$e->getTraceAsString()
            ),
                417
            );
        }
    }
}

?>#BMS#->{"filename":"TriggersByIds.php","checksum":318679644,"relativePath":"Bartleby\/Commons\/EndPoints\/TriggersByIds.php","size":2874}<-#BME#
<?php

namespace Bartleby\EndPoints;

require_once BARTLEBY_ROOT_FOLDER . 'Mongo/MongoEndPoint.php';
require_once BARTLEBY_PUBLIC_FOLDER . 'Configuration.php';

use Bartleby\Mongo\MongoEndPoint;
use Bartleby\Mongo\MongoCallDataRawWrapper;
use Bartleby\Core\JsonResponse;
use \MongoCollection;
use Bartleby\Configuration;

class  TriggersByIdsCallData extends MongoCallDataRawWrapper {
    const ids = 'ids';
}

class  TriggersByIds extends MongoEndPoint {

    function call() {
        /* @var TriggersByIdsCallData */
        $parameters=$this->getModel();
        $db = $this->getDB();
        /* @var \MongoCollection */
        $collection = $db->triggers;
        $ids = $parameters->getValueForKey(TriggersByIdsCallData::ids);
        if (isset ($ids) && is_array($ids) && count($ids)) {
            $q = array('_id' => array('$in' => $ids));

            ////////////////////////////////////////////
            // space and Observation UID confinements
            // and runUID eviction
            ////////////////////////////////////////////

            try {
                // Restrict to this spaceUID
                $q[SPACE_UID_KEY] = $this->getSpaceUID(false);
            } catch (\Exception $e) {
                return new JsonResponse("spaceUID is undefined", 412);
            }

            try {
                // Restrict to this observationUID
                $q[OBSERVATION_UID_KEY] = $this->getObservationUID(false);
            } catch (\Exception $e) {
                return new JsonResponse("observationUID is undefined", 412);
            }
            try {
                // Filter owned Triggers
                $q [RUN_UID_KEY] = [
                    // Not equal
                    '$ne' => $this->getRunUID(false)
                ];
            } catch (\Exception $e) {
                return new JsonResponse("runUID is undefined", 412);
            }

        } else {
            return new JsonResponse(VOID_RESPONSE, 204);
        }

        ////////////////////////////////////////////
        // Query
        ////////////////////////////////////////////

        try {
            $r = array();
            $cursor = $collection->find($q);
            if ($cursor->count(TRUE) > 0) {
                foreach ($cursor as $obj) {
                    $r[] = $obj;
                }
            }

            if (count($r) > 0) {
                return new JsonResponse($r, 200);
            } else {
                return new JsonResponse(VOID_RESPONSE, 404);
            }
        } catch (\Exception $e) {
            return new JsonResponse(['code' => $e->getCode(),
                'message' => $e->getMessage(),
                'file' => $e->getFile(),
                'line' => $e->getLine(),
                'trace' => $e->getTraceAsString()
            ],
                417
            );
        }
    }
}

?>#BMS#->{"filename":"VerifyLocker.php","checksum":923470042,"relativePath":"Bartleby\/Commons\/EndPoints\/VerifyLocker.php","size":3768}<-#BME#
<?php

namespace Bartleby\EndPoints;
require_once BARTLEBY_ROOT_FOLDER. 'Mongo/MongoEndPoint.php';
require_once BARTLEBY_ROOT_FOLDER . 'Mongo/MongoCallDataRawWrapper.php';

use Bartleby\mongo\MongoCallDataRawWrapper;
use Bartleby\Mongo\MongoEndPoint;
use Bartleby\Core\JsonResponse;
use Bartleby\Models\User;
use \MongoCursorException;
use \MongoClient;
use Bartleby\Configuration;

final class VerifyLockerCallData extends MongoCallDataRawWrapper {

    /**
     * The locker UID
     */
    const lockerUID = 'lockerUID';

    /**
     * The sent code should be allways salted with the shared salt key client side.
     * You should never transmit or store clear codes.
     */
    const code = 'code';


}

final class VerifyLocker extends MongoEndPoint{

    function POST() {
        /* @var VerifyLockerCallData */
        $parameters=$this->getModel();
        $currentLockerUID = $parameters->getValueForKey(VerifyLockerCallData::lockerUID);
        $proposedCode = $parameters->getValueForKey(VerifyLockerCallData::code);

        $db=$this->getDB();
        /* @var \MongoCollection */
        $collection = $db->lockers;
        if (!isset($currentLockerUID)){
            return new JsonResponse('Query is void',412);
        }
        $q = array ('_id' =>$currentLockerUID);
        try {
            $locker = $collection->findOne($q);
            if (isset($locker)) {
                if (array_key_exists('userUID',$locker) &&
                    array_key_exists('code',$locker)&&
                    array_key_exists('startDate',$locker)&&
                    array_key_exists('endDate',$locker)){
                    $userUID=$locker['userUID'];
                    // We should be able to grab the current user
                    // The verification require a valid logged user
                    $currentUser=$this->_context->getCurrentUser();
                    if (array_key_exists(MONGO_ID_KEY,$currentUser)){
                        // User UID
                        if ($currentUser[MONGO_ID_KEY]==$userUID){
                            // CODE
                            $code=$locker['code'];
                            if ($proposedCode!=$code){
                                return new JsonResponse('Code Missmatch',401);
                            }
                            // TIME
                            $startDate=new \DateTime($locker['startDate']);
                            $endDate=new \DateTime($locker['endDate']);
                            $now=new \DateTime('now');
                            if ($now->getTimestamp() > $startDate->getTimestamp() &&
                                $now->getTimestamp() < $endDate->getTimestamp()){
                                return new JsonResponse($locker,200);
                            }else{
                                return new JsonResponse('Locker is not actually usable (date issue)',401);
                            }
                        }else{
                            return new JsonResponse('User UID missmatch', 403);
                        }
                    }else {
                        return new JsonResponse('Current user is not valid', 412);
                    }
                }else{
                    return new JsonResponse('Found Locker is not valid',401);
                }
            } else {
                return new JsonResponse(VOID_RESPONSE,404);
            }
        } catch ( \Exception $e ) {
            return new JsonResponse( array ('code'=>$e->getCode(),
                'message'=>$e->getMessage(),
                'file'=>$e->getFile(),
                'line'=>$e->getLine(),
                'trace'=>$e->getTraceAsString()
            ),
                417
            );
        }

    }



}#BMS#->{"filename":"FilterCollectionOfEntityPasswordsRemover.php","checksum":416266611,"relativePath":"Bartleby\/Commons\/Filters\/FilterCollectionOfEntityPasswordsRemover.php","size":1194}<-#BME#
<?php

namespace Bartleby\Filters;

require_once dirname(dirname(__DIR__)) . '/Core/IFilter.php';
require_once dirname(dirname(__DIR__)). '/Core/KeyPath.php';

use Bartleby\Core\IFilter;
use Bartleby\Core\KeyPath;


class FilterCollectionOfEntityPasswordsRemover implements IFilter {

    /**
     * You should set the relevant keyPath if necessary
     * @var string
     */
    var $iterableCollectionKeyPath=NULL;

    /**
     * You should set the relevant keyPath if necessary
     * @var string
     */
    var $passwordKeyPath="password";


    function filterData($data){
        if (isset($data)){
            if(isset($this->iterableCollectionKeyPath)){
                $collection=KeyPath::valueForKeyPath($data,$this->iterableCollectionKeyPath);
            }else{
                $collection=$data;
            }
            if (isset($collection) && is_array($collection)){
                foreach ($collection as &$entity) {
                    KeyPath::setValueByReferenceForKeyPath($entity,$this->passwordKeyPath,"");
                }
                // Return the filtered collection
                return $collection;
            }
        }
        return $data;
    }


}#BMS#->{"filename":"FilterEntityPasswordRemover.php","checksum":1564614970,"relativePath":"Bartleby\/Commons\/Filters\/FilterEntityPasswordRemover.php","size":582}<-#BME#
<?php

namespace Bartleby\Filters;

require_once dirname(dirname(__DIR__)) . '/Core/IFilter.php';
require_once dirname(dirname(__DIR__)) . '/Core/KeyPath.php';

use Bartleby\Core\IFilter;
use Bartleby\Core\KeyPath;

class FilterEntityPasswordRemover implements IFilter {

    /**
     * You should set the relevant key if necessary
     * @var string
     */
    var $passwordKeyPath="password";

    function filterData($data){
        if (isset($data)){
            KeyPath::setValueByReferenceForKeyPath($data,$this->passwordKeyPath,"");
        }
        return $data;
    }


}#BMS#->{"filename":"FilterHookByClosure.php","checksum":393212266,"relativePath":"Bartleby\/Commons\/Filters\/FilterHookByClosure.php","size":800}<-#BME#
<?php

namespace Bartleby\Filters;

require_once dirname(dirname(__DIR__)) . '/Core/IFilter.php';

use Closure;
use Bartleby\Core\IFilter;


/**
 * Class FilterHookByClosure
 *  Allows to filter data using a closure.
 * @package Bartleby\Filters
 */
class FilterHookByClosure implements IFilter {

    /* @var $closure Closure */
    var $closure;

    function filterData($data){
        if (isset($data)){
            if(isset($this->closure) && $this->_is_closure($this->closure)){
                return  $this->closure->__invoke($data);
            }else{
                throw new \Exception("Closure expected in FilterHookByClosure");
            }
        }
        return $data;
    }

    private function _is_closure($t) {
        return is_object($t) && ($t instanceof Closure);
    }


}#BMS#->{"filename":"UpdateUser.php","checksum":3737672723,"relativePath":"Bartleby\/Commons\/Overloads\/EndPoints\/UpdateUser.php","size":2660}<-#BME#
<?php

namespace Bartleby\EndPoints\Overloads;

require_once BARTLEBY_ROOT_FOLDER.'Commons/_generated/EndPoints/UpdateUser.php';

use Bartleby\Core\KeyPath;
use Bartleby\Core\CallDataRawWrapper;
use Bartleby\EndPoints\UpdateUserCallData;
use Bartleby\Core\JsonResponse;

class UpdateUser extends \Bartleby\EndPoints\UpdateUser {

    function call() {

        /* @var UpdateUserCallData */
        $parameters=$this->getModel();

        $spaceUID=$this->getSpaceUID(false);
        $user=$parameters->getValueForKey(UpdateUserCallData::user);
        $userID=KeyPath::valueForKeyPath($user,"_id");
        $foundSpaceUID=KeyPath::valueForKeyPath($user,SPACE_UID_KEY);

        if($foundSpaceUID!=$spaceUID){
            $this->_context->consignIssue('Attempt to move a user to another Dataspace has been blocked',__FILE__,__LINE__);
            return new JsonResponse([
                'foundSpaceUID'=>$foundSpaceUID,
                'spaceUID'=>$spaceUID,
                'context'=>$this->_context
            ],403);
        }
        
        ////////////////////////////////
        // VERIFY THE PREVIOUS SPACEUID
        /////////////////////////////////
        
        $db=$this->getDB();
        /* @var \MongoCollection */
        $collection = $db->users;
        $q = array ('_id' =>$userID);
        if (isset($q)&& count($q)>0){
        }else{
            return new JsonResponse('Query is void',412);
        }
        try {
            $r = $collection->findOne($q);
            if (isset($r)) {
       
                $previousSpaceUID=KeyPath::valueForKeyPath($r,SPACE_UID_KEY);
                if($previousSpaceUID!=$spaceUID){
                    $this->_context->consignIssue('Dataspace inconsistency has been blocked',__FILE__,__LINE__);
                    return new JsonResponse([
                        'foundSpaceUID'=>$foundSpaceUID,
                        'spaceUID'=>$spaceUID,
                        'context'=>$this->_context
                    ],403);
                }
                ///////////////////////////
                // CALL THE PARENT LOGIC
                ///////////////////////////
                
                return parent::call($parameters);
            } else {
                return new JsonResponse(VOID_RESPONSE,404);
            }
        } catch ( \Exception $e ) {
            return new JsonResponse([
                'code'=>$e->getCode(),
                'message'=>$e->getMessage(),
                'file'=>$e->getFile(),
                'line'=>$e->getLine(),
                'trace'=>$e->getTraceAsString()
            ],
                417
            );
        }



    }

}#BMS#->{"filename":"UpdateUsers.php","checksum":1795636088,"relativePath":"Bartleby\/Commons\/Overloads\/EndPoints\/UpdateUsers.php","size":1332}<-#BME#
<?php

namespace Bartleby\EndPoints\Overloads; // (!) Important  

require_once BARTLEBY_ROOT_FOLDER.'Commons/_generated/EndPoints/UpdateUsers.php';

use Bartleby\Core\KeyPath;
use Bartleby\Core\CallDataRawWrapper;
use Bartleby\EndPoints\UpdateUsersCallData;

class UpdateUsers extends \Bartleby\EndPoints\UpdateUsers {

    function call() {
        /* @var UpdateUserCallData */
        $parameters=$this->getModel();
        $spaceUID=$this->getSpaceUID(false);
        $users=$arrayOfObject=$parameters->getValueForKey(UpdateUsersCallData::users);
        foreach ($users as $user) {
            $foundSpaceUID=KeyPath::valueForKeyPath($user,SPACE_UID_KEY);
            if($foundSpaceUID!=$spaceUID){
                $this->_context->consignIssue('Dataspace inconsistency has been blocked',__FILE__,__LINE__);
                return new JsonResponse([
                    'foundSpaceUID'=>$foundSpaceUID,
                    'spaceUID'=>$spaceUID,
                    'context'=>$this->_context
                ],403);
            }
        }

        ////////////////////////////////
        // VERIFY THE PREVIOUS SPACEUID ?
        /////////////////////////////////

        // We currently donnot verify previous UID has the Multi update requires super admins privileges.


        return parent::call($parameters);
    }

}#BMS#->{"filename":"Bootstrap3XPage.php","checksum":1667139132,"relativePath":"Bartleby\/Commons\/Pages\/Bootstrap3XPage.php","size":5008}<-#BME#
<?php

namespace Bartleby\Commons\Pages;

require_once BARTLEBY_ROOT_FOLDER . 'Mongo/MongoHTML5Page.php';
require_once BARTLEBY_ROOT_FOLDER . 'Mongo/MongoCallDataRawWrapper.php';

use Bartleby\Core\HTMLResponse;
use Bartleby\mongo\MongoCallDataRawWrapper;
use Bartleby\Mongo\MongoHTML5Page;


/**
 * Class Bootstrap3XPage
 *
 * A base page class with all the required resources to be able to use Bootstrap 3.X
 * You should expose a www/static/css/style.css
 * @package Bartleby\Commons\Pages
 */
abstract class Bootstrap3XPage extends MongoHTML5Page{

    /////////////////////////
    //
    // * PAGE LAYOUT *
    //
    // <head>
    //   <!-- metas -->
    // </head>
    // <body>
    //  <!--mainContent-->
    //  <!--scripts -->
    // </body>
    //
    //////////////////////////

    protected $_useCdn=false;

    /***
     * Setup method is called before to create the document.
     */
    function setup(){
        $this->_addJQuery();
        $this->_addBootstrapJS();
    }


    /**
     * Returns the global HTML5 response
     * @return HTMLResponse
     */
    function getDocument() {
        $this->setup();
        $r=new HTMLResponse();
        $r->statusCode=200;
        $r->document='<!DOCTYPE html>
<html lang="'.$this->_lang.'">
  <head>
    <meta charset="'.$this->_charset.'">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    '.$this->_metas().'
    <title>'.$this->_title.'</title>'
            .$this->_BootStrap()
            .$this->_top_scripts().'
    <!-- CSS -->'
            .$this->_CSSLink()
            .$this->_IE_Block().
            '
  </head>
  <body>
  <!--main content -->'
            .$this->mainContent().'
  <!-scripts-->'
            .$this->_bottom_scripts() .'
  </body>
</html>';

        return $r;
    }

    /***
     * Called to render the main content.
     * @return string
     */
    function mainContent(){
        return '';
    }


    ////////////////
    // JS and CSS
    ////////////////


    private  function _addBootstrapJS(){
        if ($this->_useCdn==true){
            $this->addTopScript('
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>');
        }else{
            $this->addTopScript('
    <script src="'.$this->absoluteUrl('static/vendors/bootstrap/3.3.6/js/bootstrap.min.js').'"></script>');
        }
    }


    private  function _addJQuery(){
        if ($this->_useCdn==true){
            $this->addTopScript('
    <!-- jQuery (necessary for Bootstrap\'s JavaScript plugins) -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>');
        }else{
            $this->addTopScript('
    <!-- jQuery (necessary for Bootstrap\'s JavaScript plugins) -->
    <script src="'.$this->absoluteUrl('static/vendors/jquery/jquery-1.12.4.min.js').'"></script>');
        }
    }

    private  function _IE_Block() {
        if ($this->_useCdn == true) {
            return '
    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn\'t work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->';
        } else {
            return '
    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn\'t work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="' . $this->absoluteUrl('static/vendors/html5shiv/3.7.3/html5shiv.min.js') . '"></script>
      <script src="' . $this->absoluteUrl('static/vendors/respond/1.4.2/html5shiv.min.js') . '"></script>
    <![endif]-->';
        }
    }

    /**
     * @return string return a CDN link for bootstrap
     */
    private function _BootStrap(){
        if ($this->_useCdn==true){
            return'
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap-theme.min.css" integrity="sha384-fLW2N01lMqjakBkx3l/M9EahuwpSfeNvV63J5ezn3uZzapT0u7EYsXMjQV+0En5r" crossorigin="anonymous">';
        }else{
            return'
    <link rel="stylesheet" href="'.$this->absoluteUrl('static/vendors/bootstrap/3.3.6/css/bootstrap.min.css').'">
    <link rel="stylesheet" href="'.$this->absoluteUrl('static/vendors/bootstrap/3.3.6/css/bootstrap-theme.min.css').'">';
        }
    }

}#BMS#->{"filename":"PostInstaller.php","checksum":3139482319,"relativePath":"Bartleby\/Commons\/Tools\/PostInstaller.php","size":1541}<-#BME#
<?php
/**
 * Created by PhpStorm.
 * User: bpds
 * Date: 04/06/2016
 * Time: 07:52
 */

namespace Bartleby\Tools;

require_once BARTLEBY_PUBLIC_FOLDER . 'Configuration.php';

use \MongoClient;
use Bartleby\Core\Stages;

class PostInstaller {

    function logMessage($message=""){
        echo ($message."<br>\n");
    }

    /*@var MongoDb */
    protected $_db;

    function run($configuration){
        
        $this->logMessage ("");
        $this->logMessage ("Running Bartleby's POST INSTALLER");
        try {
            $this->logMessage("Connecting to MONGO");
            $m = new MongoClient();
        } catch (Exception $e) {
            $this->logMessage("Mongo client must be installed ". $e->getMessage());
        }
        $this->logMessage("Selecting the database  ".$configuration->MONGO_DB_NAME());
        $db = $m->selectDB($configuration->MONGO_DB_NAME());// Selecting  base

        // INDEXES

        // TRIGGERS
        // We want to be able to filter very fast the triggers
        // With multiple criteria
        $this->logMessage("Creating 'spaceUID' Index");
        $db->triggers->createIndex(array('spaceUID' => 1));
        $this->logMessage("Creating 'index' Index");
        $db->triggers->createIndex(array('index' => 1), array());
        $this->logMessage("Creating 'observationUID' Index");
        $db->triggers->createIndex(array('observationUID' => 1), array());
        $this->logMessage("Creating 'runUID' Index");
        $db->triggers->createIndex(array('runUID' => 1), array());
    }

}#BMS#->{"filename":"bartleby.json","checksum":1220489113,"relativePath":"Bartleby\/Commons.flexions\/App\/datasources\/bartleby.json","size":160601}<-#BME#
{
    "bartleby-json-modeling": "1.0",
    "info": {
        "description": "This is Bartleby commons API",
        "version": "0.9.beta1",
        "title": "Bartleby",
        "license": {
            "name": "Proprietary",
            "url": "http://www.chaosmos.fr/license.html"
        }
    },
    "host": "pereira-da-silva.com/clients/lylo/",
    "basePath": "/api/v1",
    "tags": [],
    "schemes": [
        "https"
    ],
    "definitions": {
        "CollectionMetadatum": {
            "description": "Bartleby's Core: Collection Metadatum. Complete implementation in CollectionMetadatum",
            "allOf": [
                {
                    "type": "object",
                    "required": [],
                    "properties": {
                        "storage": {
                            "type": "enum",
                            "instanceOf": "string",
                            "emumPreciseType": "CollectionMetadatum.Storage",
                            "description": "the used file storage",
                            "enum": [
                                "monolithicFileStorage"
                            ],
                            "default": ".monolithicFileStorage",
                            "supervisable": false
                        },
                        "collectionName": {
                            "type": "string",
                            "description": "The holding collection name",
                            "default": "\\(Default.NO_NAME)",
                            "supervisable": false
                        },
                        "proxy": {
                            "explicitType": "JObject",
                            "description": "The proxy object (not serializable, not supervisable)",
                            "serializable": false,
                            "supervisable": false
                        },
                        "allowDistantPersistency": {
                            "type": "boolean",
                            "description": "Allow distant persistency?",
                            "default": "true",
                            "supervisable": false
                        },
                        "inMemory": {
                            "type": "Boolean",
                            "description": "In Memory?",
                            "default": "true",
                            "supervisable": false
                        }
                    }
                }
            ],
            "metadata": {
                "urdMode": false
            }
        },
        "Progression": {
            "description": "Bartleby's Commons: A progression state",
            "allOf": [
                {
                    "type": "object",
                    "required": [],
                    "properties": {
                        "startTime": {
                            "type": "double",
                            "description": "The start time of the progression state",
                            "required": false,
                            "serialisable": true,
                            "supervisable": false,
                            "dynamic": false
                        },
                        "currentTaskIndex": {
                            "type": "integer",
                            "description": "Index of the task",
                            "default": 0,
                            "required": true
                        },
                        "totalTaskCount": {
                            "type": "integer",
                            "description": "Total number of tasks",
                            "default": 0,
                            "required": true
                        },
                        "currentPercentProgress": {
                            "type": "double",
                            "description": "0 to 100",
                            "default": 0,
                            "required": true
                        },
                        "message": {
                            "type": "string",
                            "description": "The Message",
                            "default": "",
                            "required": true
                        },
                        "informations": {
                            "type": "string",
                            "description": "The consolidated information (may include the message)",
                            "default": "",
                            "required": true
                        },
                        "data": {
                            "type": "data",
                            "description": "The associated data",
                            "required": false
                        },
                        "category": {
                            "type": "string",
                            "description": "A category to discriminate bunch of progression states",
                            "default": "",
                            "required": true,
                            "supervisable": false
                        },
                        "externalIdentifier": {
                            "type": "string",
                            "description": "An external identifier",
                            "default": "",
                            "required": true,
                            "supervisable": false
                        }
                    }
                }
            ],
            "metadata": {
                "urdMode": false
            }
        },
        "Completion": {
            "description": "Bartleby's Commons: A completion state",
            "allOf": [
                {
                    "type": "object",
                    "required": [],
                    "properties": {
                        "success": {
                            "type": "boolean",
                            "description": "Success if set to true",
                            "default": "true",
                            "required": true
                        },
                        "statusCode": {
                            "type": "integer",
                            "description": "The status",
                            "default": "StatusOfCompletion.undefined.rawValue",
                            "required": true
                        },
                        "message": {
                            "type": "string",
                            "description": "The Message",
                            "default": "",
                            "required": true
                        },
                        "data": {
                            "type": "data",
                            "description": "completion data",
                            "required": false
                        },
                        "category": {
                            "type": "string",
                            "description": "A category to discriminate bunch of completion states",
                            "default": "",
                            "required": true,
                            "supervisable": false
                        },
                        "externalIdentifier": {
                            "type": "string",
                            "description": "An external identifier",
                            "default": "",
                            "required": true,
                            "supervisable": false
                        }
                    }
                }
            ],
            "metadata": {
                "urdMode": false
            }
        },
        "RegistryMetadata": {
            "description": "Bartleby's Core: Complete implementation in JRegistryMetadata. All its properties are not supervisable.",
            "allOf": [
                {
                    "type": "object",
                    "required": [],
                    "properties": {
                        "spaceUID": {
                            "type": "string",
                            "description": "The data space UID can be shared between multiple registries.",
                            "default": "\\(Default.NO_UID)",
                            "supervisable": false
                        },
                        "currentUser": {
                            "schema": {
                                "description": "The user currently associated to the local instance of the registry",
                                "$ref": "#/definitions/User",
                                "supervisable": false,
                                "cryptable": false
                            }
                        },
                        "identificationMethod": {
                            "type": "enum",
                            "instanceOf": "string",
                            "emumPreciseType": "RegistryMetadata.IdentificationMethod",
                            "description": "The identification method (By cookie or by Key - kvid)",
                            "enum": [
                                "key",
                                "cookie"
                            ],
                            "default": ".key",
                            "supervisable": false
                        },
                        "identificationValue": {
                            "type": "string",
                            "description": "The current kvid identification value (injected in HTTP headers)",
                            "supervisable": false
                        },
                        "rootObjectUID": {
                            "type": "string",
                            "description": "The rootObject UID",
                            "default": "\\(Default.NO_UID)",
                            "supervisable": false
                        },
                        "collaborationServerURL": {
                            "type": "url",
                            "description": "The url of the collaboration server",
                            "supervisable": false
                        },
                        "collectionsMetadata": {
                            "schema": {
                                "description": "The collection of CollectionMetadatum ",
                                "type": "array",
                                "items": {
                                    "description": "A collection of CollectionMetadatum",
                                    "explicitType": "CollectionMetadatum",
                                    "default": "[CollectionMetadatum]()",
                                    "supervisable": false
                                }
                            }
                        },
                        "stateDictionary": {
                            "type": "dictionary",
                            "description": "The State dictionary to insure registry persistency ",
                            "default": "[String:AnyObject]()",
                            "supervisable": false
                        },
                        "URLBookmarkData": {
                            "type": "dictionary",
                            "description": "The collection of serialized Security-Scoped Bookmarks (you should store Data)",
                            "default": "[String:AnyObject]()",
                            "supervisable": false
                        },
                        "preferredFileName": {
                            "type": "string",
                            "description": "The preferred filename for this registry/document",
                            "supervisable": false
                        },
                        "triggersIndexesDebugHistory": {
                            "schema": {
                                "type": "array",
                                "items": {
                                    "description": "used for Core Debug , stores all the indexes by order of reception.",
                                    "instanceOf": "integer",
                                    "default": "[Int]()",
                                    "supervisable": false
                                }
                            }
                        },
                        "triggersIndexes": {
                            "schema": {
                                "type": "array",
                                "items": {
                                    "description": "A collection of trigger Indexes (used to detect data holes)",
                                    "instanceOf": "integer",
                                    "default": "[Int]()",
                                    "supervisable": false
                                }
                            }
                        },
                        "ownedTriggersIndexes": {
                            "schema": {
                                "type": "array",
                                "items": {
                                    "description": "The persistentcollection of triggers indexes owned by the current user (allows local distinctive analytics even on cloned documents)",
                                    "instanceOf": "integer",
                                    "default": "[Int]()",
                                    "supervisable": false
                                }
                            }
                        },
                        "lastIntegratedTriggerIndex": {
                            "type": "integer",
                            "description": "The index of the last trigger that has been integrated",
                            "default": -1,
                            "dynamic": false,
                            "supervisable": false
                        },
                        "receivedTriggers": {
                            "schema": {
                                "type": "array",
                                "items": {
                                    "description": "A collection Triggers that are temporarly stored before data integration",
                                    "$ref": "#/definitions/Trigger",
                                    "default": "[Trigger]()",
                                    "supervisable": false
                                }
                            }
                        },
                        "operationsQuarantine": {
                            "schema": {
                                "type": "array",
                                "items": {
                                    "description": "A collection of PushOperations in Quarantine (check DataSynchronization.md \"Faults\" section for details) ",
                                    "$ref": "#/definitions/PushOperation",
                                    "default": "[PushOperation]()",
                                    "supervisable": false
                                }
                            }
                        },
                        "bunchInProgress": {
                            "type": "boolean",
                            "description": "Do we have operations in progress in the current bunch ?",
                            "default": "false",
                            "supervisable": false,
                            "serializable": false
                        },
                        "totalNumberOfOperations": {
                            "type": "integer",
                            "description": "The highest number that we may have counted",
                            "default": 0,
                            "dynamic": false,
                            "supervisable": false,
                            "serializable": false
                        },
                        "pendingOperationsProgressionState": {
                            "schema": {
                                "description": "The consolidated progression state of all pending operations",
                                "$ref": "#/definitions/Progression",
                                "supervisable": false,
                                "required": false,
                                "serializable": false
                            }
                        },
                        "online": {
                            "type": "boolean",
                            "description": "is the user performing Online",
                            "default": "Bartleby.configuration.ONLINE_BY_DEFAULT",
                            "supervisable": true
                        },
                        "pushOnChanges": {
                            "type": "boolean",
                            "description": "If set to true any object creation, update, or deletion will be pushed as soon as possible.",
                            "default": "Bartleby.configuration.ONLINE_BY_DEFAULT",
                            "supervisable": true
                        },
                        "saveThePassword": {
                            "type": "boolean",
                            "description": "Save the password or not?",
                            "default": "Bartleby.configuration.SAVE_PASSWORD_DEFAULT_VALUE",
                            "supervisable": true
                        }
                    }
                }
            ],
            "metadata": {
                "urdMode": false
            }
        },
        "User": {
            "description": "Bartleby's Core: a user in a specified data Space",
            "allOf": [
                {
                    "type": "object",
                    "required": [
                        "spaceUID",
                        "phoneNumber",
                        "password"
                    ],
                    "properties": {
                        "externalID": {
                            "type": "string",
                            "description": "An external unique identifier"
                        },
                        "spaceUID": {
                            "type": "string",
                            "description": "The spaceUID. A user with the same credentials can exists within multiple Data space.",
                            "default": "\\(Bartleby.createUID())"
                        },
                        "verificationMethod": {
                            "type": "enum",
                            "instanceOf": "string",
                            "emumPreciseType": "User.VerificationMethod",
                            "description": "the verification method",
                            "enum": [
                                "none",
                                "byPhoneNumber",
                                "byEmail"
                            ],
                            "default": ".byPhoneNumber"
                        },
                        "firstname": {
                            "type": "string",
                            "default": "\\(Bartleby.randomStringWithLength(5))"
                        },
                        "lastname": {
                            "type": "string",
                            "default": "\\(Bartleby.randomStringWithLength(5))"
                        },
                        "email": {
                            "description": "The user's email. Can be the secondary Identification source ",
                            "type": "string"
                        },
                        "phoneNumber": {
                            "description": "The user's phone number. Can be the secondary Identification source ",
                            "type": "string"
                        },
                        "password": {
                            "description": "The hashed version of the user password",
                            "type": "string",
                            "default": "\\(Bartleby.randomStringWithLength(8,signs:Bartleby.configuration.PASSWORD_CHAR_CART))",
                            "cryptable": true
                        },
                        "activationCode": {
                            "description": "An activation code",
                            "type": "string",
                            "default": "\\(Bartleby.randomStringWithLength(8,signs:Bartleby.configuration.PASSWORD_CHAR_CART))"
                        },
                        "status": {
                            "type": "enum",
                            "instanceOf": "string",
                            "emumPreciseType": "User.Status",
                            "description": "User Status",
                            "enum": [
                                "new",
                                "actived",
                                "suspended"
                            ],
                            "default": ".new"
                        },
                        "tags": {
                            "schema": {
                                "type": "array",
                                "items": {
                                    "description": "The user Tags. External reference to Tags instances",
                                    "$ref": "#/definitions/ExternalReference",
                                    "required": true,
                                    "default": "[ExternalReference]()"
                                }
                            }
                        },
                        "notes": {
                            "type": "string",
                            "description": "Notes"
                        },
                        "loginHasSucceed": {
                            "type": "boolean",
                            "description": "set to true on the first successfull login in the session (this property is not serialized)",
                            "default": "false",
                            "supervisable": false,
                            "serializable": false
                        }
                    }
                }
            ],
            "metadata": {
                "urdMode": false,
                "groupable": false
            }
        },
        "Locker": {
            "description": "Bartleby's Core: a locker",
            "allOf": [
                {
                    "type": "object",
                    "required": [
                        "spaceUID",
                        "username",
                        "password"
                    ],
                    "properties": {
                        "registryUID": {
                            "type": "string",
                            "description": "The associated registry UID."
                        },
                        "subjectUID": {
                            "description": "The subject UID you want to lock",
                            "type": "string",
                            "default": "\\(Default.NO_UID)"
                        },
                        "userUID": {
                            "description": "The userUID that can unlock the locker",
                            "type": "string",
                            "default": "\\(Default.NO_UID)"
                        },
                        "mode": {
                            "type": "enum",
                            "instanceOf": "string",
                            "emumPreciseType": "Locker.Mode",
                            "description": "the locker mode",
                            "enum": [
                                "autoDestructive",
                                "persistent"
                            ],
                            "default": ".autoDestructive"
                        },
                        "verificationMethod": {
                            "type": "enum",
                            "instanceOf": "string",
                            "emumPreciseType": "Locker.VerificationMethod",
                            "description": "the locker mode",
                            "enum": [
                                "online",
                                "offline"
                            ],
                            "default": ".online"
                        },
                        "code": {
                            "description": "This code should be crypted / decrypted",
                            "type": "string",
                            "default": "\\(Bartleby.randomStringWithLength(6,signs:\"0123456789ABCDEFGHJKMNPQRZTUVW\"))"
                        },
                        "numberOfAttempt": {
                            "description": "The number of attempts",
                            "type": "integer",
                            "default": 3
                        },
                        "startDate": {
                            "type": "date",
                            "definition": "the starting date. If Locker.verifyed.online The server date will be used as reference",
                            "default": "Date.distantPast"
                        },
                        "endDate": {
                            "type": "date",
                            "definition": "the ending date. If Locker.verifyed.online The server date will be used as reference",
                            "default": "Date.distantFuture"
                        },
                        "gems": {
                            "description": "Thoses data gems will be return on success",
                            "type": "string",
                            "default": "\\(Default.NO_GEM)"
                        }
                    }
                }
            ],
            "metadata": {
                "urdMode": false
            }
        },
        "ExternalReference": {
            "description": "Bartleby's Core: an ExternalReference stores all the necessary data to find a unique resource.",
            "allOf": [
                {
                    "type": "object",
                    "required": [
                        "iUID"
                    ],
                    "properties": {
                        "iUID": {
                            "description": "The UID of the referred instance",
                            "type": "string",
                            "default": "\\(Default.NO_UID)"
                        },
                        "iTypeName": {
                            "description": "The typeName of the referred instance",
                            "type": "string",
                            "default": "\\(Default.NO_UID)"
                        }
                    }
                }
            ],
            "metadata": {
                "urdMode": false
            }
        },
        "PushOperation": {
            "description": "Bartleby's Core: an object used to provision serialized operation. All its properties are not supervisable",
            "allOf": [
                {
                    "type": "object",
                    "properties": {
                        "commandUID": {
                            "type": "string",
                            "description": "The unique identifier of the related Command",
                            "supervisable": false
                        },
                        "toDictionary": {
                            "description": "The dictionary representation of a serialized action call",
                            "type": "dictionary",
                            "supervisable": false
                        },
                        "responseDictionary": {
                            "description": "The dictionary representation of the last response serialized data",
                            "type": "dictionary",
                            "supervisable": false,
                            "dynamic": false
                        },
                        "completionState": {
                            "schema": {
                                "description": "The completion state of the operation",
                                "$ref": "#/definitions/Completion",
                                "supervisable": false
                            }
                        },
                        "status": {
                            "type": "enum",
                            "instanceOf": "string",
                            "emumPreciseType": "PushOperation.Status",
                            "description": "The invocation Status None: on creation, Pending: can be pushed, Provisionned: is currently in an operation bunch, InProgress: the endpoint has been called, Completed : The end point call has been completed",
                            "enum": [
                                "none",
                                "pending",
                                "provisionned",
                                "inProgress",
                                "completed"
                            ],
                            "default": ".none",
                            "supervisable": false
                        },
                        "counter": {
                            "description": "The invocation counter",
                            "type": "integer",
                            "supervisable": false,
                            "default": -1,
                            "required": true
                        },
                        "creationDate": {
                            "description": "The creationdate",
                            "type": "date",
                            "supervisable": false
                        },
                        "lastInvocationDate": {
                            "description": "The last invocation date",
                            "type": "date",
                            "supervisable": false
                        }
                    }
                }
            ],
            "metadata": {
                "urdMode": false,
                "persistsLocallyOnlyInMemory": false,
                "allowDistantPersistency": false,
                "undoable": false
            }
        },
        "Trigger": {
            "description": "Bartleby's Core: a Trigger encapsulates a bunch of ExternalReferencees that's modelizes a state transformation",
            "allOf": [
                {
                    "type": "object",
                    "properties": {
                        "index": {
                            "description": "The index is injected server side (each dataspace-registry) has it own counter)",
                            "type": "integer",
                            "format": "int64",
                            "supervisable": false,
                            "default": -1
                        },
                        "spaceUID": {
                            "description": "The dataSpace UID",
                            "type": "string",
                            "supervisable": false
                        },
                        "observationUID": {
                            "description": "The observation UID for a given document correspond  to the Registry.rootObjectUID",
                            "type": "string",
                            "required": false,
                            "supervisable": false
                        },
                        "senderUID": {
                            "description": "The user.UID of the sender",
                            "type": "string",
                            "supervisable": false
                        },
                        "runUID": {
                            "description": "The UID of the instance of Bartleby client that has created the trigger.",
                            "type": "string",
                            "supervisable": false
                        },
                        "origin": {
                            "description": "The action that has initiated the trigger",
                            "type": "string",
                            "required": false,
                            "supervisable": false
                        },
                        "targetCollectionName": {
                            "description": "The targetted collection name",
                            "type": "string",
                            "required": true,
                            "default": "",
                            "supervisable": false
                        },
                        "creationDate": {
                            "description": "The server side creation date ( informative, use index for ranking)",
                            "type": "date",
                            "required": false,
                            "supervisable": false
                        },
                        "action": {
                            "description": "The action name",
                            "type": "string",
                            "required": true,
                            "default": "",
                            "supervisable": false
                        },
                        "UIDS": {
                            "description": "A coma separated UIDS list",
                            "type": "string",
                            "required": true,
                            "default": "",
                            "supervisable": false
                        },
                        "payloads": {
                            "schema": {
                                "type": "array",
                                "items": {
                                    "description": "A collection of JSON payload",
                                    "explicitType": "dictionary",
                                    "supervisable": false
                                }
                            }
                        }
                    }
                }
            ],
            "metadata": {
                "urdMode": false,
                "persistsLocallyOnlyInMemory": false,
                "allowDistantPersistency": false,
                "undoable": false
            }
        },
        "Tag": {
            "description": "Bartleby's Core: a tag can be used to classify instances.",
            "allOf": [
                {
                    "type": "object",
                    "properties": {
                        "creationDate": {
                            "type": "string",
                            "format": "date-time"
                        },
                        "color": {
                            "type": "string"
                        },
                        "icon": {
                            "type": "string"
                        }
                    }
                }
            ],
            "metadata": {
                "urdMode": false
            }
        },
        "JString": {
            "description": "Bartleby's Core: String Primitive Wrapper.",
            "allOf": [
                {
                    "type": "object",
                    "properties": {
                        "string": {
                            "type": "string",
                            "description": "the embedded String"
                        }
                    }
                }
            ],
            "metadata": {
                "urdMode": false
            }
        },
        "JData": {
            "description": "Bartleby's Core: Data Primitive Wrapper.",
            "allOf": [
                {
                    "type": "object",
                    "properties": {
                        "data": {
                            "type": "data",
                            "description": "the data"
                        }
                    }
                }
            ],
            "metadata": {
                "urdMode": false
            }
        }
    },
    "paths": {
        "/collectionMetadatum/{collectionMetadatumId}": {
            "get": {
                "tags": [
                    "collectionMetadata"
                ],
                "summary": "Find CollectionMetadatum by ID",
                "description": "Returns a single CollectionMetadatum",
                "operationId": "readCollectionMetadatumById",
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "name": "collectionMetadatumId",
                        "in": "path",
                        "description": "The unique identifier the the of CollectionMetadatum",
                        "required": true,
                        "type": "string"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "successful operation",
                        "schema": {
                            "$ref": "#/definitions/CollectionMetadatum"
                        }
                    },
                    "404": {
                        "description": "CollectionMetadatum not found"
                    }
                }
            }
        },
        "/collectionMetadatum": {
            "post": {
                "tags": [
                    "collectionMetadata"
                ],
                "summary": "Creates a new CollectionMetadatum to the system",
                "description": "",
                "operationId": "createCollectionMetadatum",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "in": "body",
                        "name": "collectionMetadatum",
                        "description": "The instance ofCollectionMetadatum that needs to be added",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/CollectionMetadatum"
                        }
                    }
                ],
                "responses": {
                    "405": {
                        "description": "Invalid input"
                    }
                },
                "metadata": {
                    "urdMode": false
                }
            },
            "put": {
                "tags": [
                    "collectionMetadata"
                ],
                "summary": "Update an existing CollectionMetadatum",
                "description": "",
                "operationId": "updateCollectionMetadatum",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "in": "body",
                        "name": "collectionMetadatum",
                        "description": "The CollectionMetadatum instance to update",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/CollectionMetadatum"
                        }
                    }
                ],
                "responses": {
                    "400": {
                        "description": "Invalid ID supplied"
                    },
                    "404": {
                        "description": "CollectionMetadatum not found"
                    },
                    "405": {
                        "description": "Validation exception"
                    }
                }
            },
            "delete": {
                "tags": [
                    "collectionMetadata"
                ],
                "summary": "Deletes a CollectionMetadatum",
                "description": "",
                "operationId": "deleteCollectionMetadatum",
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "name": "collectionMetadatumId",
                        "in": "path",
                        "description": "The identifier of the CollectionMetadatum to be deleted",
                        "required": true,
                        "type": "string"
                    }
                ],
                "responses": {
                    "400": {
                        "description": "Invalid CollectionMetadatum value"
                    }
                }
            }
        },
        "/collectionMetadata": {
            "post": {
                "tags": [
                    "collectionMetadata"
                ],
                "summary": "Create collectionMetadata to the system",
                "description": "",
                "operationId": "createCollectionMetadata",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "in": "body",
                        "name": "collectionMetadata",
                        "description": "Collection of CollectionMetadatum that needs to be added",
                        "required": true,
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/CollectionMetadatum"
                            }
                        }
                    }
                ],
                "responses": {
                    "405": {
                        "description": "Invalid input"
                    }
                },
                "metadata": {
                    "urdMode": false
                }
            },
            "get": {
                "tags": [
                    "collectionMetadata"
                ],
                "summary": "Find collectionMetadata by ID",
                "description": "Returns a collection of CollectionMetadatum",
                "operationId": "readCollectionMetadataByIds",
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "name": "ids",
                        "in": "path",
                        "description": "The IDS of the collectionMetadata to return",
                        "required": true,
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    {
                        "in": "body",
                        "name": "result_fields",
                        "description": "the result fields (MONGO DB)",
                        "required": true,
                        "schema": {
                            "type": "array",
                            "items": {
                                "type": "string"
                            }
                        }
                    },
                    {
                        "in": "body",
                        "name": "sort",
                        "description": "the sort (MONGO DB)",
                        "required": false,
                        "type": "dictionary"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "successful operation",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/CollectionMetadatum"
                            }
                        }
                    },
                    "400": {
                        "description": "Invalid IDS supplied"
                    },
                    "404": {
                        "description": "CollectionMetadata not found"
                    }
                }
            },
            "put": {
                "tags": [
                    "collectionMetadata"
                ],
                "summary": "Update an existing CollectionMetadatum",
                "description": "",
                "operationId": "updateCollectionMetadata",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "in": "body",
                        "name": "collectionMetadata",
                        "description": "Collection of CollectionMetadatum to update",
                        "required": true,
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/CollectionMetadatum"
                            }
                        }
                    }
                ],
                "responses": {
                    "400": {
                        "description": "Invalid IDS supplied"
                    },
                    "404": {
                        "description": "CollectionMetadata not found"
                    },
                    "405": {
                        "description": "Validation exception"
                    }
                }
            },
            "delete": {
                "tags": [
                    "collectionMetadata"
                ],
                "summary": "Deletes some collectionMetadata",
                "description": "",
                "operationId": "deleteCollectionMetadata",
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "name": "ids",
                        "in": "path",
                        "description": "The ids of collectionMetadata to delete",
                        "required": true,
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    }
                ],
                "responses": {
                    "400": {
                        "description": "Invalid collectionMetadata value"
                    }
                }
            }
        },
        "/collectionMetadataByQuery": {
            "get": {
                "tags": [
                    "collectionMetadata"
                ],
                "summary": "Find collectionMetadata by query (check $q, $s, $f in Bartleby's MongoCallDataRawWrapper)",
                "description": "Returns a collection of CollectionMetadatum",
                "operationId": "readCollectionMetadataByQuery",
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "in": "body",
                        "name": "result_fields",
                        "description": "the result fields (MONGO DB)",
                        "required": true,
                        "schema": {
                            "type": "array",
                            "items": {
                                "type": "string"
                            }
                        }
                    },
                    {
                        "in": "body",
                        "name": "sort",
                        "description": "the sort (MONGO DB)",
                        "required": false,
                        "type": "dictionary"
                    },
                    {
                        "in": "body",
                        "name": "query",
                        "description": "the query (MONGO DB)",
                        "required": false,
                        "type": "dictionary"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "successful operation",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/CollectionMetadatum"
                            }
                        }
                    },
                    "400": {
                        "description": "Invalid IDS supplied"
                    },
                    "404": {
                        "description": "CollectionMetadata not found"
                    }
                }
            }
        },
        "/progression/{progressionId}": {
            "get": {
                "tags": [
                    "progressions"
                ],
                "summary": "Find Progression by ID",
                "description": "Returns a single Progression",
                "operationId": "readProgressionById",
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "name": "progressionId",
                        "in": "path",
                        "description": "The unique identifier the the of Progression",
                        "required": true,
                        "type": "string"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "successful operation",
                        "schema": {
                            "$ref": "#/definitions/Progression"
                        }
                    },
                    "404": {
                        "description": "Progression not found"
                    }
                }
            }
        },
        "/progression": {
            "post": {
                "tags": [
                    "progressions"
                ],
                "summary": "Creates a new Progression to the system",
                "description": "",
                "operationId": "createProgression",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "in": "body",
                        "name": "progression",
                        "description": "The instance ofProgression that needs to be added",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/Progression"
                        }
                    }
                ],
                "responses": {
                    "405": {
                        "description": "Invalid input"
                    }
                },
                "metadata": {
                    "urdMode": false
                }
            },
            "put": {
                "tags": [
                    "progressions"
                ],
                "summary": "Update an existing Progression",
                "description": "",
                "operationId": "updateProgression",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "in": "body",
                        "name": "progression",
                        "description": "The Progression instance to update",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/Progression"
                        }
                    }
                ],
                "responses": {
                    "400": {
                        "description": "Invalid ID supplied"
                    },
                    "404": {
                        "description": "Progression not found"
                    },
                    "405": {
                        "description": "Validation exception"
                    }
                }
            },
            "delete": {
                "tags": [
                    "progressions"
                ],
                "summary": "Deletes a Progression",
                "description": "",
                "operationId": "deleteProgression",
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "name": "progressionId",
                        "in": "path",
                        "description": "The identifier of the Progression to be deleted",
                        "required": true,
                        "type": "string"
                    }
                ],
                "responses": {
                    "400": {
                        "description": "Invalid Progression value"
                    }
                }
            }
        },
        "/progressions": {
            "post": {
                "tags": [
                    "progressions"
                ],
                "summary": "Create progressions to the system",
                "description": "",
                "operationId": "createProgressions",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "in": "body",
                        "name": "progressions",
                        "description": "Collection of Progression that needs to be added",
                        "required": true,
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/Progression"
                            }
                        }
                    }
                ],
                "responses": {
                    "405": {
                        "description": "Invalid input"
                    }
                },
                "metadata": {
                    "urdMode": false
                }
            },
            "get": {
                "tags": [
                    "progressions"
                ],
                "summary": "Find progressions by ID",
                "description": "Returns a collection of Progression",
                "operationId": "readProgressionsByIds",
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "name": "ids",
                        "in": "path",
                        "description": "The IDS of the progressions to return",
                        "required": true,
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    {
                        "in": "body",
                        "name": "result_fields",
                        "description": "the result fields (MONGO DB)",
                        "required": true,
                        "schema": {
                            "type": "array",
                            "items": {
                                "type": "string"
                            }
                        }
                    },
                    {
                        "in": "body",
                        "name": "sort",
                        "description": "the sort (MONGO DB)",
                        "required": false,
                        "type": "dictionary"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "successful operation",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/Progression"
                            }
                        }
                    },
                    "400": {
                        "description": "Invalid IDS supplied"
                    },
                    "404": {
                        "description": "Progressions not found"
                    }
                }
            },
            "put": {
                "tags": [
                    "progressions"
                ],
                "summary": "Update an existing Progression",
                "description": "",
                "operationId": "updateProgressions",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "in": "body",
                        "name": "progressions",
                        "description": "Collection of Progression to update",
                        "required": true,
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/Progression"
                            }
                        }
                    }
                ],
                "responses": {
                    "400": {
                        "description": "Invalid IDS supplied"
                    },
                    "404": {
                        "description": "Progressions not found"
                    },
                    "405": {
                        "description": "Validation exception"
                    }
                }
            },
            "delete": {
                "tags": [
                    "progressions"
                ],
                "summary": "Deletes some progressions",
                "description": "",
                "operationId": "deleteProgressions",
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "name": "ids",
                        "in": "path",
                        "description": "The ids of progressions to delete",
                        "required": true,
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    }
                ],
                "responses": {
                    "400": {
                        "description": "Invalid progressions value"
                    }
                }
            }
        },
        "/progressionsByQuery": {
            "get": {
                "tags": [
                    "progressions"
                ],
                "summary": "Find progressions by query (check $q, $s, $f in Bartleby's MongoCallDataRawWrapper)",
                "description": "Returns a collection of Progression",
                "operationId": "readProgressionsByQuery",
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "in": "body",
                        "name": "result_fields",
                        "description": "the result fields (MONGO DB)",
                        "required": true,
                        "schema": {
                            "type": "array",
                            "items": {
                                "type": "string"
                            }
                        }
                    },
                    {
                        "in": "body",
                        "name": "sort",
                        "description": "the sort (MONGO DB)",
                        "required": false,
                        "type": "dictionary"
                    },
                    {
                        "in": "body",
                        "name": "query",
                        "description": "the query (MONGO DB)",
                        "required": false,
                        "type": "dictionary"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "successful operation",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/Progression"
                            }
                        }
                    },
                    "400": {
                        "description": "Invalid IDS supplied"
                    },
                    "404": {
                        "description": "Progressions not found"
                    }
                }
            }
        },
        "/completion/{completionId}": {
            "get": {
                "tags": [
                    "completions"
                ],
                "summary": "Find Completion by ID",
                "description": "Returns a single Completion",
                "operationId": "readCompletionById",
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "name": "completionId",
                        "in": "path",
                        "description": "The unique identifier the the of Completion",
                        "required": true,
                        "type": "string"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "successful operation",
                        "schema": {
                            "$ref": "#/definitions/Completion"
                        }
                    },
                    "404": {
                        "description": "Completion not found"
                    }
                }
            }
        },
        "/completion": {
            "post": {
                "tags": [
                    "completions"
                ],
                "summary": "Creates a new Completion to the system",
                "description": "",
                "operationId": "createCompletion",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "in": "body",
                        "name": "completion",
                        "description": "The instance ofCompletion that needs to be added",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/Completion"
                        }
                    }
                ],
                "responses": {
                    "405": {
                        "description": "Invalid input"
                    }
                },
                "metadata": {
                    "urdMode": false
                }
            },
            "put": {
                "tags": [
                    "completions"
                ],
                "summary": "Update an existing Completion",
                "description": "",
                "operationId": "updateCompletion",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "in": "body",
                        "name": "completion",
                        "description": "The Completion instance to update",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/Completion"
                        }
                    }
                ],
                "responses": {
                    "400": {
                        "description": "Invalid ID supplied"
                    },
                    "404": {
                        "description": "Completion not found"
                    },
                    "405": {
                        "description": "Validation exception"
                    }
                }
            },
            "delete": {
                "tags": [
                    "completions"
                ],
                "summary": "Deletes a Completion",
                "description": "",
                "operationId": "deleteCompletion",
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "name": "completionId",
                        "in": "path",
                        "description": "The identifier of the Completion to be deleted",
                        "required": true,
                        "type": "string"
                    }
                ],
                "responses": {
                    "400": {
                        "description": "Invalid Completion value"
                    }
                }
            }
        },
        "/completions": {
            "post": {
                "tags": [
                    "completions"
                ],
                "summary": "Create completions to the system",
                "description": "",
                "operationId": "createCompletions",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "in": "body",
                        "name": "completions",
                        "description": "Collection of Completion that needs to be added",
                        "required": true,
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/Completion"
                            }
                        }
                    }
                ],
                "responses": {
                    "405": {
                        "description": "Invalid input"
                    }
                },
                "metadata": {
                    "urdMode": false
                }
            },
            "get": {
                "tags": [
                    "completions"
                ],
                "summary": "Find completions by ID",
                "description": "Returns a collection of Completion",
                "operationId": "readCompletionsByIds",
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "name": "ids",
                        "in": "path",
                        "description": "The IDS of the completions to return",
                        "required": true,
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    {
                        "in": "body",
                        "name": "result_fields",
                        "description": "the result fields (MONGO DB)",
                        "required": true,
                        "schema": {
                            "type": "array",
                            "items": {
                                "type": "string"
                            }
                        }
                    },
                    {
                        "in": "body",
                        "name": "sort",
                        "description": "the sort (MONGO DB)",
                        "required": false,
                        "type": "dictionary"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "successful operation",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/Completion"
                            }
                        }
                    },
                    "400": {
                        "description": "Invalid IDS supplied"
                    },
                    "404": {
                        "description": "Completions not found"
                    }
                }
            },
            "put": {
                "tags": [
                    "completions"
                ],
                "summary": "Update an existing Completion",
                "description": "",
                "operationId": "updateCompletions",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "in": "body",
                        "name": "completions",
                        "description": "Collection of Completion to update",
                        "required": true,
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/Completion"
                            }
                        }
                    }
                ],
                "responses": {
                    "400": {
                        "description": "Invalid IDS supplied"
                    },
                    "404": {
                        "description": "Completions not found"
                    },
                    "405": {
                        "description": "Validation exception"
                    }
                }
            },
            "delete": {
                "tags": [
                    "completions"
                ],
                "summary": "Deletes some completions",
                "description": "",
                "operationId": "deleteCompletions",
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "name": "ids",
                        "in": "path",
                        "description": "The ids of completions to delete",
                        "required": true,
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    }
                ],
                "responses": {
                    "400": {
                        "description": "Invalid completions value"
                    }
                }
            }
        },
        "/completionsByQuery": {
            "get": {
                "tags": [
                    "completions"
                ],
                "summary": "Find completions by query (check $q, $s, $f in Bartleby's MongoCallDataRawWrapper)",
                "description": "Returns a collection of Completion",
                "operationId": "readCompletionsByQuery",
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "in": "body",
                        "name": "result_fields",
                        "description": "the result fields (MONGO DB)",
                        "required": true,
                        "schema": {
                            "type": "array",
                            "items": {
                                "type": "string"
                            }
                        }
                    },
                    {
                        "in": "body",
                        "name": "sort",
                        "description": "the sort (MONGO DB)",
                        "required": false,
                        "type": "dictionary"
                    },
                    {
                        "in": "body",
                        "name": "query",
                        "description": "the query (MONGO DB)",
                        "required": false,
                        "type": "dictionary"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "successful operation",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/Completion"
                            }
                        }
                    },
                    "400": {
                        "description": "Invalid IDS supplied"
                    },
                    "404": {
                        "description": "Completions not found"
                    }
                }
            }
        },
        "/registryMetadata/{registryMetadataId}": {
            "get": {
                "tags": [
                    "registryMetadatas"
                ],
                "summary": "Find RegistryMetadata by ID",
                "description": "Returns a single RegistryMetadata",
                "operationId": "readRegistryMetadataById",
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "name": "registryMetadataId",
                        "in": "path",
                        "description": "The unique identifier the the of RegistryMetadata",
                        "required": true,
                        "type": "string"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "successful operation",
                        "schema": {
                            "$ref": "#/definitions/RegistryMetadata"
                        }
                    },
                    "404": {
                        "description": "RegistryMetadata not found"
                    }
                }
            }
        },
        "/registryMetadata": {
            "post": {
                "tags": [
                    "registryMetadatas"
                ],
                "summary": "Creates a new RegistryMetadata to the system",
                "description": "",
                "operationId": "createRegistryMetadata",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "in": "body",
                        "name": "registryMetadata",
                        "description": "The instance ofRegistryMetadata that needs to be added",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/RegistryMetadata"
                        }
                    }
                ],
                "responses": {
                    "405": {
                        "description": "Invalid input"
                    }
                },
                "metadata": {
                    "urdMode": false
                }
            },
            "put": {
                "tags": [
                    "registryMetadatas"
                ],
                "summary": "Update an existing RegistryMetadata",
                "description": "",
                "operationId": "updateRegistryMetadata",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "in": "body",
                        "name": "registryMetadata",
                        "description": "The RegistryMetadata instance to update",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/RegistryMetadata"
                        }
                    }
                ],
                "responses": {
                    "400": {
                        "description": "Invalid ID supplied"
                    },
                    "404": {
                        "description": "RegistryMetadata not found"
                    },
                    "405": {
                        "description": "Validation exception"
                    }
                }
            },
            "delete": {
                "tags": [
                    "registryMetadatas"
                ],
                "summary": "Deletes a RegistryMetadata",
                "description": "",
                "operationId": "deleteRegistryMetadata",
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "name": "registryMetadataId",
                        "in": "path",
                        "description": "The identifier of the RegistryMetadata to be deleted",
                        "required": true,
                        "type": "string"
                    }
                ],
                "responses": {
                    "400": {
                        "description": "Invalid RegistryMetadata value"
                    }
                }
            }
        },
        "/registryMetadatas": {
            "post": {
                "tags": [
                    "registryMetadatas"
                ],
                "summary": "Create registryMetadatas to the system",
                "description": "",
                "operationId": "createRegistryMetadatas",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "in": "body",
                        "name": "registryMetadatas",
                        "description": "Collection of RegistryMetadata that needs to be added",
                        "required": true,
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/RegistryMetadata"
                            }
                        }
                    }
                ],
                "responses": {
                    "405": {
                        "description": "Invalid input"
                    }
                },
                "metadata": {
                    "urdMode": false
                }
            },
            "get": {
                "tags": [
                    "registryMetadatas"
                ],
                "summary": "Find registryMetadatas by ID",
                "description": "Returns a collection of RegistryMetadata",
                "operationId": "readRegistryMetadatasByIds",
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "name": "ids",
                        "in": "path",
                        "description": "The IDS of the registryMetadatas to return",
                        "required": true,
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    {
                        "in": "body",
                        "name": "result_fields",
                        "description": "the result fields (MONGO DB)",
                        "required": true,
                        "schema": {
                            "type": "array",
                            "items": {
                                "type": "string"
                            }
                        }
                    },
                    {
                        "in": "body",
                        "name": "sort",
                        "description": "the sort (MONGO DB)",
                        "required": false,
                        "type": "dictionary"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "successful operation",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/RegistryMetadata"
                            }
                        }
                    },
                    "400": {
                        "description": "Invalid IDS supplied"
                    },
                    "404": {
                        "description": "RegistryMetadatas not found"
                    }
                }
            },
            "put": {
                "tags": [
                    "registryMetadatas"
                ],
                "summary": "Update an existing RegistryMetadata",
                "description": "",
                "operationId": "updateRegistryMetadatas",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "in": "body",
                        "name": "registryMetadatas",
                        "description": "Collection of RegistryMetadata to update",
                        "required": true,
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/RegistryMetadata"
                            }
                        }
                    }
                ],
                "responses": {
                    "400": {
                        "description": "Invalid IDS supplied"
                    },
                    "404": {
                        "description": "RegistryMetadatas not found"
                    },
                    "405": {
                        "description": "Validation exception"
                    }
                }
            },
            "delete": {
                "tags": [
                    "registryMetadatas"
                ],
                "summary": "Deletes some registryMetadatas",
                "description": "",
                "operationId": "deleteRegistryMetadatas",
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "name": "ids",
                        "in": "path",
                        "description": "The ids of registryMetadatas to delete",
                        "required": true,
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    }
                ],
                "responses": {
                    "400": {
                        "description": "Invalid registryMetadatas value"
                    }
                }
            }
        },
        "/registryMetadatasByQuery": {
            "get": {
                "tags": [
                    "registryMetadatas"
                ],
                "summary": "Find registryMetadatas by query (check $q, $s, $f in Bartleby's MongoCallDataRawWrapper)",
                "description": "Returns a collection of RegistryMetadata",
                "operationId": "readRegistryMetadatasByQuery",
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "in": "body",
                        "name": "result_fields",
                        "description": "the result fields (MONGO DB)",
                        "required": true,
                        "schema": {
                            "type": "array",
                            "items": {
                                "type": "string"
                            }
                        }
                    },
                    {
                        "in": "body",
                        "name": "sort",
                        "description": "the sort (MONGO DB)",
                        "required": false,
                        "type": "dictionary"
                    },
                    {
                        "in": "body",
                        "name": "query",
                        "description": "the query (MONGO DB)",
                        "required": false,
                        "type": "dictionary"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "successful operation",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/RegistryMetadata"
                            }
                        }
                    },
                    "400": {
                        "description": "Invalid IDS supplied"
                    },
                    "404": {
                        "description": "RegistryMetadatas not found"
                    }
                }
            }
        },
        "/user/{userId}": {
            "get": {
                "tags": [
                    "users"
                ],
                "summary": "Find User by ID",
                "description": "Returns a single User",
                "operationId": "readUserById",
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "name": "userId",
                        "in": "path",
                        "description": "The unique identifier the the of User",
                        "required": true,
                        "type": "string"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "successful operation",
                        "schema": {
                            "$ref": "#/definitions/User"
                        }
                    },
                    "404": {
                        "description": "User not found"
                    }
                }
            }
        },
        "/user": {
            "post": {
                "tags": [
                    "users"
                ],
                "summary": "Creates a new User to the system",
                "description": "",
                "operationId": "createUser",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "in": "body",
                        "name": "user",
                        "description": "The instance ofUser that needs to be added",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/User"
                        }
                    }
                ],
                "responses": {
                    "405": {
                        "description": "Invalid input"
                    }
                },
                "metadata": {
                    "urdMode": false
                }
            },
            "put": {
                "tags": [
                    "users"
                ],
                "summary": "Update an existing User",
                "description": "",
                "operationId": "updateUser",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "in": "body",
                        "name": "user",
                        "description": "The User instance to update",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/User"
                        }
                    }
                ],
                "responses": {
                    "400": {
                        "description": "Invalid ID supplied"
                    },
                    "404": {
                        "description": "User not found"
                    },
                    "405": {
                        "description": "Validation exception"
                    }
                }
            },
            "delete": {
                "tags": [
                    "users"
                ],
                "summary": "Deletes a User",
                "description": "",
                "operationId": "deleteUser",
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "name": "userId",
                        "in": "path",
                        "description": "The identifier of the User to be deleted",
                        "required": true,
                        "type": "string"
                    }
                ],
                "responses": {
                    "400": {
                        "description": "Invalid User value"
                    }
                }
            }
        },
        "/users": {
            "post": {
                "tags": [
                    "users"
                ],
                "summary": "Create users to the system",
                "description": "",
                "operationId": "createUsers",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "in": "body",
                        "name": "users",
                        "description": "Collection of User that needs to be added",
                        "required": true,
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/User"
                            }
                        }
                    }
                ],
                "responses": {
                    "405": {
                        "description": "Invalid input"
                    }
                },
                "metadata": {
                    "urdMode": false
                }
            },
            "get": {
                "tags": [
                    "users"
                ],
                "summary": "Find users by ID",
                "description": "Returns a collection of User",
                "operationId": "readUsersByIds",
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "name": "ids",
                        "in": "path",
                        "description": "The IDS of the users to return",
                        "required": true,
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    {
                        "in": "body",
                        "name": "result_fields",
                        "description": "the result fields (MONGO DB)",
                        "required": true,
                        "schema": {
                            "type": "array",
                            "items": {
                                "type": "string"
                            }
                        }
                    },
                    {
                        "in": "body",
                        "name": "sort",
                        "description": "the sort (MONGO DB)",
                        "required": false,
                        "type": "dictionary"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "successful operation",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/User"
                            }
                        }
                    },
                    "400": {
                        "description": "Invalid IDS supplied"
                    },
                    "404": {
                        "description": "Users not found"
                    }
                }
            },
            "put": {
                "tags": [
                    "users"
                ],
                "summary": "Update an existing User",
                "description": "",
                "operationId": "updateUsers",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "in": "body",
                        "name": "users",
                        "description": "Collection of User to update",
                        "required": true,
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/User"
                            }
                        }
                    }
                ],
                "responses": {
                    "400": {
                        "description": "Invalid IDS supplied"
                    },
                    "404": {
                        "description": "Users not found"
                    },
                    "405": {
                        "description": "Validation exception"
                    }
                }
            },
            "delete": {
                "tags": [
                    "users"
                ],
                "summary": "Deletes some users",
                "description": "",
                "operationId": "deleteUsers",
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "name": "ids",
                        "in": "path",
                        "description": "The ids of users to delete",
                        "required": true,
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    }
                ],
                "responses": {
                    "400": {
                        "description": "Invalid users value"
                    }
                }
            }
        },
        "/usersByQuery": {
            "get": {
                "tags": [
                    "users"
                ],
                "summary": "Find users by query (check $q, $s, $f in Bartleby's MongoCallDataRawWrapper)",
                "description": "Returns a collection of User",
                "operationId": "readUsersByQuery",
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "in": "body",
                        "name": "result_fields",
                        "description": "the result fields (MONGO DB)",
                        "required": true,
                        "schema": {
                            "type": "array",
                            "items": {
                                "type": "string"
                            }
                        }
                    },
                    {
                        "in": "body",
                        "name": "sort",
                        "description": "the sort (MONGO DB)",
                        "required": false,
                        "type": "dictionary"
                    },
                    {
                        "in": "body",
                        "name": "query",
                        "description": "the query (MONGO DB)",
                        "required": false,
                        "type": "dictionary"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "successful operation",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/User"
                            }
                        }
                    },
                    "400": {
                        "description": "Invalid IDS supplied"
                    },
                    "404": {
                        "description": "Users not found"
                    }
                }
            }
        },
        "/locker/{lockerId}": {
            "get": {
                "tags": [
                    "lockers"
                ],
                "summary": "Find Locker by ID",
                "description": "Returns a single Locker",
                "operationId": "readLockerById",
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "name": "lockerId",
                        "in": "path",
                        "description": "The unique identifier the the of Locker",
                        "required": true,
                        "type": "string"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "successful operation",
                        "schema": {
                            "$ref": "#/definitions/Locker"
                        }
                    },
                    "404": {
                        "description": "Locker not found"
                    }
                }
            }
        },
        "/locker": {
            "post": {
                "tags": [
                    "lockers"
                ],
                "summary": "Creates a new Locker to the system",
                "description": "",
                "operationId": "createLocker",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "in": "body",
                        "name": "locker",
                        "description": "The instance ofLocker that needs to be added",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/Locker"
                        }
                    }
                ],
                "responses": {
                    "405": {
                        "description": "Invalid input"
                    }
                },
                "metadata": {
                    "urdMode": false
                }
            },
            "put": {
                "tags": [
                    "lockers"
                ],
                "summary": "Update an existing Locker",
                "description": "",
                "operationId": "updateLocker",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "in": "body",
                        "name": "locker",
                        "description": "The Locker instance to update",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/Locker"
                        }
                    }
                ],
                "responses": {
                    "400": {
                        "description": "Invalid ID supplied"
                    },
                    "404": {
                        "description": "Locker not found"
                    },
                    "405": {
                        "description": "Validation exception"
                    }
                }
            },
            "delete": {
                "tags": [
                    "lockers"
                ],
                "summary": "Deletes a Locker",
                "description": "",
                "operationId": "deleteLocker",
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "name": "lockerId",
                        "in": "path",
                        "description": "The identifier of the Locker to be deleted",
                        "required": true,
                        "type": "string"
                    }
                ],
                "responses": {
                    "400": {
                        "description": "Invalid Locker value"
                    }
                }
            }
        },
        "/lockers": {
            "post": {
                "tags": [
                    "lockers"
                ],
                "summary": "Create lockers to the system",
                "description": "",
                "operationId": "createLockers",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "in": "body",
                        "name": "lockers",
                        "description": "Collection of Locker that needs to be added",
                        "required": true,
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/Locker"
                            }
                        }
                    }
                ],
                "responses": {
                    "405": {
                        "description": "Invalid input"
                    }
                },
                "metadata": {
                    "urdMode": false
                }
            },
            "get": {
                "tags": [
                    "lockers"
                ],
                "summary": "Find lockers by ID",
                "description": "Returns a collection of Locker",
                "operationId": "readLockersByIds",
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "name": "ids",
                        "in": "path",
                        "description": "The IDS of the lockers to return",
                        "required": true,
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    {
                        "in": "body",
                        "name": "result_fields",
                        "description": "the result fields (MONGO DB)",
                        "required": true,
                        "schema": {
                            "type": "array",
                            "items": {
                                "type": "string"
                            }
                        }
                    },
                    {
                        "in": "body",
                        "name": "sort",
                        "description": "the sort (MONGO DB)",
                        "required": false,
                        "type": "dictionary"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "successful operation",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/Locker"
                            }
                        }
                    },
                    "400": {
                        "description": "Invalid IDS supplied"
                    },
                    "404": {
                        "description": "Lockers not found"
                    }
                }
            },
            "put": {
                "tags": [
                    "lockers"
                ],
                "summary": "Update an existing Locker",
                "description": "",
                "operationId": "updateLockers",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "in": "body",
                        "name": "lockers",
                        "description": "Collection of Locker to update",
                        "required": true,
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/Locker"
                            }
                        }
                    }
                ],
                "responses": {
                    "400": {
                        "description": "Invalid IDS supplied"
                    },
                    "404": {
                        "description": "Lockers not found"
                    },
                    "405": {
                        "description": "Validation exception"
                    }
                }
            },
            "delete": {
                "tags": [
                    "lockers"
                ],
                "summary": "Deletes some lockers",
                "description": "",
                "operationId": "deleteLockers",
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "name": "ids",
                        "in": "path",
                        "description": "The ids of lockers to delete",
                        "required": true,
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    }
                ],
                "responses": {
                    "400": {
                        "description": "Invalid lockers value"
                    }
                }
            }
        },
        "/lockersByQuery": {
            "get": {
                "tags": [
                    "lockers"
                ],
                "summary": "Find lockers by query (check $q, $s, $f in Bartleby's MongoCallDataRawWrapper)",
                "description": "Returns a collection of Locker",
                "operationId": "readLockersByQuery",
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "in": "body",
                        "name": "result_fields",
                        "description": "the result fields (MONGO DB)",
                        "required": true,
                        "schema": {
                            "type": "array",
                            "items": {
                                "type": "string"
                            }
                        }
                    },
                    {
                        "in": "body",
                        "name": "sort",
                        "description": "the sort (MONGO DB)",
                        "required": false,
                        "type": "dictionary"
                    },
                    {
                        "in": "body",
                        "name": "query",
                        "description": "the query (MONGO DB)",
                        "required": false,
                        "type": "dictionary"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "successful operation",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/Locker"
                            }
                        }
                    },
                    "400": {
                        "description": "Invalid IDS supplied"
                    },
                    "404": {
                        "description": "Lockers not found"
                    }
                }
            }
        },
        "/pushOperation/{pushOperationId}": {
            "get": {
                "tags": [
                    "pushOperations"
                ],
                "summary": "Find PushOperation by ID",
                "description": "Returns a single PushOperation",
                "operationId": "readPushOperationById",
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "name": "pushOperationId",
                        "in": "path",
                        "description": "The unique identifier the the of PushOperation",
                        "required": true,
                        "type": "string"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "successful operation",
                        "schema": {
                            "$ref": "#/definitions/PushOperation"
                        }
                    },
                    "404": {
                        "description": "PushOperation not found"
                    }
                }
            }
        },
        "/pushOperation": {
            "post": {
                "tags": [
                    "pushOperations"
                ],
                "summary": "Creates a new PushOperation to the system",
                "description": "",
                "operationId": "createPushOperation",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "in": "body",
                        "name": "pushOperation",
                        "description": "The instance ofPushOperation that needs to be added",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/PushOperation"
                        }
                    }
                ],
                "responses": {
                    "405": {
                        "description": "Invalid input"
                    }
                },
                "metadata": {
                    "urdMode": false
                }
            },
            "put": {
                "tags": [
                    "pushOperations"
                ],
                "summary": "Update an existing PushOperation",
                "description": "",
                "operationId": "updatePushOperation",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "in": "body",
                        "name": "pushOperation",
                        "description": "The PushOperation instance to update",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/PushOperation"
                        }
                    }
                ],
                "responses": {
                    "400": {
                        "description": "Invalid ID supplied"
                    },
                    "404": {
                        "description": "PushOperation not found"
                    },
                    "405": {
                        "description": "Validation exception"
                    }
                }
            },
            "delete": {
                "tags": [
                    "pushOperations"
                ],
                "summary": "Deletes a PushOperation",
                "description": "",
                "operationId": "deletePushOperation",
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "name": "pushOperationId",
                        "in": "path",
                        "description": "The identifier of the PushOperation to be deleted",
                        "required": true,
                        "type": "string"
                    }
                ],
                "responses": {
                    "400": {
                        "description": "Invalid PushOperation value"
                    }
                }
            }
        },
        "/pushOperations": {
            "post": {
                "tags": [
                    "pushOperations"
                ],
                "summary": "Create pushOperations to the system",
                "description": "",
                "operationId": "createPushOperations",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "in": "body",
                        "name": "pushOperations",
                        "description": "Collection of PushOperation that needs to be added",
                        "required": true,
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/PushOperation"
                            }
                        }
                    }
                ],
                "responses": {
                    "405": {
                        "description": "Invalid input"
                    }
                },
                "metadata": {
                    "urdMode": false
                }
            },
            "get": {
                "tags": [
                    "pushOperations"
                ],
                "summary": "Find pushOperations by ID",
                "description": "Returns a collection of PushOperation",
                "operationId": "readPushOperationsByIds",
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "name": "ids",
                        "in": "path",
                        "description": "The IDS of the pushOperations to return",
                        "required": true,
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    {
                        "in": "body",
                        "name": "result_fields",
                        "description": "the result fields (MONGO DB)",
                        "required": true,
                        "schema": {
                            "type": "array",
                            "items": {
                                "type": "string"
                            }
                        }
                    },
                    {
                        "in": "body",
                        "name": "sort",
                        "description": "the sort (MONGO DB)",
                        "required": false,
                        "type": "dictionary"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "successful operation",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/PushOperation"
                            }
                        }
                    },
                    "400": {
                        "description": "Invalid IDS supplied"
                    },
                    "404": {
                        "description": "PushOperations not found"
                    }
                }
            },
            "put": {
                "tags": [
                    "pushOperations"
                ],
                "summary": "Update an existing PushOperation",
                "description": "",
                "operationId": "updatePushOperations",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "in": "body",
                        "name": "pushOperations",
                        "description": "Collection of PushOperation to update",
                        "required": true,
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/PushOperation"
                            }
                        }
                    }
                ],
                "responses": {
                    "400": {
                        "description": "Invalid IDS supplied"
                    },
                    "404": {
                        "description": "PushOperations not found"
                    },
                    "405": {
                        "description": "Validation exception"
                    }
                }
            },
            "delete": {
                "tags": [
                    "pushOperations"
                ],
                "summary": "Deletes some pushOperations",
                "description": "",
                "operationId": "deletePushOperations",
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "name": "ids",
                        "in": "path",
                        "description": "The ids of pushOperations to delete",
                        "required": true,
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    }
                ],
                "responses": {
                    "400": {
                        "description": "Invalid pushOperations value"
                    }
                }
            }
        },
        "/pushOperationsByQuery": {
            "get": {
                "tags": [
                    "pushOperations"
                ],
                "summary": "Find pushOperations by query (check $q, $s, $f in Bartleby's MongoCallDataRawWrapper)",
                "description": "Returns a collection of PushOperation",
                "operationId": "readPushOperationsByQuery",
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "in": "body",
                        "name": "result_fields",
                        "description": "the result fields (MONGO DB)",
                        "required": true,
                        "schema": {
                            "type": "array",
                            "items": {
                                "type": "string"
                            }
                        }
                    },
                    {
                        "in": "body",
                        "name": "sort",
                        "description": "the sort (MONGO DB)",
                        "required": false,
                        "type": "dictionary"
                    },
                    {
                        "in": "body",
                        "name": "query",
                        "description": "the query (MONGO DB)",
                        "required": false,
                        "type": "dictionary"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "successful operation",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/PushOperation"
                            }
                        }
                    },
                    "400": {
                        "description": "Invalid IDS supplied"
                    },
                    "404": {
                        "description": "PushOperations not found"
                    }
                }
            }
        },
        "/trigger/{triggerId}": {
            "get": {
                "tags": [
                    "triggers"
                ],
                "summary": "Find Trigger by ID",
                "description": "Returns a single Trigger",
                "operationId": "readTriggerById",
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "name": "triggerId",
                        "in": "path",
                        "description": "The unique identifier the the of Trigger",
                        "required": true,
                        "type": "string"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "successful operation",
                        "schema": {
                            "$ref": "#/definitions/Trigger"
                        }
                    },
                    "404": {
                        "description": "Trigger not found"
                    }
                }
            }
        },
        "/trigger": {
            "post": {
                "tags": [
                    "triggers"
                ],
                "summary": "Creates a new Trigger to the system",
                "description": "",
                "operationId": "createTrigger",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "in": "body",
                        "name": "trigger",
                        "description": "The instance ofTrigger that needs to be added",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/Trigger"
                        }
                    }
                ],
                "responses": {
                    "405": {
                        "description": "Invalid input"
                    }
                },
                "metadata": {
                    "urdMode": false
                }
            },
            "put": {
                "tags": [
                    "triggers"
                ],
                "summary": "Update an existing Trigger",
                "description": "",
                "operationId": "updateTrigger",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "in": "body",
                        "name": "trigger",
                        "description": "The Trigger instance to update",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/Trigger"
                        }
                    }
                ],
                "responses": {
                    "400": {
                        "description": "Invalid ID supplied"
                    },
                    "404": {
                        "description": "Trigger not found"
                    },
                    "405": {
                        "description": "Validation exception"
                    }
                }
            },
            "delete": {
                "tags": [
                    "triggers"
                ],
                "summary": "Deletes a Trigger",
                "description": "",
                "operationId": "deleteTrigger",
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "name": "triggerId",
                        "in": "path",
                        "description": "The identifier of the Trigger to be deleted",
                        "required": true,
                        "type": "string"
                    }
                ],
                "responses": {
                    "400": {
                        "description": "Invalid Trigger value"
                    }
                }
            }
        },
        "/triggers": {
            "post": {
                "tags": [
                    "triggers"
                ],
                "summary": "Create triggers to the system",
                "description": "",
                "operationId": "createTriggers",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "in": "body",
                        "name": "triggers",
                        "description": "Collection of Trigger that needs to be added",
                        "required": true,
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/Trigger"
                            }
                        }
                    }
                ],
                "responses": {
                    "405": {
                        "description": "Invalid input"
                    }
                },
                "metadata": {
                    "urdMode": false
                }
            },
            "get": {
                "tags": [
                    "triggers"
                ],
                "summary": "Find triggers by ID",
                "description": "Returns a collection of Trigger",
                "operationId": "readTriggersByIds",
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "name": "ids",
                        "in": "path",
                        "description": "The IDS of the triggers to return",
                        "required": true,
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    {
                        "in": "body",
                        "name": "result_fields",
                        "description": "the result fields (MONGO DB)",
                        "required": true,
                        "schema": {
                            "type": "array",
                            "items": {
                                "type": "string"
                            }
                        }
                    },
                    {
                        "in": "body",
                        "name": "sort",
                        "description": "the sort (MONGO DB)",
                        "required": false,
                        "type": "dictionary"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "successful operation",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/Trigger"
                            }
                        }
                    },
                    "400": {
                        "description": "Invalid IDS supplied"
                    },
                    "404": {
                        "description": "Triggers not found"
                    }
                }
            },
            "put": {
                "tags": [
                    "triggers"
                ],
                "summary": "Update an existing Trigger",
                "description": "",
                "operationId": "updateTriggers",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "in": "body",
                        "name": "triggers",
                        "description": "Collection of Trigger to update",
                        "required": true,
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/Trigger"
                            }
                        }
                    }
                ],
                "responses": {
                    "400": {
                        "description": "Invalid IDS supplied"
                    },
                    "404": {
                        "description": "Triggers not found"
                    },
                    "405": {
                        "description": "Validation exception"
                    }
                }
            },
            "delete": {
                "tags": [
                    "triggers"
                ],
                "summary": "Deletes some triggers",
                "description": "",
                "operationId": "deleteTriggers",
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "name": "ids",
                        "in": "path",
                        "description": "The ids of triggers to delete",
                        "required": true,
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    }
                ],
                "responses": {
                    "400": {
                        "description": "Invalid triggers value"
                    }
                }
            }
        },
        "/triggersByQuery": {
            "get": {
                "tags": [
                    "triggers"
                ],
                "summary": "Find triggers by query (check $q, $s, $f in Bartleby's MongoCallDataRawWrapper)",
                "description": "Returns a collection of Trigger",
                "operationId": "readTriggersByQuery",
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "in": "body",
                        "name": "result_fields",
                        "description": "the result fields (MONGO DB)",
                        "required": true,
                        "schema": {
                            "type": "array",
                            "items": {
                                "type": "string"
                            }
                        }
                    },
                    {
                        "in": "body",
                        "name": "sort",
                        "description": "the sort (MONGO DB)",
                        "required": false,
                        "type": "dictionary"
                    },
                    {
                        "in": "body",
                        "name": "query",
                        "description": "the query (MONGO DB)",
                        "required": false,
                        "type": "dictionary"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "successful operation",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/Trigger"
                            }
                        }
                    },
                    "400": {
                        "description": "Invalid IDS supplied"
                    },
                    "404": {
                        "description": "Triggers not found"
                    }
                }
            }
        },
        "/jString/{jStringId}": {
            "get": {
                "tags": [
                    "jStrings"
                ],
                "summary": "Find JString by ID",
                "description": "Returns a single JString",
                "operationId": "readJStringById",
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "name": "jStringId",
                        "in": "path",
                        "description": "The unique identifier the the of JString",
                        "required": true,
                        "type": "string"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "successful operation",
                        "schema": {
                            "$ref": "#/definitions/JString"
                        }
                    },
                    "404": {
                        "description": "JString not found"
                    }
                }
            }
        },
        "/jString": {
            "post": {
                "tags": [
                    "jStrings"
                ],
                "summary": "Creates a new JString to the system",
                "description": "",
                "operationId": "createJString",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "in": "body",
                        "name": "jString",
                        "description": "The instance ofJString that needs to be added",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/JString"
                        }
                    }
                ],
                "responses": {
                    "405": {
                        "description": "Invalid input"
                    }
                },
                "metadata": {
                    "urdMode": false
                }
            },
            "put": {
                "tags": [
                    "jStrings"
                ],
                "summary": "Update an existing JString",
                "description": "",
                "operationId": "updateJString",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "in": "body",
                        "name": "jString",
                        "description": "The JString instance to update",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/JString"
                        }
                    }
                ],
                "responses": {
                    "400": {
                        "description": "Invalid ID supplied"
                    },
                    "404": {
                        "description": "JString not found"
                    },
                    "405": {
                        "description": "Validation exception"
                    }
                }
            },
            "delete": {
                "tags": [
                    "jStrings"
                ],
                "summary": "Deletes a JString",
                "description": "",
                "operationId": "deleteJString",
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "name": "jStringId",
                        "in": "path",
                        "description": "The identifier of the JString to be deleted",
                        "required": true,
                        "type": "string"
                    }
                ],
                "responses": {
                    "400": {
                        "description": "Invalid JString value"
                    }
                }
            }
        },
        "/jStrings": {
            "post": {
                "tags": [
                    "jStrings"
                ],
                "summary": "Create jStrings to the system",
                "description": "",
                "operationId": "createJStrings",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "in": "body",
                        "name": "jStrings",
                        "description": "Collection of JString that needs to be added",
                        "required": true,
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/JString"
                            }
                        }
                    }
                ],
                "responses": {
                    "405": {
                        "description": "Invalid input"
                    }
                },
                "metadata": {
                    "urdMode": false
                }
            },
            "get": {
                "tags": [
                    "jStrings"
                ],
                "summary": "Find jStrings by ID",
                "description": "Returns a collection of JString",
                "operationId": "readJStringsByIds",
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "name": "ids",
                        "in": "path",
                        "description": "The IDS of the jStrings to return",
                        "required": true,
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    {
                        "in": "body",
                        "name": "result_fields",
                        "description": "the result fields (MONGO DB)",
                        "required": true,
                        "schema": {
                            "type": "array",
                            "items": {
                                "type": "string"
                            }
                        }
                    },
                    {
                        "in": "body",
                        "name": "sort",
                        "description": "the sort (MONGO DB)",
                        "required": false,
                        "type": "dictionary"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "successful operation",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/JString"
                            }
                        }
                    },
                    "400": {
                        "description": "Invalid IDS supplied"
                    },
                    "404": {
                        "description": "JStrings not found"
                    }
                }
            },
            "put": {
                "tags": [
                    "jStrings"
                ],
                "summary": "Update an existing JString",
                "description": "",
                "operationId": "updateJStrings",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "in": "body",
                        "name": "jStrings",
                        "description": "Collection of JString to update",
                        "required": true,
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/JString"
                            }
                        }
                    }
                ],
                "responses": {
                    "400": {
                        "description": "Invalid IDS supplied"
                    },
                    "404": {
                        "description": "JStrings not found"
                    },
                    "405": {
                        "description": "Validation exception"
                    }
                }
            },
            "delete": {
                "tags": [
                    "jStrings"
                ],
                "summary": "Deletes some jStrings",
                "description": "",
                "operationId": "deleteJStrings",
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "name": "ids",
                        "in": "path",
                        "description": "The ids of jStrings to delete",
                        "required": true,
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    }
                ],
                "responses": {
                    "400": {
                        "description": "Invalid jStrings value"
                    }
                }
            }
        },
        "/jStringsByQuery": {
            "get": {
                "tags": [
                    "jStrings"
                ],
                "summary": "Find jStrings by query (check $q, $s, $f in Bartleby's MongoCallDataRawWrapper)",
                "description": "Returns a collection of JString",
                "operationId": "readJStringsByQuery",
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "in": "body",
                        "name": "result_fields",
                        "description": "the result fields (MONGO DB)",
                        "required": true,
                        "schema": {
                            "type": "array",
                            "items": {
                                "type": "string"
                            }
                        }
                    },
                    {
                        "in": "body",
                        "name": "sort",
                        "description": "the sort (MONGO DB)",
                        "required": false,
                        "type": "dictionary"
                    },
                    {
                        "in": "body",
                        "name": "query",
                        "description": "the query (MONGO DB)",
                        "required": false,
                        "type": "dictionary"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "successful operation",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/JString"
                            }
                        }
                    },
                    "400": {
                        "description": "Invalid IDS supplied"
                    },
                    "404": {
                        "description": "JStrings not found"
                    }
                }
            }
        },
        "/jData/{jDataId}": {
            "get": {
                "tags": [
                    "jDatas"
                ],
                "summary": "Find JData by ID",
                "description": "Returns a single JData",
                "operationId": "readJDataById",
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "name": "jDataId",
                        "in": "path",
                        "description": "The unique identifier the the of JData",
                        "required": true,
                        "type": "string"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "successful operation",
                        "schema": {
                            "$ref": "#/definitions/JData"
                        }
                    },
                    "404": {
                        "description": "JData not found"
                    }
                }
            }
        },
        "/jData": {
            "post": {
                "tags": [
                    "jDatas"
                ],
                "summary": "Creates a new JData to the system",
                "description": "",
                "operationId": "createJData",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "in": "body",
                        "name": "jData",
                        "description": "The instance ofJData that needs to be added",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/JData"
                        }
                    }
                ],
                "responses": {
                    "405": {
                        "description": "Invalid input"
                    }
                },
                "metadata": {
                    "urdMode": false
                }
            },
            "put": {
                "tags": [
                    "jDatas"
                ],
                "summary": "Update an existing JData",
                "description": "",
                "operationId": "updateJData",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "in": "body",
                        "name": "jData",
                        "description": "The JData instance to update",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/JData"
                        }
                    }
                ],
                "responses": {
                    "400": {
                        "description": "Invalid ID supplied"
                    },
                    "404": {
                        "description": "JData not found"
                    },
                    "405": {
                        "description": "Validation exception"
                    }
                }
            },
            "delete": {
                "tags": [
                    "jDatas"
                ],
                "summary": "Deletes a JData",
                "description": "",
                "operationId": "deleteJData",
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "name": "jDataId",
                        "in": "path",
                        "description": "The identifier of the JData to be deleted",
                        "required": true,
                        "type": "string"
                    }
                ],
                "responses": {
                    "400": {
                        "description": "Invalid JData value"
                    }
                }
            }
        },
        "/jDatas": {
            "post": {
                "tags": [
                    "jDatas"
                ],
                "summary": "Create jDatas to the system",
                "description": "",
                "operationId": "createJDatas",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "in": "body",
                        "name": "jDatas",
                        "description": "Collection of JData that needs to be added",
                        "required": true,
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/JData"
                            }
                        }
                    }
                ],
                "responses": {
                    "405": {
                        "description": "Invalid input"
                    }
                },
                "metadata": {
                    "urdMode": false
                }
            },
            "get": {
                "tags": [
                    "jDatas"
                ],
                "summary": "Find jDatas by ID",
                "description": "Returns a collection of JData",
                "operationId": "readJDatasByIds",
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "name": "ids",
                        "in": "path",
                        "description": "The IDS of the jDatas to return",
                        "required": true,
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    {
                        "in": "body",
                        "name": "result_fields",
                        "description": "the result fields (MONGO DB)",
                        "required": true,
                        "schema": {
                            "type": "array",
                            "items": {
                                "type": "string"
                            }
                        }
                    },
                    {
                        "in": "body",
                        "name": "sort",
                        "description": "the sort (MONGO DB)",
                        "required": false,
                        "type": "dictionary"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "successful operation",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/JData"
                            }
                        }
                    },
                    "400": {
                        "description": "Invalid IDS supplied"
                    },
                    "404": {
                        "description": "JDatas not found"
                    }
                }
            },
            "put": {
                "tags": [
                    "jDatas"
                ],
                "summary": "Update an existing JData",
                "description": "",
                "operationId": "updateJDatas",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "in": "body",
                        "name": "jDatas",
                        "description": "Collection of JData to update",
                        "required": true,
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/JData"
                            }
                        }
                    }
                ],
                "responses": {
                    "400": {
                        "description": "Invalid IDS supplied"
                    },
                    "404": {
                        "description": "JDatas not found"
                    },
                    "405": {
                        "description": "Validation exception"
                    }
                }
            },
            "delete": {
                "tags": [
                    "jDatas"
                ],
                "summary": "Deletes some jDatas",
                "description": "",
                "operationId": "deleteJDatas",
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "name": "ids",
                        "in": "path",
                        "description": "The ids of jDatas to delete",
                        "required": true,
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    }
                ],
                "responses": {
                    "400": {
                        "description": "Invalid jDatas value"
                    }
                }
            }
        },
        "/jDatasByQuery": {
            "get": {
                "tags": [
                    "jDatas"
                ],
                "summary": "Find jDatas by query (check $q, $s, $f in Bartleby's MongoCallDataRawWrapper)",
                "description": "Returns a collection of JData",
                "operationId": "readJDatasByQuery",
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "in": "body",
                        "name": "result_fields",
                        "description": "the result fields (MONGO DB)",
                        "required": true,
                        "schema": {
                            "type": "array",
                            "items": {
                                "type": "string"
                            }
                        }
                    },
                    {
                        "in": "body",
                        "name": "sort",
                        "description": "the sort (MONGO DB)",
                        "required": false,
                        "type": "dictionary"
                    },
                    {
                        "in": "body",
                        "name": "query",
                        "description": "the query (MONGO DB)",
                        "required": false,
                        "type": "dictionary"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "successful operation",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/JData"
                            }
                        }
                    },
                    "400": {
                        "description": "Invalid IDS supplied"
                    },
                    "404": {
                        "description": "JDatas not found"
                    }
                }
            }
        }
    },
    "securityDefinitions": [],
    "externalDocs": {
        "description": "Find out more about Bartleby",
        "url": "http://www.pereira-da-silva.com/projects/bartleby/"
    }
}#BMS#->{"filename":"post-processor.php","checksum":4236769726,"relativePath":"Bartleby\/Commons.flexions\/App\/post-processor.php","size":3041}<-#BME#
<?php


/* @var $h Hypotypose */

// /////////////////////////////////////////
// #1 Save the hypotypose to files
// /////////////////////////////////////////

hypotyposeToFiles();

// /////////////////////////////////////////
// #2 generate some post generation files
// /////////////////////////////////////////


if(file_exists(realpath($destination))==false){
	throw new Exception("Unexisting destination ".realpath($destination));
}

$generated='';
$h=Hypotypose::Instance();

// Let's write the list of the files we have created
// We could iterate of each loop ( $h->flexedList)
$list = $h->getFlatFlexedList();
$counter = 0;

foreach ( $list as $flexed ) {
    /* @var $flexed Flexed */
	if ($flexed->exclude === false) {
		// Let's add a human readable log.
		$counter ++;
        $line='';
		if (VERBOSE_FLEXIONS)
			fLog ( $counter . " " . $flexed->fileName. cr() , false );
		// Let's list the file name
		$line .= $counter.'-> We have created "'.$flexed->package.$flexed->fileName . '"' . "".cr();
		$generated .= $line;
	}
}

// We save the file
$filePath= $destination .'ReadMe.txt';
$c='Those files that are recreated by YouDubApi-flexions-App should not be modified directly.'.cr().cr();
$c.=$generated;
file_put_contents ( $filePath, $c );


// /////////////////////////////////////////
// #3 Deploy
// /////////////////////////////////////////


// We can deploy the files per version and stage
// And keep a copy in the out.YouDubApi-flexions-App folder.

require_once FLEXIONS_MODULES_DIR . '/Deploy/FTPDeploy.php';
require_once FLEXIONS_MODULES_DIR . '/Deploy/LocalDeploy.php';



// DEVELOPMENT
if ($h->stage==DefaultStages::STAGE_DEVELOPMENT){
    $deploy=new LocalDeploy($h);

    $generatedFolder=dirname(dirname(__DIR__)).'/Commons/_generated/';
    // WE DELETE THE GENERATED FOLDER BEFORE TO REGENERATE
    $deploy->rmPath($generatedFolder);
    $deploy->flatCopyFiles('/php/api/v1/_generated/Endpoints/',$generatedFolder.'EndPoints/',true);
    $deploy->flatCopyFiles('/php/api/v1/_generated/Models/',$generatedFolder.'Models/',true);
	$deploy->flatCopyFiles('/php/_generated/',$generatedFolder,true);

    // We want to copy the package 'ios/' files to the iOS sources
    // WE DELETE THE GENERATED FOLDER BEFORE TO REGENERATE
    $deploy->rmPath(xOS_BARTLEBYS_COMMONS_EXPORT_PATH);
    $deploy->copyFiles('/xOS/',xOS_BARTLEBYS_COMMONS_EXPORT_PATH,true);
}

// PRODUCTION
// Replace Host + <USER> & <PASSWORD>
if ($h->stage==DefaultStages::STAGE_BETA){
	// We want to copy the package 'php/' files to a valid FTP.
	$ftpDeploy=new FTPDeploy($h);
    $ftpDeploy->setUp("dev.api.lylo.tv");
    if($ftpDeploy->login("www.dev","uburoi1972danse")==true){
        $ftpDeploy->copyFiles('php/','/home/dev/public_html/');
    }else{
        // There is may be an issue
    }
    // Local copies
    $deploy=new LocalDeploy($h);
	// We want to copy the package 'ios/' files to the iOS sources
    $deploy->rmPath(xOS_BARTLEBYS_COMMONS_EXPORT_PATH);
	$deploy->copyFiles('/xOS/',xOS_BARTLEBYS_COMMONS_EXPORT_PATH,true);
}#BMS#->{"filename":"pre-processor.php","checksum":1527417323,"relativePath":"Bartleby\/Commons.flexions\/App\/pre-processor.php","size":1351}<-#BME#
<?php

// we load the shared variables
include  FLEXIONS_SOURCE_DIR.'/Shared.php';
require_once FLEXIONS_MODULES_DIR . 'SwaggerToFlexions/SwaggerToFlexionsRepresentations.php';
require_once FLEXIONS_MODULES_DIR . 'SwaggerToFlexions/SwaggerDelegate.php';

// we instanciate the Hypotypose singleton
$h = Hypotypose::instance();
$h->stage=DefaultStages::STAGE_DEVELOPMENT;
$h->version='1.0';
$h->classPrefix=$prefix;
if(isset($doNotGenerate)){
    $h->excludePath=$doNotGenerate;
}

$transformer=new SwaggerToFlexionsRepresentations();
$delegate=new SWaggerDelegate();
$r = $transformer->projectRepresentationFromSwaggerJson($descriptorFilePath, $prefix, $delegate);


/// Associate the entities to the loop name
if(! $h->setLoopDescriptor($r->entities,DefaultLoops::ENTITIES)){
    throw new Exception('Error when setting the loop descriptor '.DefaultLoops::ENTITIES);
}

/// Associate the global descriptor to the loop name
// Yoy must wrap it in an array
if(! $h->setLoopDescriptor($r->actions,DefaultLoops::ACTIONS)){
    throw new Exception('Error when setting the loop descriptor '.DefaultLoops::ACTIONS);
}

/// Associate the global descriptor to the loop name
// Yoy must wrap it in an array
if(! $h->setLoopDescriptor(array($r),DefaultLoops::PROJECT)){
    throw new Exception('Error when setting the loop descriptor '.DefaultLoops::PROJECT);
}#BMS#->{"filename":"ReadMe.md","checksum":158670892,"relativePath":"Bartleby\/Commons.flexions\/App\/ReadMe.md","size":213}<-#BME#
## YouDub Api Generator

Generation  to various templates.

## How to ?

```
php -f run.php
```

The generated files will be available in the folder out.flexions/
The logs will be written in Flexions folder /out/
#BMS#->{"filename":"run.php","checksum":2970387975,"relativePath":"Bartleby\/Commons.flexions\/App\/run.php","size":426}<-#BME#
<?php


$arguments=array();
$arguments['source']="./";
$arguments['destination']="out.flexions/";
$arguments['descriptor']="datasources/bartleby.json";
$arguments['templates']="*";
$arguments['preProcessors']="pre-processor.php";
$arguments['postProcessors']="post-processor.php";

define ( "COMMANDLINE_MODE", true );

// Invoke Flexions
include_once dirname(dirname(dirname(__DIR__))).'/BartlebyFlexions/src/flexions.php';

#BMS#->{"filename":"Shared.php","checksum":2555124634,"relativePath":"Bartleby\/Commons.flexions\/App\/Shared.php","size":1582}<-#BME#
<?php

// DEFINE IN THIS FILE ANY SHARED GLOBAL SETUPS
// THIS FILE SHOULD BE INCLUDED IN YOUR TEMPLATES

/* @var $f Flexed */

require_once FLEXIONS_MODULES_DIR . 'Utils/Pluralization.php';
include_once dirname(dirname(dirname(__DIR__))) . '/GenerativeConstants.php';

$isIncludeInBartlebysCommons = true;
$prefix = "";// No prefix


$modelsShouldConformToNSCoding = true; // (!) you can opt for NSCoding support (the model will not be pure swift models)

$excludeEntitiesWith = ["AbstractContext"]; //

$xOSIncludeCollectionControllerForEntityNamed = [
    "Operation"
];

$excludeActionsWith = [
    "JString", "JDictionary", "JData", // Primitive Wrapper
    "Trigger",
    "Operation",
    "Abstract", // Any abstract entity should be ignored
    "ExternalReference",
    "Progression",
    "Completion",
    "BaseObject",
    "Tag",
    "CollectionMetadatum",
    "HTTPResponse",
    "RegistryMetadata",
    "CollectionMetadata",
    "CollectionMetadatum"//

];//We will generate only the entity ( On client and server side)
$excludeFromServerActionsWith = [""];

$unDeletableEntitiesWith = [];
$unModifiableEntitiesWith = [];
$doNotGenerate = [];

if (isset ($f)) {
    $f->company = "Bartleby's | https://bartlebys.org";
    $f->prefix = $prefix;
    $f->author = "b@bartlebys.org";
    $f->projectName = "Bartleby";
    //$f->license = FLEXIONS_MODULES_DIR."Licenses/LGPL.template.php";
}


/*
$parentClass = "";
$collectionParentClass="";
$protocols="";
$imports = "\n#import \"$parentClass.h\"\n"; // NOT NEEDED FOR SWIFT
$markAsDynamic = false;
$allowScalars = true;
*/
#BMS#->{"filename":"endpoint.cuds.swift.template.php","checksum":1357419024,"relativePath":"Bartleby\/Commons.flexions\/App\/templates\/actions\/endpoint.cuds.swift.template.php","size":212}<-#BME#
<?php
/**
 * Injects the variable and injects the module template.
 */
include FLEXIONS_SOURCE_DIR.'/Shared.php';
include FLEXIONS_MODULES_DIR . 'Bartleby/templates/actions/cuds.withWeakLogic.swift.template.php';#BMS#->{"filename":"endpoint.php.template.php","checksum":2196702646,"relativePath":"Bartleby\/Commons.flexions\/App\/templates\/actions\/endpoint.php.template.php","size":200}<-#BME#
<?php
/**
 * Injects the variable and injects the module template.
 */
include FLEXIONS_SOURCE_DIR.'/Shared.php';
include FLEXIONS_MODULES_DIR . 'Bartleby/templates/actions/endpoint.php.template.php';#BMS#->{"filename":"endpoint.swift.template.php","checksum":89320255,"relativePath":"Bartleby\/Commons.flexions\/App\/templates\/actions\/endpoint.swift.template.php","size":202}<-#BME#
<?php
/**
 * Injects the variable and injects the module template.
 */
include FLEXIONS_SOURCE_DIR.'/Shared.php';
include FLEXIONS_MODULES_DIR . 'Bartleby/templates/actions/endpoint.swift.template.php';#BMS#->{"filename":"model.php.template.php","checksum":2736040291,"relativePath":"Bartleby\/Commons.flexions\/App\/templates\/entities\/model.php.template.php","size":198}<-#BME#
<?php
/**
 * Injects the variable and injects the module template.
 */
include FLEXIONS_SOURCE_DIR.'/Shared.php';
include FLEXIONS_MODULES_DIR . 'Bartleby/templates/entities/model.php.template.php';#BMS#->{"filename":"model.swift.template.php","checksum":645731421,"relativePath":"Bartleby\/Commons.flexions\/App\/templates\/entities\/model.swift.template.php","size":200}<-#BME#
<?php
/**
 * Injects the variable and injects the module template.
 */
include FLEXIONS_SOURCE_DIR.'/Shared.php';
include FLEXIONS_MODULES_DIR . 'Bartleby/templates/entities/model.swift.template.php';#BMS#->{"filename":"modelCollectionController.swift.template.php","checksum":279416835,"relativePath":"Bartleby\/Commons.flexions\/App\/templates\/entities\/modelCollectionController.swift.template.php","size":220}<-#BME#
<?php
/**
 * Injects the variable and injects the module template.
 */
include FLEXIONS_SOURCE_DIR.'/Shared.php';
include FLEXIONS_MODULES_DIR . 'Bartleby/templates/entities/modelCollectionController.swift.template.php';#BMS#->{"filename":"bartlebyDocument.swift.template.php","checksum":3420945094,"relativePath":"Bartleby\/Commons.flexions\/App\/templates\/project\/bartlebyDocument.swift.template.php","size":630}<-#BME#
<?php
/**
 * Injects the variable and injects the module template.
 */
include FLEXIONS_SOURCE_DIR.'/Shared.php';

// Configuration
require_once FLEXIONS_MODULES_DIR . 'Bartleby/templates/project/SwiftDocumentConfigurator.php';
$configurator=new SwiftDocumentConfigurator();
$configurator->filename="BartlebyDocument.swift";
$configurator->includeCollectionControllerForEntityContainingString=array("User","Group","Permission","Operation","Locker");
$configurator->excludeCollectionControllerForEntityContainingString=array();

// Invocation
include FLEXIONS_MODULES_DIR . 'Bartleby/templates/project/document.swift.template.php';#BMS#->{"filename":"commons.configuration.php.template.php","checksum":4152905103,"relativePath":"Bartleby\/Commons.flexions\/App\/templates\/project\/commons.configuration.php.template.php","size":213}<-#BME#
<?php
/**
 * Injects the variable and injects the module template.
 */
include FLEXIONS_SOURCE_DIR.'/Shared.php';
include FLEXIONS_MODULES_DIR . 'Bartleby/templates/project/commons.configuration.php.template.php';#BMS#->{"filename":"post-processor.php","checksum":2785060727,"relativePath":"Bartleby\/Commons.flexions\/EndPointsFromDefinitions\/post-processor.php","size":1436}<-#BME#
<?php

require_once FLEXIONS_MODULES_DIR.'/Deploy/FTPDeploy.php';
require_once FLEXIONS_MODULES_DIR.'/Deploy/LocalDeploy.php';


/* @var $h Hypotypose */

// /////////////////////////////////////////
// #1 Save the hypotypose to files
// /////////////////////////////////////////

hypotyposeToFiles();

// DEVELOPMENT
if ($h->stage==DefaultStages::STAGE_DEVELOPMENT){
    $deploy=new LocalDeploy($h);
    $deploy->copyFiles('/php/',dirname(__DIR__).'/www/',true);

    // AGGREGATE THE PATHS IN youdub.json
    $decodedPaths=null;
    $fl=$h->flexedList[DefaultLoops::PROJECT];
    /* @var $flexed Flexed */
    foreach ($fl as $flexed) {
        if($flexed->fileName=='pathsFragment.json'){
            $json=$flexed->source;
            $decodedPaths=json_decode($json,true);
        }
    }
    if(isset($decodedPaths)){
        // We gonna update the json
        $dataSourcePath= dirname(__DIR__) . '/App/datasources/bartleby.json';
        $dataSourceJSON=json_decode(file_get_contents($dataSourcePath),true);
        // $paths=$dataSourceJSON['paths']; <- if you want to preserve the paths
        $paths=array();
        foreach ($decodedPaths['paths'] as $path => $contentAtPath ) {
            $paths[$path]=$contentAtPath;
        }
        $dataSourceJSON['paths']=$paths;
        $encoded=json_encode($dataSourceJSON,JSON_UNESCAPED_SLASHES|JSON_PRETTY_PRINT);
        file_put_contents($dataSourcePath,$encoded);

    }


}#BMS#->{"filename":"pre-processor.php","checksum":1527417323,"relativePath":"Bartleby\/Commons.flexions\/EndPointsFromDefinitions\/pre-processor.php","size":1351}<-#BME#
<?php

// we load the shared variables
include  FLEXIONS_SOURCE_DIR.'/Shared.php';
require_once FLEXIONS_MODULES_DIR . 'SwaggerToFlexions/SwaggerToFlexionsRepresentations.php';
require_once FLEXIONS_MODULES_DIR . 'SwaggerToFlexions/SwaggerDelegate.php';

// we instanciate the Hypotypose singleton
$h = Hypotypose::instance();
$h->stage=DefaultStages::STAGE_DEVELOPMENT;
$h->version='1.0';
$h->classPrefix=$prefix;
if(isset($doNotGenerate)){
    $h->excludePath=$doNotGenerate;
}

$transformer=new SwaggerToFlexionsRepresentations();
$delegate=new SWaggerDelegate();
$r = $transformer->projectRepresentationFromSwaggerJson($descriptorFilePath, $prefix, $delegate);


/// Associate the entities to the loop name
if(! $h->setLoopDescriptor($r->entities,DefaultLoops::ENTITIES)){
    throw new Exception('Error when setting the loop descriptor '.DefaultLoops::ENTITIES);
}

/// Associate the global descriptor to the loop name
// Yoy must wrap it in an array
if(! $h->setLoopDescriptor($r->actions,DefaultLoops::ACTIONS)){
    throw new Exception('Error when setting the loop descriptor '.DefaultLoops::ACTIONS);
}

/// Associate the global descriptor to the loop name
// Yoy must wrap it in an array
if(! $h->setLoopDescriptor(array($r),DefaultLoops::PROJECT)){
    throw new Exception('Error when setting the loop descriptor '.DefaultLoops::PROJECT);
}#BMS#->{"filename":"run.php","checksum":649653290,"relativePath":"Bartleby\/Commons.flexions\/EndPointsFromDefinitions\/run.php","size":449}<-#BME#
<?php

$arguments=array();
$arguments['source']="./";
$arguments['destination']="out.flexions/";
$arguments['descriptor']= dirname(__DIR__) . '/App/datasources/bartleby.json';
$arguments['templates']="*";
$arguments['preProcessors']="pre-processor.php";
$arguments['postProcessors']="post-processor.php";

define ( "COMMANDLINE_MODE", true );

// Invoke flexions
include_once dirname(dirname(dirname(__DIR__))).'/BartlebyFlexions/src/flexions.php';
#BMS#->{"filename":"Shared.php","checksum":1515705902,"relativePath":"Bartleby\/Commons.flexions\/EndPointsFromDefinitions\/Shared.php","size":1249}<-#BME#
<?php


// DEFINE IN THIS FILE ANY SHARED GLOBAL SETUPS
// THIS FILE SHOULD BE INCLUDED IN YOUR TEMPLATES

/* @var $f Flexed */

require_once FLEXIONS_MODULES_DIR . 'Utils/Pluralization.php';
include_once dirname(dirname(dirname(__DIR__))) . '/GenerativeConstants.php';

$prefix = "Swagger";
$excludeEntitiesWith = array("AbstractContext");//

$excludeActionsWith = [
    "Asset",
    "Datum",
    "AbstractContext",
    "Reference",
    "Tag",
    "Scene",
    "Shot",
    "Sentence",
    "TextPart",
    "Sign",
    "StringAttribute",
    "TimeCode",
    "TimeRange",
    "MovieCharacter",
    "Actor"
];//We generate only the entity
$unDeletableEntitiesWith = [];
$unModifiableEntitiesWith = [];
$doNotGenerate = ["AbstractContext"];// Used by the flexions script to reject a flexed content

if (isset ($f)) {
    $f->package = "Models/";
    $f->company = "Bartleby's | https://bartlebys.org";
    $f->prefix = $prefix;
    $f->author = "b@bartlebys.org";
    $f->projectName = "Bartleby";
    //$f->license = FLEXIONS_MODULES_DIR."Licenses/LGPL.template.php";
}

/*
$parentClass = "";
$collectionParentClass="";
$protocols="";
$imports = "\n#import \"$parentClass.h\"\n"; // NOT NEEDED FOR SWIFT
$markAsDynamic = false;
$allowScalars = true;
*/#BMS#->{"filename":"endPoints.json.template.php","checksum":1409133785,"relativePath":"Bartleby\/Commons.flexions\/EndPointsFromDefinitions\/templates\/project\/endPoints.json.template.php","size":216}<-#BME#
<?php
/**
 * Injects the variable and injects the module template.
 */
include FLEXIONS_SOURCE_DIR.'/Shared.php';
include FLEXIONS_MODULES_DIR . 'Bartleby/modeling-meta-templates/project/endPoints.json.template.php';#BMS#->{"filename":"BackgroundExecution.php","checksum":3779582768,"relativePath":"Bartleby\/Core\/BackgroundExecution.php","size":1072}<-#BME#
<?php

namespace Bartleby\Core;

/**
 * A simple back ground execution process
 * Usage sample : 
 *				$process = new BackgroundExecution();
 *				$process->runPHP('
 *							$generator=new HashMapGenerator();
 *							$generator->HashMapForRelativePaths('.$relativePaths.');
 *						');
 *						
 *  @author bpds
 */
class BackgroundExecution{

	private $_pid=NULL;
	
	public  function runPHP($phpString,$outputFile = '/dev/null'){
		return $this->_pid = shell_exec( 'php -r \''.$phpString.'\' > ' .$outputFile.' 2>&1 &\; echo $! ' );
	}
	public  function runPHPFile($phpFile,$outputFile = '/dev/null'){
		return $this->_pid = shell_exec( 'php -f \''.$phpFile.'\' > ' .$outputFile.' 2>&1 &\; echo $! ' );
	}
	
	public function isRunning() {
		try {
			$result = shell_exec('ps '. $this->_pid);
			if(count(preg_split("/\n/", $result)) > 2) {
				return TRUE;
			}
		} catch(Exception $e) {		
		}
		return FALSE;
	}

	public function getPid(){
		return $this->_pid;
	}
	
	public function kill(){
		if (isset($this->_pid)){
			shell_exec('kill '. $this->_pid);
		}
	}
	
}
#BMS#->{"filename":"CallData.php","checksum":110152453,"relativePath":"Bartleby\/Core\/CallData.php","size":434}<-#BME#
<?php

namespace Bartleby\Core;

require_once BARTLEBY_ROOT_FOLDER . 'Core/IAuthentified.php';
require_once BARTLEBY_ROOT_FOLDER . 'Core/Model.php';



/**
 * Class CallData
 * You can use CallData to build strongly typed models
 *
 * And you can use a CallDataRawWrapper
 * when #the code is generated#
 * it will bypass the serialization/deserialization phase
 *
 * @package Bartleby\Core
 */
class CallData extends Model {
    
}

#BMS#->{"filename":"CallDataRawWrapper.php","checksum":1005915447,"relativePath":"Bartleby\/Core\/CallDataRawWrapper.php","size":1891}<-#BME#
<?php

namespace Bartleby\Core;

/**
 * Class CallDataRawWrapper
 * You can use CallData to build strongly typed calls
 *
 * And you can use a CallDataRawWrapper
 * when the code is generated or intensively tested
 * it will bypass serialization/deserialization
 *
 * @package Bartleby\Core
 */
class CallDataRawWrapper {

    private $_storage;

    private $_isArray=true;
    
    /**
     * CallData constructor.
     * @param array $data
     */
    public function __construct($data) {
        $this->_isArray=is_array($data);
        $this->_storage = $data;
    }

    public function getValueForKey($key){
        if($this->_isArray){
            if(array_key_exists($key,$this->_storage)){
                return $this->_storage[$key];
            }
        }else{
            return $this->_storage->{$key};
        }
        return null;
    }


    public function keyExists($key){
        if($this->_isArray) {
            return array_key_exists($key, $this->_storage);
        }else{
            return property_exists($this->_storage,$key);
        }

    }


    public function getDictionary(){
        return $this->_storage;
    }

    //////////////////////////
    // Facilities
    //////////////////////////

    // Sort values must be casted to numeric values
    // So we propose some facilities to transform

    function getCastedDictionaryForKey($key){
        return $this->castNumericValues($this->getValueForKey($key));
    }

    function castNumericValues($values) {
        if (!is_array($values)) {
            return $values;
        }
        foreach ($values as $key => $value) {
            if (is_array($value)) {
                $this->castNumericValues($value);
            } else {
                if (is_numeric($value)) {
                    $values[$key] = 0 + $value;
                }
            }
        }
        return $values;
    }

}#BMS#->{"filename":"Configuration.php","checksum":1725812558,"relativePath":"Bartleby\/Core\/Configuration.php","size":17414}<-#BME#
<?php
namespace Bartleby\Core;
require_once __DIR__ . '/Stages.php';
require_once __DIR__ . '/Mode.php';

if (!defined('PERMISSION_IS_STATIC')) {
    define('PERMISSION_IS_STATIC', 0);

    date_default_timezone_set ( 'UTC' );

    // PERMISSION_RESTRICTED_TO_ENUMERATED_USERS is equivalent
    // to PERMISSION_IS_STATIC+PERMISSION_RESTRICTED_TO_ENUMERATED_USERS

    define('PERMISSION_NO_RESTRICTION', 1);
    define('PERMISSION_BY_TOKEN', 2);
    define('PERMISSION_PRESENCE_OF_A_COOKIE', 3);
    define('PERMISSION_BY_IDENTIFICATION', 4); // Two approachs are possible byKeys (using a key value pair on each call) or by Cookies
    define('PERMISSION_RESTRICTED_TO_ENUMERATED_USERS', 5);
    define('PERMISSION_RESTRICTED_BY_QUERIES', 6);
    define('PERMISSION_RESTRICTED_TO_GROUP_MEMBERS', 7);

    // Explicit you need to PERMISSION_IS_DYNAMIC
    define('PERMISSION_IS_DYNAMIC', 32768);// We reserve the ability to add new permission types

    define('PERMISSION_IS_GRANTED_TO_SUPER_ADMIN_ONLY', 65536);
    define('PERMISSION_IS_BLOCKED', 131072);// For security purpose we can decide to lock the super admin

    define('TOKEN_CONTEXT', 'context');

    define('UID_KEY', 'UID');
    define('MONGO_ID_KEY', '_id'); // For example : PERMISSION_RESTRICTED_TO_ENUMERATED_USERS the ids of the users
    define('KVID_KEY','kvid'); // Used for KVID identification by Headers
    define('SPACE_UID_KEY', 'spaceUID');
    define('OBSERVATION_UID_KEY', 'observationUID');// Is generally a RootObjectUID
    define('RUN_UID_KEY', 'runUID');
    define('EPHEMERAL_KEY','ephemeral');
    define('REQUEST_COUNTER_KEY', 'requestCounter');
    define('BARTLEBY_KEY','Bartleby');
    define('CURRENT_SPACE_UID_COOKIE_KEY','currentSpaceUID');// Used by pages when using Identification by Cookie.

    define('JSON_PRETTY_PRINT_KEY','prettify');

    define('LEVEL_KEY', 'level'); // The permission level.
    define('KEY_NAME', 'name'); // For example : when PERMISSION_PRESENCE_OF_A_TOKEN the name == the token key
    define('IDS_KEY', 'ids'); // For example : PERMISSION_RESTRICTED_TO_ENUMERATED_USERS the ids of the users

    // SYNTAX FOR PERMISSION_RESTRICTED_BY_QUERIES
    define('ARRAY_OF_QUERIES', 'queries');
    define('SELECT_COLLECTION_NAME', 'collectionName');
    define('WHERE_VALUE_OF_ENTITY_KEY', 'entitySelectionKey');
    define('EQUALS_VALUE_OF_PARAMETERS_KEY_PATH', 'paramKeyPath');
    define('COMPARE_WITH_OPERATOR', 'operator');
    define('RESULT_ENTITY_KEY', 'entityKey');
    define('AND_PARAMETER_KEY', 'parameterkey'); // CHOOSE AND_PARAMETER_KEY or  AND_CURRENT_USERID

    define('AND_CURRENT_USERID', 'currentUserId'); // There is a precedence for AND_CURRENT_USERID

    define('TOKEN_CONTEXT_KEY', 'context');

    define('NOT_SUPERVISABLE', 'NO');
    define('NO_UID', 'NU');

    define('DEFAULT_SPACE_UID', '0');  //used when there no dID by the GateKeeper
    define('DEFAULT_AUTH_COOKIE_KEY', 'authtoken');  // Set on sign in

    // SOME CLIENT IMPLEMENTATION MAY CONSIDER NULL as a FAULT
    // SO WE PREFER TO RETURN A VOID JSON DICTIONARY instead of a void
    define('VOID_RESPONSE', "{}");

    if ( ( array_key_exists('argc', $_SERVER) && $_SERVER ['argc'] == 0 )
        || (!defined('STDIN') && !defined('SHELL') )
        && php_sapi_name() !== 'cli'
        ){

        define("COMMANDLINE_MODE", false);
    } else {
        define("COMMANDLINE_MODE", true);
    }

    if (COMMANDLINE_MODE){
        define('CR',"\n");
    }else{
        define('CR',"<br/>");
    }
}


/**
 * Class Configuration
 * This configuration is central in Bartleby's architecture.
 *
 * It defines or implements :
 * 
 * - SearchPaths
 * - Versionning
 * - ACL rules aka. Permissions
 * - Token Cryptographic facilities
 * - Data filters.
 *
 * @package Bartleby\Core
 */
class Configuration {

    // APP

    // Bartleby's version
    const BARTLEBY_VERSION = "1.0";
    const BARTLEBY_RELEASE = "RC";
    const INFORMATIONS_KEY = 'informations';
    const ANONYMOUS = 'anonymous';

    protected $_executionDirectory;
    protected $_bartlebyRootDirectory;

    protected $_BASE_URL = NULL;
    protected $_STAGE = Stages::DEVELOPMENT;
    protected $_VERSION = 'v1';
    protected $_SECRET_KEY = 'You should define a salt to make good code soup'; // PRIVATE SALT 32BYTES MIN
    protected $_SHARED_SALT = "You should define this salt and share it with the app clients"; // SALT SHARED BY CLIENTS

    protected $_superAdmins = array();// The super admin ids are declarative
    protected $_permissionsRules = array();// Will be setup first in BartlebyCommonsConfiguration

    private $_filtersIn = array();
    private $_filtersOut = array();

    // Can be API or PAGES
    public  $runMode=Mode::API;

    /**
     * @var null|| String
     */
    public $_spaceUID=NULL;

    /**
     * @param $bartlebyRootDirectory string
     */
    public function setBartlebyRootDirectory($bartlebyRootDirectory) {
        $this->_bartlebyRootDirectory = $bartlebyRootDirectory;
    }


    /**
     * @var array of overloaded paths.
     */
    private $_fixedPaths = array();

    /**
     * Defines the BASE_URL and the _STAGE
     * If necessary the _BASE_URL and _STAGE can be declared
     * @param array $baseURLS
     * @throws \Exception An exception if the host was not found.
     */
    protected function _autoDefineBaseUrlAndStage(array $baseURLS){

        if (array_key_exists('SERVER_NAME',$_SERVER)){
            $serverName=$_SERVER['SERVER_NAME'];
            foreach ($baseURLS as $stage => $host) {
                if (strpos($host,$serverName)!==false){
                    $this->_STAGE=$stage;
                }
            }
        }

        if (!isset($this->_STAGE)){
            $this->_STAGE = Stages::LOCAL;
        };
        if (array_key_exists($this->_STAGE,$baseURLS)){
            $this->_BASE_URL= $baseURLS[$this->_STAGE];
        }else{
            throw new \Exception('Unexisting Host for stage'.$this->_STAGE);
        }
    }

    /**
     * @return string For Bartleby The Host is the complete path for example https://demo.bartlebys.org/www/
     */
    public function BASE_URL() {
        return $this->_BASE_URL;
    }



    // MONGO DB DEFAULT VALUES

    protected $_MONGO_DB_NAME='Set up your Mongo db name';
    protected $_MONGO_USERS_COLLECTION='users';
    protected $_MONGO_USER_PASSWORD_KEY_PATH='password';

    /**
     * @return string
     */
    public function MONGO_DB_NAME() {
        return $this->_MONGO_DB_NAME;
    }

    /**
     * @return string
     */
    public function MONGO_USERS_COLLECTION() {
        return $this->_MONGO_USERS_COLLECTION;
    }


    /**
     * @return string
     */
    public function MONGO_USER_PASSWORD_KEY_PATH() {
        return $this->_MONGO_USER_PASSWORD_KEY_PATH;
    }



    //////////////////////////////////
    // Behavioural const + getters
    ///////////////////////////////////

    // The getters allows overload of the consts.

    /**
     * Disable the ACL to perform Dev tests.
     */
    const DISABLE_ACL = false;

    /**
     * @return bool
     */
    public function DISABLE_ACL() {
        return $this::DISABLE_ACL;
    }

    /**
     * Can be used during development to simplify the tests.
     */
    const BY_PASS_SALTED_TOKENS = false;  // Should be set to false !

    /**
     * @return bool
     */
    public function BY_PASS_SALTED_TOKENS() {
        return $this::BY_PASS_SALTED_TOKENS;
    }

    /*
    * Should be used once to call destructive installer.
    */
    const ALLOW_DESTRUCTIVE_INSTALLER = false;  // Should be set to false (!)

    /**
     * @return bool
     */
    public function ALLOW_DESTRUCTIVE_INSTALLER() {
        return $this::ALLOW_DESTRUCTIVE_INSTALLER;
    }


    /**
     * Disables the data Filters IN & OUT
     * This options should never be turned to true in production.
     * The passwords would be  server side stored
     */
    const DISABLE_DATA_FILTERS = false;  // Should be set to false (!)

    /**
     * @return bool
     */
    public function DISABLE_DATA_FILTERS() {
        return $this::DISABLE_DATA_FILTERS;
    }


    /* Used by developers */
    const DEVELOPER_DEBUG_MODE = true; // Should be set to false (!)
    
    /**
     * @return bool
     */
    public function DEVELOPER_DEBUG_MODE() {
        return $this::DEVELOPER_DEBUG_MODE;
    }


    /**
     * You stop encrypting cookies to search key - and crypto error during development.
     */
    const USE_ENCRYPTION_FOR_IDENTIFICATION_VALUES = true;  // Should be set to true (!)

    /**
     * @return bool
     */
    public function USE_ENCRYPTION_FOR_IDENTIFICATION_VALUES() {
        return $this::USE_ENCRYPTION_FOR_IDENTIFICATION_VALUES;
    }

    /**
     * If set to true on multiple creation attempts
     * The exception thrown by the creation will be catched
     */
    const IGNORE_MULTIPLE_CREATION_IN_CRUD_MODE = true;

    /**
     * @return bool
     */
    public function IGNORE_MULTIPLE_CREATION_IN_CRUD_MODE() {
        return $this::IGNORE_MULTIPLE_CREATION_IN_CRUD_MODE;
    }

    /**
     * If set to true on multiple deletion attempts
     * The exception thrown by the creation will be catched
     */
    const IGNORE_MULTIPLE_DELETION_ATTEMPT = true;

    /**
     * @return bool
     */
    public function IGNORE_MULTIPLE_DELETION_ATTEMPT() {
        return $this::IGNORE_MULTIPLE_DELETION_ATTEMPT;
    }


    ////////////////////
    // APP
    ///////////////////


    /**
     * Configuration constructor.
     * @param string $executionDirectory
     * @param string $bartlebyRootDirectory
     * @param $runMode
     */
    public function __construct($executionDirectory,$bartlebyRootDirectory,$runMode = Mode::API){
        $this->_executionDirectory = $executionDirectory;
        $this->_bartlebyRootDirectory = $bartlebyRootDirectory;
        $this->runMode=$runMode;
    }

    /**
     * @return string
     */
    public function getExecutionDirectory() {
        return $this->_executionDirectory;
    }

    /**
     * @return mixed
     */
    public function getBartlebyRootDirectory() {
        return $this->_bartlebyRootDirectory;
    }

    /**
     * @return string
     */
    public function STAGE() {
        return $this->_STAGE;
    }

    /**
     * @return string
     */
    public function VERSION() {
        return $this->_VERSION;
    }


    public function getEntitiesName($runMode) {
        if ($runMode == Mode::PAGES) {
            return 'Pages';
        } else {
            return 'EndPoints';
        }
    }


    /**
     * @return array returns an array with all the collections Name
     */
    public function getCollectionsNameList(){
        return [];
    }

    ////////////////////
    // Routes
    ///////////////////


    function getRouteAliases($runMode) {
        if ($runMode == Mode::PAGES) {
            return $this->_getPagesRouteAliases();
        } else {
            return $this->_getEndPointsRouteAliases();
        }
    }

    /**
     * Returns a Routes aliases
     * Should be setup first in BartlebyCommonsConfiguration
     * @return RoutesAliases
     */
    protected function _getEndPointsRouteAliases() {
        $mapping = array();// This message should never appear
        return new RoutesAliases($mapping);
    }

    /**
     * Returns a Routes aliases
     * Should be setup first in BartlebyCommonsConfiguration
     * @return RoutesAliases
     */
    protected function _getPagesRouteAliases() {
        $mapping = array();// This message should never appear
        return new RoutesAliases($mapping);
    }


    ////////////////////
    // Search Paths
    ///////////////////


    function getModelsSearchPaths() {
        return array(
            $this->_executionDirectory . $this->_VERSION . '/_generated/Models/',
            $this->_executionDirectory . $this->_VERSION . '/Models/',
            $this->_bartlebyRootDirectory . 'Commons/Models/',
            $this->_bartlebyRootDirectory . 'Commons/_generated/Models/'
        );
    }


    function getEndpointsSearchPaths() {
        return array(
            $this->_executionDirectory . $this->_VERSION . '/_generated/EndPoints/',
            $this->_executionDirectory . $this->_VERSION . '/EndPoints/',
            $this->_bartlebyRootDirectory . 'Commons/EndPoints/',
            $this->_bartlebyRootDirectory . 'Commons/_generated/EndPoints/'
        );
    }

    function getPagesSearchPaths() {
        return array(
            $this->_executionDirectory . $this->_VERSION . '/_generated/Pages/',
            $this->_executionDirectory . $this->_VERSION . '/Pages/',
            $this->_bartlebyRootDirectory . 'Commons/Pages/',
            $this->_bartlebyRootDirectory . 'Commons/_generated/Pages/'
        );
    }


    /**
     * Define the path for a given class.
     * This method allows fast search resolution and class overload. (hook)
     *
     * @param string $className string the class name.
     * @param string $path  the absolute path
     */
    function definePath($className,$path){
        $this->_fixedPaths[$className]=$path;
    }

    /**
     * Return the path if defined else a "" string
     * @param string $className the class name
     * @return mixed|string
     */
    function getFixedPathForClassName($className=""){
        if (array_key_exists($className,$this->_fixedPaths)){
            return $this->_fixedPaths[$className];
        }else{
            return "";
        }
    }

    ////////////////////
    // Permissions
    ///////////////////


    final function getSuperAdminUIDS() {
        return $this->_superAdmins;
    }


    final function getPermissionsRules() {
        return $this->_permissionsRules;
    }


    protected function addSuperAdminUIDs(array $udids) {
        foreach ($udids as $udid) {
            $this->_superAdmins[] = $udid;
        }
    }


    protected function addPermissions(array $permission) {
        foreach ($permission as $name => $value) {
            $this->_permissionsRules[$name] = $value;
        }
    }


    ////////////////////////
    // IDENTIFICATION
    ////////////////////////


    function  getCryptedKEYForSpaceUID($spaceUID) {
        if ($this->USE_ENCRYPTION_FOR_IDENTIFICATION_VALUES()){
            return $this->salt($spaceUID);
        }else{
            return $spaceUID;
        }

    }

    function encryptIdentificationValue($spaceUID, $userID) {
        if ($this->USE_ENCRYPTION_FOR_IDENTIFICATION_VALUES()){
        // We use $this->_SECRET_KEY truncated to 32Bytes as key
        // We use $spaceUID as Initialization vector
         return base64_encode(mcrypt_encrypt(MCRYPT_RIJNDAEL_128, $this->_32SALT(), $userID, MCRYPT_MODE_ECB, $spaceUID));
        }else{
            return $userID;
        }
    }

    function decryptIdentificationValue($spaceUID, $cryptedUserID) {
        if ($this->USE_ENCRYPTION_FOR_IDENTIFICATION_VALUES()){
        // We use $this->_SECRET_KEY truncated to 32Bytes as key
        // We use $spaceUID as Initialization vector
        return mcrypt_decrypt(MCRYPT_RIJNDAEL_128, $this->_32SALT(), base64_decode($cryptedUserID), MCRYPT_MODE_ECB, $spaceUID);
        }else{
            return $cryptedUserID;
        }
    }

    /**
     * $this->_SECRET_KEY truncated to 32Bytes as key
     * @return string
     */
    protected function _32SALT() {
        return substr($this->_SECRET_KEY, 0, 32);
    }

    ////////////////////
    // FILTERS
    ///////////////////

    /**
     * @param string $endPointKey
     * @param IFilter $filter
     */
    function addFilterIn($endPointKey, IFilter $filter) {
        if (isset($endPointKey) && isset($filter)) {
            $this->_filtersIn[$endPointKey] = $filter;
        }
    }


    /**
     * @param string $endPointKey
     * @param IFilter $filter
     */
    function addFilterOut($endPointKey, IFilter $filter) {
        if (isset($endPointKey) && isset($filter)) {
            $this->_filtersOut[$endPointKey] = $filter;
        }
    }

    function hasFilterOUT($endPointKey) {
        return (array_key_exists($endPointKey, $this->_filtersOut));
    }

    function hasFilterIN($endPointKey) {
        return (array_key_exists($endPointKey, $this->_filtersIn));
    }

    function runFilterIN($endPointKey, $parameters) {
        /* @var $filter IFilter */
        $filter = $this->_filtersIn[$endPointKey];
        return $filter->filterData($parameters);

    }

    function runFilterOUT($endPointKey, $responseData) {
        /* @var $filter IFilter */
        $filter = $this->_filtersOut[$endPointKey];
        return $filter->filterData($responseData);
    }


    ////////////////////
    // SALT
    ///////////////////

    function salt($string) {
        return md5($string . $this->_SECRET_KEY);
    }

    function saltWithSharedKey($string) {
        return md5($string . $this->_SHARED_SALT);
    }


    /*
     * Server side equivalent of swift  HTTPManager.httpHeadersWithToken
     * @param $spaceUID
     * @param $actionName
     */
    public function httpHeadersWithToken($spaceUID, $actionName) {
        $headers = [];
        $headers[SPACE_UID_KEY] = $spaceUID;
        $tokenKey = $this->saltWithSharedKey($actionName.'#'.$spaceUID);
        $tokenValue = $this->saltWithSharedKey($tokenKey);
        $headers[$tokenKey] = $tokenValue;
        return $headers;
    }
}#BMS#->{"filename":"Context.php","checksum":3072511734,"relativePath":"Bartleby\/Core\/Context.php","size":8224}<-#BME#
<?php

namespace Bartleby\Core;
require_once BARTLEBY_ROOT_FOLDER . 'Core/Configuration.php';
require_once BARTLEBY_ROOT_FOLDER . 'Core/IAuthentified.php';
require_once BARTLEBY_ROOT_FOLDER . 'Commons/EndPoints/Auth.php';

use  Bartleby\Core\Configuration;
use  Bartleby\EndPoints\Auth;
use Bartleby\Core\IAuthentified;

/**
 * Class Context
 * @package Bartleby\Core
 */
class Context implements IAuthentified{

    /* @var string the controller class name*/
    public $controllerClassName='';
    /* @var string the 'model' class name*/
    public $modelClassName='';
    /*@var string  the method to be called on the controller class*/
    public $method;

    ////////////////////////////
    // Contextual Informations
    // that are serialized when the context is returned for debug purposes
    // For more detailled infos you can call the Infos Endpoint
    ////////////////////////////
    public $infos=array();

    /* @var array An array of issues used for analysis */
    public $issues=array();

    /* @var Configuration */
    private $_configuration;
    /* @var array */
    private $_allVariables=array();
    /* @var boolean */
    private $_hasBeenCleaned=false;


    // The current user may be stored in the context.


    /**
     * Context constructor.
     * @param array $variables
     * @param \Bartleby\Core\Configuration $configuration
     */
    public function __construct(array $variables, Configuration $configuration) {
        $this->_allVariables=$variables;
        $this->_configuration=$configuration;
        $this->infos['runMode']=$configuration->runMode;
        $this->infos[SPACE_UID_KEY]=$this->getSpaceUID();
        $this->infos['cookies']=$_COOKIE;
    }

    /**
     * Add some parameters (e.g url named parameters.
     * @param array $parameters
     */
    public function addParameters(array $parameters){
        $filtered=$this->_cleanInputs($parameters);
        $this->_allVariables=array_merge($this->_allVariables,$filtered);
    }


    ////////////////////
    // IAuthentified
    ////////////////////


    // The curent user is not always available
    // It may be populated by the GateKeeper
    // Or a by Controller.

    /* @var array user as an array */
    private $_currentUser=null;

    /**
     * @return array
     */
    public function getCurrentUser() {
        return $this->_currentUser;
    }

    /**
     * @param array $currentUser
     */
    public function setCurrentUser($currentUser) {
        $this->_currentUser = $currentUser;
    }


    ////////////////////
    ///  ACCESSORS
    ////////////////////

    /**
     * @return \Bartleby\Core\Configuration
     */
    public function getConfiguration(){
        return $this->_configuration;
    }

    /**
     * Returns all the aggregated variables
     * HTTP headers, QueryString, Post parameters
     * and even named url parameters. e.g "/user/{userId}/comments/{numberOfComment}"
     *
     * @return array
     */
    public function getVariables(){
        if ($this->_hasBeenCleaned){
            return $this->_allVariables;
        }
        $this->_allVariables=$this->_cleanInputs($this->_allVariables);
        $this->_hasBeenCleaned=true;
        return $this->_allVariables;
    }


    /**
     * Grabs the SpaceUID
     * @return null|string the dataSpace UID.
     */
    public function getSpaceUID(){
        $spaceUID=NULL;
        if (array_key_exists(SPACE_UID_KEY,$this->_allVariables)){
            $spaceUID=$this->_allVariables[SPACE_UID_KEY];
        }
        // We may have a contextual cookie
        if (!isset($spaceUID) && array_key_exists(CURRENT_SPACE_UID_COOKIE_KEY,$this->_allVariables)){
            $spaceUID=$this->_allVariables[CURRENT_SPACE_UID_COOKIE_KEY];
        }
        return $spaceUID;
    }



    /**
     * Grabs the runUID
     * @return null|string the run UID.
     */
    public function getRunUID(){
        $runUID=NULL;
        if (array_key_exists(RUN_UID_KEY,$this->_allVariables)){
            $runUID=$this->_allVariables[RUN_UID_KEY];
        }
        return $runUID;
    }

    /**
     * Grabs the observationUID
     * @return null|string the Observation UID.
     */
    public function getObservationUID(){
        $observationUID=NULL;
        if (array_key_exists(OBSERVATION_UID_KEY,$this->_allVariables)){
            $observationUID=$this->_allVariables[OBSERVATION_UID_KEY];
        }
        return $observationUID;
    }

    /**
     * @return bool
     */
    public function usePrettyPrint(){
         if (array_key_exists(JSON_PRETTY_PRINT_KEY,$this->_allVariables)){
             $prettyPrint=strtolower($this->_allVariables[JSON_PRETTY_PRINT_KEY]);
             return ($prettyPrint=="true");
         }
        return false;
    }

    /**
     * Returns the current User UID
     * @return null|string
     */
    public function getCurrentUserUID(){
        return $this->getUserID($this->getSpaceUID());
    }


    /**
     * Returns the userID if there is one in the "kvid" HTTP header field or a cookie.
     * @param $spaceUID
     * @return null|string
     */
    public function getUserID($spaceUID){
        if (!isset($spaceUID)){
            $this->consignIssue('spaceUID is not set',__FILE__,__LINE__);
            return NULL;
        }
        // We the "kvid" http header.
        $userUID=$this->_getUserIDFromKVI($spaceUID);
        if (isset($userUID)){
            return $userUID;
        }
        // And fall back on the cookie.
        return $this->_getUserIDFromCookie($spaceUID);
    }


    /**
     * Returns the userID from the kvi
     * @param $spaceUID
     * @return null|string
     */
    private function _getUserIDFromKVI($spaceUID) {
        $allHeader=getallheaders();
        if (array_key_exists(Auth::kvidKey,$allHeader)) {
            $cryptedUserID = $allHeader[Auth::kvidKey];
            $userID = $this->_configuration->decryptIdentificationValue($spaceUID, $cryptedUserID);
            return $userID;
        }
        return NULL;
    }


    /**
     * Returns the userID from the cookie
     * @param $spaceUID
     * @return null|string
     */
    private function _getUserIDFromCookie($spaceUID) {
        if (!isset($_COOKIE)){
            $this->consignIssue('Php\'s _COOKIE global is not existing.',__FILE__,__LINE__);
        }
        $cookieKey = $this->_configuration->getCryptedKEYForSpaceUID($spaceUID);
        if (array_key_exists($cookieKey, $_COOKIE)) {
            $cookieValue = $_COOKIE[$cookieKey];
            $userID = $this->_configuration->decryptIdentificationValue($spaceUID, $cookieValue);
            return $userID;
        }else {
            $this->consignIssue('Cookie key ' . $cookieKey . ' is not existing.',__FILE__,__LINE__);
        }
        return NULL;
    }
    

    /**
     * return true if there is a consistant cookie for the context
     * @param $spaceUID
     * @return bool
     */
    function hasUserAuthCookie($spaceUID) {
        $cookieKey = $this->_configuration->getCryptedKEYForSpaceUID($spaceUID);
        return (array_key_exists($cookieKey, $_COOKIE));
    }


    /**
     * @param $issue string
     * @param $file string
     * @param $line int
     */
    function consignIssue($issue,$file,$line){
        $this->issues[basename($file).'('.$line.')']=$issue;
    }

    /**
     * returns true if an issue with that text has been found
     * @param $text
     * @return bool
     */
    function containsIssueWithText($text){
        foreach ($this->issues as $k=>$issueText) {
            if (strtolower(trim($issueText))==strtolower(trim($text))) {
                return true;
            }
        }
        return false;
    }


    ////////////////////
    /// PRIVATE METHODS
    ////////////////////

    /**
     * Cleans up the inputs
     *
     * @param $data
     * @return array|string
     */
    private function _cleanInputs($data) {
        $clean_input = Array ();
        if (is_array ( $data )) {
            foreach ( $data as $k => $v ) {
                $clean_input [$k] = $this->_cleanInputs ( $v );
            }
        } else {
            $clean_input = trim ( strip_tags ( $data ) );
        }
        return $clean_input;
    }

}#BMS#->{"filename":"Controller.php","checksum":431339095,"relativePath":"Bartleby\/Core\/Controller.php","size":17442}<-#BME#
<?php

namespace Bartleby\Core;

require_once BARTLEBY_ROOT_FOLDER . 'Commons/_generated/Models/Trigger.php';
require_once BARTLEBY_ROOT_FOLDER . 'Core/Context.php';
require_once BARTLEBY_ROOT_FOLDER . 'Core/KeyPath.php';
require_once BARTLEBY_ROOT_FOLDER . 'Commons/_generated/Models/User.php';

use Bartleby\Core\Context;
use Bartleby\Models\Trigger;
use \MongoCollection;
use Bartleby\Core\Mode;
use MongoClient;
use Bartleby\Models\User;


/**
 * Class Controller
 * @package Bartleby\Core
 */
abstract class Controller implements IAuthentified, IAuthenticationControl {

    /**
     * @var null|bool
     */
    protected $_isAuthenticated = null;

    /**
     * @var null|bool
     */
    protected $_authenticationIsValid = null;

    /**
     * @var string
     */
    protected $_userID;

    /**
     * A model wrapper
     * @var CallDataRawWrapper
     */
    private $_model;

    /**
     * @var \Bartleby\Core\Context
     */
    protected $_context;

    /**
     * Controller constructor.
     * @param $model
     * @param \Bartleby\Core\Context $context
     */
    public function __construct($model, Context $context) {
        ;
        $this->_model = $model;
        $this->_context = $context;
    }

    /**
     * @return Configuration
     */
    protected function getConfiguration() {
        return $this->_context->getConfiguration();
    }

    /**
     * Return the current user UID for a given spaceUID
     * @param $spaceUID
     * @return null|string
     */
    public function getCurrentUserID($spaceUID) {
        if (isset($this->_userID)) {
            return $this->_userID;
        }
        $this->_userID = $this->_context->getUserID($spaceUID);
        return $this->_userID;
    }


    /**
     * Grabs the SpaceUID or throws and Exception
     * @param bool $canBeNull
     * @return mixed|string the dataSpace UID.
     * @throws \Exception if $canBeNull==false and the value has not been found
     */
    public function getSpaceUID($canBeNull = false) {
        $spaceUID = $this->_context->getSpaceUID();
        if (!isset($spaceUID) && !$canBeNull) {
            // It is not normal in api mode
            throw new \Exception("Undefined space UID");
        }
        return $spaceUID;
    }


    /**
     * Grabs the runUID or throws and Exception
     * @param bool $canBeNull
     * @return mixed|string the run UID.
     * @throws \Exception if $canBeNull==false and the value has not been found
     */
    public function getRunUID($canBeNull = false) {
        $runUID = $this->_context->getRunUID();
        if (!isset($runUID) && !$canBeNull) {
            throw new \Exception("Undefined run UID");
        }
        return $runUID;
    }


    /**
     * Grabs the observationUID or throws and Exception
     * @param bool $canBeNull
     * @return mixed|string the Observation UID.
     * @throws \Exception if $canBeNull==false and the value has not been found
     */
    public function getObservationUID($canBeNull = false) {
        $observationUID = $this->_context->getObservationUID();
        if (!isset($observationUID) && !$canBeNull) {
            throw new \Exception("Undefined Observation UID");
        }
        return $observationUID;
    }

    /**
     * Inserts a trigger into the triggers collection to be relayed via SSE.
     *
     * @param string $senderUID
     * @param string $collectionName the collection name
     * @param string $origin the action that has created the trigger
     * @param string $homologousAction e.g: `CreateUser would trigger homologous action `ReadUser`
     * @param mixed $reference can be a collection or a single instance.
     * @return  int  -1 if an error has occured and the trigger index on success.
     * @throws \Exception
     */
    public function relayTrigger($senderUID, $collectionName, $origin, $homologousAction, $reference) {

        // Determine if the trigger should be ephemeral
        $ephemeral = NULL;
        $spaceUID = NO_UID;
        $runUID = NO_UID;
        $requestCounter = "0";
        $observationUID = NO_UID;

        $spaceUID = $this->getSpaceUID(false);
        $observationUID = $this->getObservationUID(false);
        $runUID = $this->getRunUID(false);

        $allHEADER = getallheaders();
        if ($allHEADER != false) {
            if (array_key_exists(EPHEMERAL_KEY, $allHEADER)) {
                $ephemeral = '1';
            }
            if (array_key_exists(REQUEST_COUNTER_KEY, $allHEADER)) {
                $requestCounter = $allHEADER[REQUEST_COUNTER_KEY];
            }
        }

        if (isset($spaceUID) && isset($homologousAction) && isset($reference)) {
            $UIDS = $this->_extractUIDS($reference);
            if (!isset($senderUID) || $senderUID == "") {
                if (strpos($homologousAction, "ReadUser") !== false) {
                    // It is a user creation so we should determine the user creator
                } else {
                    throw new \Exception("Trigger sender is undefined", 0);
                }
            }

            if (count($UIDS) > 0) {

                // Insert the trigger.
                $db = $this->getDB();
                /* @var \MongoCollection */
                $collection = $db->triggers;
                // Default Read policy
                // https://docs.mongodb.com/manual/reference/read-concern/
                $readOptions = array(
                    "r" => "local"
                );

                $trigger = new Trigger();
                $trigger->UID = $runUID . '.' . $requestCounter;
                $trigger->observationUID = $observationUID;
                $trigger->spaceUID = $spaceUID;
                $trigger->senderUID = $senderUID;
                $trigger->runUID = $runUID;
                $trigger->index = -10000; // Distinctive Initial value
                $trigger->origin = $origin;
                $trigger->targetCollectionName = $collectionName;
                $trigger->action = $homologousAction;
                $trigger->UIDS = join(',', $UIDS);
                if (strpos($homologousAction, 'Read') !== false) {
                    // It is a CREATE and UPDATE or an UPSERT
                    if (count($UIDS)==1){
                        $trigger->payloads = array($reference);
                    }else{
                        $trigger->payloads = $reference;
                    }
                } else {
                    // It is a DELETE
                    $trigger->payloads = "[]";
                }

                /////////////////////////////////////////
                /// Triggers index
                /// uses semaphores to guarantee
                /// incremental update of the trigger index
                /// The lock is generated by ObservationUID
                /////////////////////////////////////////

                $useSemaphore = true;
                $semaphoreIdentifier = crc32($observationUID);
                $semResource = NULL;

                if (function_exists('sem_get')) { // Test semaphore support
                    $semResource = sem_get($semaphoreIdentifier, 1, 0666, 1); // get the resource for the semaphore
                    if (sem_acquire($semResource)) { // try to acquire the semaphore in case of success it will block until the sem will be available
                        $trigger->index = $collection->count(['observationUID' => $observationUID], $readOptions);
                    } else {
                        $trigger->index = -10; // Semaphore was not acquired
                    }
                } else {
                    // Semaphore support is required
                    // Theres is no semaphore support
                    $useSemaphore = false;
                    if ($this->getConfiguration()->STAGE() == Stages::LOCAL) {
                        // We can be silent In Case The local Dev Instance Do not support Semaphores
                        // Currently with my MAMP4.X (Semaphores are not supported)
                        $trigger->index = $collection->count(['observationUID' => $observationUID], $readOptions);
                    } else {
                        throw new \Exception("Semaphores support is required", 0);
                    }
                }

                // In case of irrelevant HEADER
                // We want a unique UID so we use the Trigger counter
                if ($requestCounter == "0") {
                    $requestCounter = "E." . ($trigger->index + 0);
                }

                // Default write policy
                // https://docs.mongodb.com/manual/reference/write-concern/
                $options = array(
                    "w" => 1,
                    "j" => true
                );


                $date = new \DateTime();
                $iso8601 = $date->format(DATE_ISO8601);
                $q = array(
                    MONGO_ID_KEY => $trigger->UID,
                    OBSERVATION_UID_KEY => $trigger->observationUID,
                    SPACE_UID_KEY => $trigger->spaceUID,
                    RUN_UID_KEY => $trigger->runUID,
                    "senderUID" => $trigger->senderUID,
                    "index" => $trigger->index,
                    "origin" => $trigger->origin,
                    "action" => $trigger->action,
                    "targetCollectionName" => $trigger->targetCollectionName,
                    "UIDS" => $trigger->UIDS,
                    "creationDate" => $iso8601,
                    "payloads" => $trigger->payloads
                );

                if (isset($ephemeral)) {
                    // To consistent with current JOBject encodings in MongoDB.
                    // We use '1' and not true
                    $q[EPHEMERAL_KEY] = '1';
                }
                $r = $collection->insert($q, $options);

                // Release the semaphore.
                if ($useSemaphore === true) {
                    sem_release($semResource);
                }

                if ($r['ok'] == 1) {
                    return $trigger->index;
                } else {
                    return -1;
                }


            } else {
                throw new \Exception("Void UIDS for trigger $observationUID $spaceUID $senderUID $homologousAction $reference", 0);
            }
        } else {
            throw new \Exception("Inconsitent trigger $observationUID $spaceUID $senderUID $homologousAction $reference", 0);
        }
    }


    /**
     * Returns a json encoded string
     * @param $index with the triggerIndex and and optionnal message
     * @param $optionnalMessage
     * @return string
     */
    public function responseStringWithTriggerIndex($index, $optionnalMessage) {
        if (isset($message)) {
            return array("triggerIndex" => $index, "message" => $optionnalMessage);
        } else {
            return array("triggerIndex" => $index);
        }
    }

    /**
     * Extracts the UIDS from a given reference.
     * @param $reference
     * @param array $UIDS
     * @return array
     */
    private function _extractUIDS($reference, $UIDS = array()) {
        if (isset($reference)) {
            if (is_array($reference)) {
                if (array_key_exists("_id", $reference)) {
                    $UIDS[] = $reference["_id"];
                } else {
                    foreach ($reference as $element) {
                        if (is_array($element)) {
                            return $this->_extractUIDS($element);
                        } elseif (is_string($element)) {
                            $UIDS[] = $element;
                        } else {
                            //
                        }
                    }
                }
            } elseif (is_string($reference)) {
                $UIDS[] = $reference;
            }
        }
        return $UIDS;
    }

    /***
     * Always returns a CallDataRawWrapper
     * @return CallDataRawWrapper
     */
    function getModel() {
        // It can be normal for pages not to have Data wrapper
        // So we create one
        if (!isset($this->_model)) {
            $this->_model = new CallDataRawWrapper([]);
        }
        return $this->_model;
    }

    ///////////////////////////
    /// MONGO IMPLEMENTATION
    //////////////////////////


    /**
     * The MongoDB
     *
     * @var MongoDB
     */
    private $_db;

    /**
     * The Mongo client
     *
     * @var MongoClient
     */
    private $_mongoClient;


    /**
     * @return MongoDB
     */
    protected function getDB() {
        try {
            if (!isset($this->_db)) {
                $client = $this->getMongoClient();
                if (isset($client)) {
                    $this->_db = $client->selectDB($this->getConfiguration()->MONGO_DB_NAME());
                }
            }
            return $this->_db;
        } catch (\MongoConnectionException $e) {
            throw new \Exception("MongoDB Connection Issue. " . $e->getMessage());
        }
    }


    /**
     * @return MongoClient
     */
    protected function getMongoClient() {
        if (!isset($this->_mongoClient)) {
            $this->_mongoClient = new MongoClient ();
        }
        return $this->_mongoClient;
    }


    //////////////////////////////
    //
    // IAuthentified
    //
    //////////////////////////////


    /* @var array user as an array */
    private $_currentUser = null;

    /**
     * @return array
     */
    public function getCurrentUser() {
        if (!isset($this->_currentUser)) {
            // There is no garantee that the context is populated.
            // It can be populated by the GateKeeper if the permission == PERMISSION_BY_IDENTIFICATION
            $this->_currentUser = $this->_context->getCurrentUser();
        }
        if (!isset($this->_currentUser)) {
            $this->_currentUser = $this->_context->getCurrentUser();
        }

        return $this->_currentUser;
    }

    /**
     * @param array $currentUser
     */
    public function setCurrentUser($currentUser) {
        $this->_currentUser = $currentUser;
    }


    //////////////////////////////
    //
    // IAuthenticationControl
    //
    //////////////////////////////


    /**
     * Should return true if there are traces of a previous valid identification (KVIds or cookie)
     * This method does not garantee the validity of the authentication.
     * Call authenticationIsValid($spaceUID) to perform a complete verification at a given time.
     * @param $spaceUID
     * @return mixed
     */
    public function isAuthenticated($spaceUID) {
        if (!isset($this->_isAuthenticated)) {
            $userUID = $this->getCurrentUserID($spaceUID);
            $this->_isAuthenticated = (isset($userUID) ? true : false);
        }
        return $this->_isAuthenticated;
    }

    /**
     * Verifies if the authentication is still valid at a given momentum.
     * @param $spaceUID
     * @return mixed
     */
    public function authenticationIsValid($spaceUID) {
        if (!isset($spaceUID)) {
            $this->_context->consignIssue('spaceUID is not defined', __FILE__, __LINE__);
            return false;
        }
        if (!$this->isAuthenticated($spaceUID)) {
            $this->_context->consignIssue('user is not authenticated', __FILE__, __LINE__);
            return false;
        }
        // We are sure that we have a valid userUID
        $userUID = $this->getCurrentUserID($spaceUID);

        // Let's check if there is a user with that UID
        $currentUser = $this->_getCurrentUser($userUID);
        if (!isset($currentUser)) {
            $this->_context->consignIssue('user ' . $userUID . ' was not found', __FILE__, __LINE__);
            return false;
        }

        // Does that user have set a spaceUID?
        if (!array_key_exists(SPACE_UID_KEY, $currentUser)) {
            $this->_context->consignIssue('Unexisting spaceUID', __FILE__, __LINE__);
            return false;
        }

        // Is the spaceUID consistent?
        if ($currentUser[SPACE_UID_KEY] != $spaceUID) {
            $this->_context->consignIssue('DataSpace is inconsistent', __FILE__, __LINE__);
            return false;
        }

        // Is the user "suspended" ?
        if (array_key_exists('status', $currentUser)) {
            if ($currentUser['status'] == User::Status_Suspended) {
                $this->_context->consignIssue('This user is suspended', __FILE__, __LINE__);
                return false;
            }
        }
        return true;
    }

    /**
     * @return array|null the user or null
     */
    private function _getCurrentUser($userID) {
        if (strlen($userID) < 24) {
            return NULL;
        }
        $user = $this->_context->getCurrentUser();
        if (isset($user)) {
            return $this->_user;
        }
        try {
            $db = $this->getDB();
            /* @var \MongoCollection */
            $collection = $db->users;
            $q = array(MONGO_ID_KEY => $userID);
            $u = $collection->findOne($q);
            if (isset($u)) {
                $this->_context->setCurrentUser($u);
                return $u;
            }
        } catch (\Exception $e) {
            // Silent
            $this->_context->consignIssue('Mongo Exception ' . $e->getMessage(), __FILE__, __LINE__);
        }
        return NULL;
    }

}#BMS#->{"filename":"GateKeeper.php","checksum":878120298,"relativePath":"Bartleby\/Core\/GateKeeper.php","size":18420}<-#BME#
<?php

namespace Bartleby\Core;

require_once BARTLEBY_ROOT_FOLDER . 'Core/IAuthentified.php';
require_once BARTLEBY_ROOT_FOLDER . 'Core/KeyPath.php';
require_once BARTLEBY_ROOT_FOLDER . 'Core/Configuration.php';
require_once BARTLEBY_ROOT_FOLDER . 'Commons/EndPoints/Auth.php';

use Bartleby\Core\KeyPath;
use Bartleby\EndPoints\Auth;
use Bartleby\EndPoints\AuthCallData;
use \MongoClient;
use \MongoCollection;
use \MongoCursorException;
use \MongoDB;
use \MongoId;


/*
 * The GateKeeper implements the security layer of Bartleby's framework.
 */

class GateKeeper {

    /* @var Context */
    private $_context;

    /* @var string */
    private $_className;

    /* @var string */
    private $_methodName;

    /* @var array */
    private $_entitiesUIDS;

    /* @var array */
    private $_user;

    /*@var string */
    private $_currentUserToken;

    /*@var string */
    private $_currentUserUID = NULL;
    
    /**
     * @param Context $configuration
     * @param string $className
     * @param string $methodName
     */
    public function __construct(Context $context, $className, $methodName) {
        $this->_context = $context;
        $components = explode('\\', $className);
        $this->_className = end($components);
        $this->_methodName = $methodName;
    }


    /**
     * @param $parameters
     * @return bool
     */
    public function isAuthorized() {

        if (!isset($this->_context) || !isset($this->_className) || !isset($this->_methodName)) {
            throw new \Exception("Context, Class Name and MethodName  required");
        }

        $key = $this->_className . '->' . $this->_methodName;
        $rules = $this->getConfiguration()->getPermissionsRules();
        if (array_key_exists($key, $rules)) {
            $currentRuleValue = $rules[$key];
            $level = $this->_levelOfRule($currentRuleValue);
            $this->_context->consignIssue('Applicable rule level = ' . $level . '. ',__FILE__,__LINE__);
            if ($level == PERMISSION_IS_BLOCKED) {
                // We block even the SuperAdmins
                return false;
            }
            $allowed = $this->_resultOfRule($level, $key, $currentRuleValue);
            if ($allowed) {
                return true;
            }
        } else {
            $this->_context->consignIssue("Unexisting permission rule key! " . $key,__FILE__,__LINE__);
        }

        // By default if the permission is not blocked
        // any super admin is allowed
        return $this->_isSuperAdmin();
    }


    /**
     * Returns the level of the rule very strictly
     * Blocks  dynamic vicious circles and un consistent permissions
     * @param $rule
     * @param bool|false $wasDynamic
     * @return int
     */
    private function _levelOfRule($rule, $wasDynamic = false) {
        if (is_array($rule)) {
            $hasValidIdsList = false;
            if (array_key_exists(IDS_KEY, $rule)) {
                $ids = $rule[IDS_KEY];
                if (is_array($ids)) {
                    if (count($ids) > 0) {
                        $hasValidIdsList = true;
                    }
                }
            }
            if (array_key_exists(LEVEL_KEY, $rule)) {
                $level = $rule[LEVEL_KEY];
                if (is_numeric($level)) {
                    $level = $level + 0;
                    switch ($level) {

                        case PERMISSION_NO_RESTRICTION:
                            return PERMISSION_NO_RESTRICTION;

                        case PERMISSION_BY_TOKEN:
                            return PERMISSION_BY_TOKEN;

                        case PERMISSION_PRESENCE_OF_A_COOKIE:
                            return PERMISSION_PRESENCE_OF_A_COOKIE;

                        case PERMISSION_BY_IDENTIFICATION:
                            return PERMISSION_BY_IDENTIFICATION;

                        case PERMISSION_RESTRICTED_TO_ENUMERATED_USERS:
                            if ($hasValidIdsList == true) {
                                return PERMISSION_RESTRICTED_TO_ENUMERATED_USERS;
                            } else {
                                return PERMISSION_IS_BLOCKED;
                            }

                        case PERMISSION_RESTRICTED_BY_QUERIES:
                            return PERMISSION_RESTRICTED_BY_QUERIES;

                        case PERMISSION_RESTRICTED_TO_GROUP_MEMBERS:
                            return PERMISSION_RESTRICTED_TO_GROUP_MEMBERS;

                        case PERMISSION_IS_DYNAMIC:
                            if ($wasDynamic == true) {
                                // We do not want a dynamic vicious circle
                                return PERMISSION_IS_BLOCKED;
                            } else {
                                return PERMISSION_IS_DYNAMIC;
                            }

                        case PERMISSION_IS_GRANTED_TO_SUPER_ADMIN_ONLY:
                            return PERMISSION_IS_GRANTED_TO_SUPER_ADMIN_ONLY;
                    }
                }
            }
        }
        return PERMISSION_IS_BLOCKED;
    }

    /**
     * @param $level
     * @param $key
     * @param $rule
     * @return bool
     */
    private function _resultOfRule($level, $key, $rule) {
        switch ($level) {
            case PERMISSION_NO_RESTRICTION:
                return true;
            case PERMISSION_BY_TOKEN:
                return ($this->_tokenIsValid($rule, $this->_context->getSpaceUID()));

            case PERMISSION_PRESENCE_OF_A_COOKIE:
                return $this->_context->hasUserAuthCookie($this->_context->getSpaceUID());

            case PERMISSION_BY_IDENTIFICATION:
                return $this->_identityIsValid($this->_context->getSpaceUID());

            case PERMISSION_RESTRICTED_TO_ENUMERATED_USERS:

                if (!$this->_resultOfRule(PERMISSION_BY_IDENTIFICATION, $key, $rule)) {
                    return false;
                }

                if (array_key_exists(IDS_KEY, $rule)) {
                    $ids = $rule[IDS_KEY];
                    if (is_array($ids)) {
                        $isEnumerated = in_array($this->_context->getCurrentUserUID(), $ids);
                        return $isEnumerated;
                    } else {
                        return false;
                    }
                } else {
                    return false;
                }

            case PERMISSION_RESTRICTED_BY_QUERIES:

                if (!$this->_resultOfRule(PERMISSION_BY_IDENTIFICATION, $key, $rule)) {
                    return false;
                }

                if (array_key_exists(ARRAY_OF_QUERIES, $rule)) {
                    $queries = $rule[ARRAY_OF_QUERIES];

                    if (is_array($queries) && count($queries) > 0) {

                        $userID = $this->_context->getCurrentUserUID();
                        if (isset($userID)) {
                            $this->_getCurrentUser($userID);
                            if (isset($this->_user)) {
                                /*

                                Syntax of a query

                                       SELECT_COLLECTION_NAME
                                       WHERE_VALUE_OF_ENTITY_KEY
                                       EQUALS_VALUE_OF_PARAMETERS_KEY_PATH

                                       COMPARE_WITH_OPERATOR
                                       RESULT_ENTITY_KEY
                                       AND_PARAMETER_KEY or AND_CURRENT_USERID

                                The result is evaluated

                                */


                                foreach ($queries as $query) {
                                    if (

                                        array_key_exists(SELECT_COLLECTION_NAME, $query) &&
                                        array_key_exists(WHERE_VALUE_OF_ENTITY_KEY, $query) &&
                                        array_key_exists(EQUALS_VALUE_OF_PARAMETERS_KEY_PATH, $query) &&
                                        array_key_exists(RESULT_ENTITY_KEY, $query) &&
                                        array_key_exists(COMPARE_WITH_OPERATOR, $query) &&
                                        (array_key_exists(AND_PARAMETER_KEY, $query) || array_key_exists(AND_CURRENT_USERID, $query))
                                    ) {

                                        $collectionName = $query[SELECT_COLLECTION_NAME];
                                        $entityKey = $query[WHERE_VALUE_OF_ENTITY_KEY];
                                        $parameterKeyPath = $query[EQUALS_VALUE_OF_PARAMETERS_KEY_PATH];
                                        $variables=$this->_context->getVariables();
                                        $parameterValue = KeyPath::valueForKeyPath($variables, $parameterKeyPath);

                                        if (isset($parameterValue)) {


                                            // Fetch the entity
                                            $entity = $this->_searchEntity($collectionName, $entityKey, $parameterValue);

                                            if (isset($entity)) {

                                                $resultEntityKey = $query[RESULT_ENTITY_KEY];
                                                $operand1 = NULL;
                                                $operand2 = NULL;

                                                if (array_key_exists($resultEntityKey, $entity)) {
                                                    $operand1 = $entity[$resultEntityKey];
                                                }

                                                if (array_key_exists(AND_CURRENT_USERID, $query)) {
                                                    $operand2 = $userID;
                                                } else if (!array_key_exists(AND_PARAMETER_KEY, $query)) {
                                                    $resultParameterKey = $query[AND_PARAMETER_KEY];
                                                    if (array_key_exists($resultParameterKey, $variables)) {
                                                        $operand2 = $variables[$resultParameterKey];
                                                    }
                                                }

                                                if (isset($operand1) && isset($operand2)) {

                                                    // PROCEED TO EVALUATION
                                                    $operator = $query[COMPARE_WITH_OPERATOR];
                                                    $result = false;
                                                    $toBeEvaluated = '$result=("' . $operand1 . '"' . $operator . '"' . $operand2 . '");';
                                                    eval($toBeEvaluated);
                                                    if ($result == true) {
                                                        return $result;
                                                    }

                                                }
                                            }
                                        }
                                    }
                                }


                            }
                        }
                    }
                }
                return false;


            case PERMISSION_RESTRICTED_TO_GROUP_MEMBERS:

                if (!$this->_resultOfRule(PERMISSION_BY_IDENTIFICATION, $key, $rule)) {
                    return false;
                }

                if (array_key_exists(IDS_KEY, $rule)) {
                    $ids = $rule[IDS_KEY];
                    if (is_array($ids)) {
                        return $this->_isInGroup($ids);
                    } else {
                        return false;
                    }
                } else {
                    return false;
                }

            case PERMISSION_IS_DYNAMIC;

                $rule = $this->_getDynamicPermissionForKey($key);
                $wasDynamic = true;
                $level = $this->_levelOfRule($rule, $wasDynamic);
                return $this->_resultOfRule($level, $key, $rule);

            case PERMISSION_IS_GRANTED_TO_SUPER_ADMIN_ONLY:
                return $this->_isSuperAdmin();

            case PERMISSION_IS_BLOCKED:
                return false;

        }
        return false;
    }

    /**
     * Returns if the current user is super admin
     * @return bool
     */
    private function _isSuperAdmin() {
        $currentUID = $this->_context->getCurrentUserUID();
        $ids = $this->getConfiguration()->getSuperAdminUIDS();
        if (is_array($ids)) {
            if (in_array($currentUID, $ids)) {
                return true;
            }
        }
        return false;
    }

    /// TOKEN

    /**
     * The token validity guarantees that the client knows the shared key
     * and is aware of Bartleby's security token policy.
     * It Verifies the conformity of the Headers or Params with the context,
     * Extracts a Token and compare the expected {key,value}
     * @return bool
     */
    private function _tokenIsValid($rule, $spaceUID) {
        if ($this->getConfiguration()->BY_PASS_SALTED_TOKENS()) {
            return true;
        } else if (array_key_exists(TOKEN_CONTEXT_KEY, $rule)) {
            $context = $rule[TOKEN_CONTEXT_KEY];
            $tokenHeaderkey = str_replace("#" . SPACE_UID_KEY, "#" . $spaceUID, $context);
            $saltedTokenHeaderkey = $this->getConfiguration()->saltWithSharedKey($tokenHeaderkey);
            $expectedValue = $this->getConfiguration()->saltWithSharedKey($saltedTokenHeaderkey);
            $variables=$this->_context->getVariables();
            if (array_key_exists($saltedTokenHeaderkey, $variables)) {
                $matches = ($variables[$saltedTokenHeaderkey] == $expectedValue);
                $this->_context->consignIssue("Token is exists, " . ($matches ? "and its value matches! " : " but its value is not matching! "),__FILE__,__LINE__);
                return $matches;
            } else {
                $this->_context->consignIssue( 'Unexisting token key! ',__FILE__,__LINE__);
            }
        }

        return false;
    }


    /**
     * Returns true if we have found a valid user for this spaceUID
     * @return bool
     */
    private function _identityIsValid($spaceUID) {
        // The user is extracted via "kvid" httpheader value or via a Cookie.
        $userID = $this->_context->getCurrentUserUID();
        if (isset($userID)) {
            $this->_context->consignIssue( 'User has been extracted',__FILE__,__LINE__);
            $user = $this->_getCurrentUser($userID);
            if (isset($user)) {
                return true;
            } else {
                $this->_context->consignIssue( 'User not found! ',__FILE__,__LINE__);
            }
        } else {
            $this->_context->consignIssue( 'User cannot be extracted from cookie! ',__FILE__,__LINE__);
        }

        return false;
    }


    /**
     * Returns the dynamic permission for a given key
     * @param $key
     * @return array
     */
    private function _getDynamicPermissionForKey($key) {
        // Todo implement a fully dynamic approach if necessary
        // The dynamic features may be deprecated.
        return array();
    }


    /**
     * @return array|null the user or null
     */
    private function _getCurrentUser($userID) {
        if (strlen($userID)<24){
            return NULL;
        }
        if (isset($this->_user)) {
            return $this->_user;
        }
        try {
            $db = $this->getDB();
            /* @var \MongoCollection */
            $collection = $db->users;
            $q = array(MONGO_ID_KEY => $userID);
            $u = $collection->findOne($q);
            if (isset($u)) {
                $this->_user = $u;
            }
        } catch (\Exception $e) {
            // Silent
            $this->_context->consignIssue( 'Mongo Exception '.$e->getMessage(),__FILE__,__LINE__);
            return NULL;
        }
        // Store the user in the context for future usages.
        $this->_context->setCurrentUser($this->_user);
        return $this->_user;
    }


    private function _searchEntity($collectionName, $entityKey, $searchValue) {
        try {
            $db = $this->getDB();
            /* @var \MongoCollection */
            $collection = $db->{$collectionName};
            $q = array($entityKey => $searchValue);
            $r = $collection->findOne($q);
            if (isset($r)) {
                return $r;
            }
        } catch (\Exception $e) {
            // Silent
            $this->_context->consignIssue( 'Mongo Exception '.$e->getMessage(),__FILE__,__LINE__);
        }
        return null;
    }


    /**
     * Returns the current userdID extracted from the calling context (cookie , KVids)
     * @return string
     */
    private function _getCurrentUserUID() {
        if (isset($this->_currentUserUID)) {
            return $this->_currentUserUID;
        }
        $this->_currentUserUID = $this->_context->getUserID($this->_context->getSpaceUID());
        return $this->_currentUserUID;
    }


    /**
     * @return boolean
     */
    private function _isInGroup($ids) {
        $userUID = $this->_context->getCurrentUserUID();
        // TODO implement
        return false;
    }


    /***
     * Returns the current configuration
     * @return Configuration
     */
    public function  getConfiguration(){
        return $this->_context->getConfiguration();
    }


    //////////////
    /// MONGO
    //////////////

    /**
     * The MongoDB
     *
     * @var $_db MongoDB
     */
    private $_db;// COUPLAGE A REDUIRE PLUS TARD


    protected function getDB() {
        if (!isset($this->_db)) {
            $client = $this->getMongoClient();
            if (isset($client)) {
                $this->_db = $client->selectDB($this->getConfiguration()->MONGO_DB_NAME());
            }
        }
        return $this->_db;
    }

    /**
     * @return MongoClient
     */
    protected function getMongoClient() {
        if (!isset($this->_mongoClient)) {
            $this->_mongoClient = new MongoClient ();
        }
        return $this->_mongoClient;
    }

    
}#BMS#->{"filename":"Gateway.php","checksum":1174551358,"relativePath":"Bartleby\/Core\/Gateway.php","size":8991}<-#BME#
<?php

namespace Bartleby\Core;

require_once BARTLEBY_ROOT_FOLDER . 'Core/Configuration.php';
require_once BARTLEBY_ROOT_FOLDER . 'Core/Request.php';
require_once BARTLEBY_ROOT_FOLDER . 'Core/RoutesAliases.php';
require_once BARTLEBY_ROOT_FOLDER . 'Core/IResponse.php';
require_once BARTLEBY_ROOT_FOLDER . 'Core/JsonResponse.php';
require_once BARTLEBY_ROOT_FOLDER . 'Core/GateKeeper.php';
require_once BARTLEBY_ROOT_FOLDER . 'Core/Mode.php';
require_once BARTLEBY_ROOT_FOLDER . 'Core/IAuthentified.php';
require_once BARTLEBY_ROOT_FOLDER . 'Core/Context.php';


/**
 * Class Gateway
 *
 * #1 This gateway routes the request to dedicated classes and invokes the relevant method
 * If a method is specified in the alias the method will be used
 * if not Bartleby we will call a method name per HTTP verb e.g $instance->POST($param)
 *
 * #2 It delegates the ACL to the Gatekeeper
 *
 * #3 Applies data filters (filter IN) before invocation and before response (filter OUT)
 *
 * @package Bartleby\Core
 */
class Gateway {

    /**
     * @var \Bartleby\Core\IResponse
     */
    private $_response;

    /**
     * The key used to determine the presence of filters IN/OUT
     * @var string
     */
    private $_filterKey="";


    /* @var Context */
    private $_context;

    /* @var Configuration */
    private $_configuration;

    /**
     * Gateway constructor.
     * @param Configuration $configuration
     */
    public function __construct(Configuration $configuration) {

        $request = new Request();
        $path = $request->getPath();

        $this->_configuration = $configuration;
        $runMode=$this->_configuration->runMode;

        // Search the relevant class file.
        // We put the CallData class within the endpoint class
        // To reduce the discovery operations.
        $searchPaths = ($runMode == Mode::API ? $this->_configuration->getEndpointsSearchPaths() : $this->_configuration->getPagesSearchPaths());
        $routeAliases = $this->_configuration->getRouteAliases($runMode);
        
        // Extract the Context.
        $this->_context = $routeAliases->contextFromPath($path, $request,$this->_configuration);

        $entitiesName = $this->_configuration->getEntitiesName($runMode);
        $unexistingPaths = array();

        // Try first to use a fixed Path 
        // So You can Overload the standard path and define a fixed One
        // To to so you can call `definePath in Configuration for example :
        // $this->definePath("ClassName", $this->_bartlebyRootDirectory . 'Commons/Overloads/EndPoints/ClassName.php');`
        $filePath = $this->_configuration->getFixedPathForClassName($this->_context->controllerClassName);

        if ($filePath == "") {
            // There are no fixed paths.
            // Let's try to resolve using search Paths
            foreach ($searchPaths as $searchPath) {
                $possiblePath = $searchPath . $this->_context->controllerClassName . '.php';
                if (file_exists($possiblePath)) {
                    $filePath = $possiblePath;
                } else {
                    $unexistingPaths[] = $possiblePath;
                }
            }
        }

        if ($filePath == "") {
            // We haven't found any valid File Path
            if ($this->_configuration->DEVELOPER_DEBUG_MODE() == true) {
                $this->_response = new JsonResponse(array("message" => "Bartleby says:\"I would prefer not to!\" - No valid route found",
                    "unexistingPath" => $unexistingPaths,
                    "runMode" => $runMode,
                    "context" => $this->_context
                ), 404);
            } else {
                $this->_response = new JsonResponse(array("message" => "Bartleby says:\"I would prefer not to!\" - No valid route found"
                ), 404);
            }
            return; //  stop the execution flow.
        } else {
            // That's the "normal case"
            // The related file has been found.

            try {

                // Let's require this file
                require_once $filePath;

                if (strpos($filePath,'/Overloads/')!==false){
                    // We use the overloaded class
                    $classForElement = '\\Bartleby\\' . $entitiesName . '\\Overloads\\' . $this->_context->controllerClassName;
                    // We donnot use the overloaded class.
                    $classForCallData = '\\Bartleby\\' . $entitiesName . '\\' . $this->_context->modelClassName;

                }else{
                    // We resolve the classes.
                    $classForElement = '\\Bartleby\\' . $entitiesName . '\\' . $this->_context->controllerClassName;
                    $classForCallData = '\\Bartleby\\' . $entitiesName . '\\' . $this->_context->modelClassName;

                }

                // Extract the method if not defined use the HTTP method as a method name.
                $methodName = (isset($this->_context->method)) ? $this->_context->method : $request->getHTTPMethod();


                // Instantiate the GateKeeper
                $gateKeeper = new GateKeeper($this->_context, $classForElement, $methodName);

                if ($this->_configuration->DISABLE_ACL() === true) {
                    // We authorize any operation
                    $authorized = true;
                }else{
                    $authorized = $gateKeeper->isAuthorized();
                }

                if ($authorized === true) {

                    // Filter IN
                    $filteredParameters = $this->_context->getVariables();
                    $this->_filterKey = $this->_context->controllerClassName . '->' . $methodName;
                    if ($this->_configuration->hasFilterIN($this->_filterKey) && $this->_configuration->DISABLE_DATA_FILTERS() == false) {
                        $filteredParameters = $this->_configuration->runFilterIN($this->_filterKey, $this->_context->getVariables());
                    }

                    // Instanciate Call Data
                    $callDataInstance = new $classForCallData($filteredParameters);
         
                    // We instantiate the class.
                    $instance = new $classForElement($callDataInstance,$this->_context);

                    // We invoke the method
                    if (method_exists($instance, $methodName)) {
                        $response = $instance->{$methodName}();
                        // Store the response
                        $this->_response = $response;
                        return; //  stop the execution flow.
                    } else {
                        $infos = array();
                        $infos [Configuration::INFORMATIONS_KEY] = 'Method ' . $methodName . ' is not supported';
                        $this->_response = new JsonResponse($infos, 405);
                        return; //  stop the execution flow.
                    }

                } else {
                    if ($this->_configuration->DEVELOPER_DEBUG_MODE() == true) {
                        $this->_response = new JsonResponse([   "context" => $this->_context ], 403);
                    } else {
                        $this->_response = new JsonResponse(VOID_RESPONSE, 403);
                    }
                    return; //  stop the execution flow.
                }

            } catch (\Exception $e) {
                if ($this->_configuration->DEVELOPER_DEBUG_MODE() == true) {
                    $this->_response = new JsonResponse([   "exception" => $e->getMessage(),
                                                            "context" => $this->_context ], 406);
                } else {
                    $this->_response = new JsonResponse([ "Exception" => $e->getMessage()], 406);
                }
                return; //  stop the execution flow.
            }
        }
    }

    /**
     * Sends the response or throws an Exception.
     * @throws \Exception
     */
    public function getResponse() {
        if (isset($this->_response)) {
            if ($this->_response instanceof IHTTPResponse){
                if ($this->_response->getStatusCode() <= 0) {
                    throw new \Exception("Inconsistent HTTPStatus code");
                }
            }
            if (isset($this->_response->data)) {
                // Run Filter OUT
                if ($this->_configuration->hasFilterOUT($this->_filterKey) && $this->_configuration->DISABLE_DATA_FILTERS() == false) {
                    $this->_response->data = $this->_configuration->runFilterOUT($this->_filterKey, $this->_response->data);
                }
            }
            // Determine if we should use prettyprint
            $this->_response->usePrettyPrint($this->_context->usePrettyPrint());
            // Send the response
            $this->_response->send();
        } else {
            throw new \Exception("No response from gateway");
        }
    }

}#BMS#->{"filename":"HTMLResponse.php","checksum":2139194418,"relativePath":"Bartleby\/Core\/HTMLResponse.php","size":553}<-#BME#
<?php

namespace Bartleby\Core;

require_once __DIR__ . '/IResponse.php';
require_once __DIR__ . '/Response.php';

class HTMLResponse extends Response implements IResponse {

    public $document;
    public $statusCode;
    private $_prettyPrint;

    function usePrettyPrint($enabled){
        $this->_prettyPrint=$enabled;
    }


    function send(){
        header('Content-Type: text/html;charset=UTF-8');
        header('HTTP/1.1 ' . $this->statusCode. ' ' . Response::getRequestStatus ($this->statusCode));
        echo $this->document;
    }

}#BMS#->{"filename":"IAuthentified.php","checksum":4257970691,"relativePath":"Bartleby\/Core\/IAuthentified.php","size":1008}<-#BME#
<?php

namespace Bartleby\Core;

/**
 * Interface IAuthentified
 * @package Bartleby\Core
 */
interface IAuthentified{

    /**
     * @return array|null
     */
    public function getCurrentUser();

    /**
     * @param array $currentUser
     */
    public function setCurrentUser($currentUser);

}

/**
 * Interface IAuthenticationControl
 * Optionnal Control layer.
 * @package Bartleby\Core
 */
interface IAuthenticationControl{

    /**
     * Should return true if there are traces of a previous valid identification (KVIds or cookie)
     * This method does not garantee the validity of the authentication.
     * Call authenticationIsValid($spaceUID) to perform a complete verification at a given time.
     * @param $spaceUID
     * @return mixed
     */
    public function isAuthenticated($spaceUID);

    /**
     * Verifies if the authentication is still valid at a given momentum.
     * @param $spaceUID
     * @return mixed
     */
    public function authenticationIsValid ($spaceUID);

}#BMS#->{"filename":"IFilter.php","checksum":3471847213,"relativePath":"Bartleby\/Core\/IFilter.php","size":90}<-#BME#
<?php

namespace Bartleby\Core;



interface IFilter {

    function filterData($data);

}#BMS#->{"filename":"IResponse.php","checksum":2803130237,"relativePath":"Bartleby\/Core\/IResponse.php","size":194}<-#BME#
<?php

namespace Bartleby\Core;

interface IResponse {
    function usePrettyPrint($enabled);
    function send();
}

interface  IHTTPResponse extends  IResponse{
    function getStatusCode();
}#BMS#->{"filename":"JsonResponse.php","checksum":774348514,"relativePath":"Bartleby\/Core\/JsonResponse.php","size":1843}<-#BME#
<?php


namespace Bartleby\Core;

require_once __DIR__ . '/IResponse.php';
require_once __DIR__ . '/Response.php';

class JsonResponse extends Response implements  IHTTPResponse{

    /* @var $data the data (we keep the property public for DataFilters) */
    public $data;


    public $_prettyPrint=false;
    /**
     * @var Integer|int
     */
    private $_statusCode=-1;

    /**
     * JsonResponse constructor.
     * @param $data
     * @param $statusCode Integer
     */
    public function __construct($data, $statusCode) {
        $this->data = $data;
        $this->_statusCode = $statusCode;
    }


    function usePrettyPrint($enabled){
        $this->_prettyPrint=$enabled;
    }


    /**
     * @return mixed
     */
    public function getJsonEncodedData() {
        if(!is_array($this->data) && $this->data!=VOID_RESPONSE) {
            // We encapsulate in an array
            return json_encode(array($this->data),($this->_prettyPrint?JSON_PRETTY_PRINT:0));
        }
        return json_encode($this->data,($this->_prettyPrint?JSON_PRETTY_PRINT:0));
    }

    /**
     * @return int
     */
    public function getStatusCode() {
        return $this->_statusCode;
    }


    /**
     * Sends the response
     */
     function send() {
        // we use this for JSON response only
        // We can accounter also redirections so we prefer to set
        // the header contextually.
         $code = $this->getStatusCode();
         header("Access-Control-Allow-Origin: *");
         header("Access-Control-Allow-Methods: *");
         header("Content-Type: application/json");
         $header = 'HTTP/1.1 ' . $code . ' ' . Response::getRequestStatus($code);
         header($header);
         if (isset ($this->data)) {
             $json=$this->getJsonEncodedData();
             echo  $json;
         }
    }
}
#BMS#->{"filename":"KeyPath.php","checksum":3310780431,"relativePath":"Bartleby\/Core\/KeyPath.php","size":3918}<-#BME#
<?php

namespace Bartleby\Core;

/**
 * Class KeyPath
 * Inspired by Cocoa KVC
 * @package Bartleby\Core
 */
class KeyPath {


    /**
     * Returns a value or null
     *
     * @param $instance
     * @param $keyPath
     * @return null
     */
    public static function valueForKeyPath($instance,$keyPath){
        $keyComponents=explode('.',$keyPath);
        if (count($keyComponents)>0){
            $key=array_shift($keyComponents);
            $c=count($keyComponents);
            if($c>1){
                $nextKeyPath=implode('.',$keyComponents);
            }else{
                $nextKeyPath=implode('',$keyComponents);
            }
            if (is_array($instance)){
                if(array_key_exists($key,$instance)) {
                    $member = $instance[$key];
                    if ($c==0){
                        return $member;
                    }
                    return KeyPath::valueForKeyPath($member, $nextKeyPath);
                }
            } else {
                if (property_exists($instance, $key)) {
                    $member = $instance->{$key};
                    if ($c == 0) {
                        return $member;
                    }
                    return KeyPath::valueForKeyPath($member, $nextKeyPath);
                }
            }
        }
        return NULL;
    }

    /**
     * Sets the value for a given keyPath
     *
     * @param $instance the instance is passed by reference.
     * @param $keyPath
     * @param $value
     */
    public static function setValueByReferenceForKeyPath(&$instance,$keyPath,$value){
        $keyComponents=explode('.',$keyPath);
        if (count($keyComponents)>0){
            $key=array_shift($keyComponents);
            $c=count($keyComponents);
            if($c>1){
                $nextKeyPath=implode('.',$keyComponents);
            }else{
                $nextKeyPath=implode('',$keyComponents);
            }
            if (is_array($instance)){
                if(array_key_exists($key,$instance)) {
                    if ($c==0){
                        $instance[$key]=$value;
                    }else{
                        KeyPath::setValueByReferenceForKeyPath($instance[$key], $nextKeyPath,$value);
                    }

                }
            } else {
                if (property_exists($instance, $key)) {
                    if ($c == 0) {
                        $instance->{$key} = $value;
                    } else {
                        KeyPath::setValueByReferenceForKeyPath($instance->{$key}, $nextKeyPath, $value);
                    }

                }
            }
        }
    }

    /**
     * Removes the entity at a given keypath
     * @param $instance the instance is passed by reference
     * @param $keyPath
     * @param $value
     */
    public static function removeKeyPathByReference(&$instance,$keyPath){
        $keyComponents=explode('.',$keyPath);
        if (count($keyComponents)>0){
            $key=array_shift($keyComponents);
            $c=count($keyComponents);
            if($c>1){
                $nextKeyPath=implode('.',$keyComponents);
            }else{
                $nextKeyPath=implode('',$keyComponents);
            }
            if (is_array($instance)){
                if(array_key_exists($key,$instance)) {
                    if ($c==0){
                        unset($instance[$key]);
                    }else{
                        KeyPath::removeKeyPathByReference($instance[$key], $nextKeyPath);
                    }
                }
            } else {
                if (property_exists($instance, $key)) {
                    if ($c == 0) {
                        unset($instance->{$key});
                    } else {
                        KeyPath::removeKeyPathByReference($instance->{$key}, $nextKeyPath);
                    }
                }
            }
        }
    }



}#BMS#->{"filename":"Mode.php","checksum":2706741735,"relativePath":"Bartleby\/Core\/Mode.php","size":92}<-#BME#
<?php

namespace Bartleby\Core;

class Mode{
    const API='api';
    const PAGES='Pages';
}#BMS#->{"filename":"Model.php","checksum":3384345121,"relativePath":"Bartleby\/Core\/Model.php","size":4574}<-#BME#
<?php

namespace Bartleby\Core;

require_once __DIR__.'/ModelTransformer.php';


/**
 * Interface IPatchableFromDictionary
 * @package Bartleby\Core
 */
interface IPatchableFromDictionary {
    /**
     * When a member is a Model
     * you should add its class name to the mapping
     * Don't forget to import and declare the usage of the class.
     *
     * function classMapping(array $mapping=array()){
     *   $mapping['asset']='Asset';
     *   return parent::classMapping($mapping);
     * }
     *
     * How to map a collection ?
     * That's very easy :
     *
     * function classMapping(array $mapping=array()){
     *   $mapping['assets']=array('Asset');
     *   return parent::classMapping($mapping);
     * }
     *
     * @param array $mapping
     * @return array
     */
    function classMapping(array $mapping = array());
}


class Model implements IPatchableFromDictionary {

    public $UID;

    private $_classMapping;

    /**
     * A Model is a typed object that
     * can be populated from a an associative Array
     *
     * @param array $dictionary
     * @throws \Exception
     */
    public function __construct(array $dictionary=array()) {
        if(is_array($dictionary)){
            $this->patchFromDictionary($dictionary);
        }
    }


    /**
     * A generic method to patch an object with a bunch of key Values
     * @param array $dictionary
     * @return mixed
     */
    public final function patchFromDictionary(array $dictionary) {
        if (!empty($dictionary)) {
            foreach ($dictionary as $key => $value) {
                $this->patchKeyWithValue($key, $value);
            }
        }
    }

    /**
     * Apply the patch for a given key.
     * @param $key
     * @param $value
     * @return mixed
     * @throws \Exception
     */
    public final function patchKeyWithValue($key, $value) {
        $mapping = $this->classMapping();
        if (array_key_exists($key, $mapping)) {
            if (is_array($value) || !isset($value)) {
                $class = $mapping[$key];
                if(is_array($class)){
                    // It is a collection
                    $class=$class[0];
                    $this->{$key}=array();
                    foreach ($value as $itemValue) {
                        // Add the sub model to the collection
                        $this->{$key}[]=$this->_getSubModel($key,$class,$itemValue);
                    }
                }else{
                   $this->{$key}=$this->_getSubModel($key,$class,$value);
                }
            } else {
                throw new \Exception($key . ' must be populated from a dictionary');
            }
        } else {
            $this->{$key} = $value;
        }
    }


    /**
     *
     * Return the submodel
     * @param $key
     * @param $value
     * @param $classnameOrTransformerInstance
     * @return mixed
     * @throws \Exception
     */
    private function _getSubModel($key,$value,$classnameOrTransformerInstance){
        if(is_string($classnameOrTransformerInstance)){
            $submodel = new $classnameOrTransformerInstance();
            if (method_exists($submodel, 'patchFromDictionary')) {
                if (isset($value)) {
                    $submodel->patchFromDictionary($value);
                    return $submodel;
                }
            } else {
                throw new \Exception('Submodel ' . $key . ' should implement patchFromDictionary');
            }
        }else{
            // It is a transformer it will map the dictionary to a model.
            if(  is_subclass_of($classnameOrTransformerInstance,'Transformer')){
                return $classnameOrTransformerInstance->modelFromDictionary($value);
            }else{
                throw new \Exception( $classnameOrTransformerInstance . 'should be a model transformer');
            }

        }
        return null;

    }

    /**
     * When a member is a Model
     * you should add its class name to the mapping
     * Don't forget to import and declare the usage of the class.
     *
     * public function classMapping(array $mapping=array()){
     *
     *      return parent::_classMapping(array('mySubModel'=>"MySubModelClassName"));
     * }
     *
     *
     * @param array $mapping
     * @return array
     */
    function classMapping(array $mapping = array()) {
        if (!isset($this->_classMapping)) {
            $this->_classMapping = $mapping;
        }
        return $this->_classMapping;
    }


    // Todo implement toDictionary() - generative ?




}#BMS#->{"filename":"ModelTransformer.php","checksum":1942710936,"relativePath":"Bartleby\/Core\/ModelTransformer.php","size":303}<-#BME#
<?php

namespace Bartleby\Core;

interface IModelTransformer {
    function modelFromDictionary(array $dictionary);
}

abstract class Transformer implements  IModelTransformer{

    function modelFromDictionary(array $dictionary){
        return (new Model())->patchFromDictionary($dictionary);
    }
}
#BMS#->{"filename":"Request.php","checksum":2390694948,"relativePath":"Bartleby\/Core\/Request.php","size":2897}<-#BME#
<?php

namespace Bartleby\Core;

//use Bartleby\Core\RoutesAliases;


class Request {

    /**
     * @var $_method string
     */
    private $_method;

    /* @var $_path string*/
    private $_path;

    /* @var $_data array*/
    private $_data=array();

    /**
     * Request constructor.
     */
    public function __construct() {

        // Requests from the same server don't have a HTTP_ORIGIN header
        if (! array_key_exists ( 'HTTP_ORIGIN', $_SERVER )) {
            $_SERVER ['HTTP_ORIGIN'] = $_SERVER ['SERVER_NAME'];
        }

        // PATH
        $this->_path = '/';
        if(array_key_exists('request',$_REQUEST)){
            $this->_path .= $_REQUEST ['request'];
            $posOfQuestionMark=strpos($this->_path,'?');
            // We filter the query string from the path
            if ($posOfQuestionMark !== false){
                $this->_path = substr($this->_path,0,$posOfQuestionMark);
            }
        }

        // METHOD
        $this->_method = strtoupper ( $_SERVER ['REQUEST_METHOD'] );
        if ($this->_method == 'POST' && array_key_exists ( 'HTTP_X_HTTP_METHOD', $_SERVER )) {
            if ($_SERVER ['HTTP_X_HTTP_METHOD'] == 'DELETE') {
                $this->_method = 'DELETE';
            } else if ($_SERVER ['HTTP_X_HTTP_METHOD'] == 'PUT') {
                $this->_method = 'PUT';
            } else {
                throw new \Exception ("Undefined Http Method");
            }
        }

        // PARAMETERS
        $this->_data=$_REQUEST;
        if(array_key_exists('request',$this->_data)){
            unset($this->_data['request']);
        }
        if(array_key_exists('XDEBUG_SESSION_START',$this->_data)){
            unset($this->_data['XDEBUG_SESSION_START']);
        }
        if(array_key_exists('XDEBUG_SESSION',$this->_data)){
            unset($this->_data['XDEBUG_SESSION']);
        }

        // (!) We donnot want to add attachments data to the parameters.
        // But we can sometimes use "php://input"
        // to extract JSON encoded params from the body
        if ( (!array_key_exists('HTTP_CONTENT_DISPOSITION',$_SERVER))
            || strpos($_SERVER['HTTP_CONTENT_DISPOSITION'],'attachment')===false){
            $flow=file_get_contents("php://input" );
            $flowVariables=json_decode($flow,true);
            if (isset($flowVariables) && is_array($flowVariables)) {
                $this->_data=array_merge($flowVariables,$this->_data);
            }
        }
        // CURRENTLY We don't urlDecode anymore the parameters keys,value

    }

    /**
     * @return string
     */
    public function getPath() {
        return $this->_path;
    }


    /**
     * @return array
     */
    public function getData() {
        return $this->_data;
    }

    /**
     *
     * @return string
     */
    public function getHTTPMethod() {
        return $this->_method;
    }

}#BMS#->{"filename":"Response.php","checksum":3125024405,"relativePath":"Bartleby\/Core\/Response.php","size":1880}<-#BME#
<?php

namespace Bartleby\Core;


class Response {
    /**
     *
     * @param int $code
     * @return string
     */
    public static function getRequestStatus($code) {
        $status = array (
            100 => 'Continue',
            101 => 'Switching Protocols',
            200 => 'OK',
            201 => 'Created',
            202 => 'Accepted',
            203 => 'Non-Authoritative Information',
            204 => 'No Content',
            205 => 'Reset Content',
            206 => 'Partial Content',
            300 => 'Multiple Choices',
            301 => 'Moved Permanently',
            302 => 'Found',
            303 => 'See Other',
            304 => 'Not Modified',
            305 => 'Use Proxy',
            306 => '(Unused)',
            307 => 'Temporary Redirect',
            400 => 'Bad Request',
            401 => 'Unauthorized',
            402 => 'Payment Required',
            403 => 'Forbidden',
            404 => 'Not Found',
            405 => 'Method Not Allowed',
            406 => 'Not Acceptable',
            407 => 'Proxy Authentication Required',
            408 => 'Request Timeout',
            409 => 'Conflict',
            410 => 'Gone',
            411 => 'Length Required',
            412 => 'Precondition Failed',
            413 => 'Request Entity Too Large',
            414 => 'Request-URI Too Long',
            415 => 'Unsupported Media Type',
            416 => 'Requested Range Not Satisfiable',
            417 => 'Expectation Failed',
            423 => 'Locked',
            500 => 'Internal Server Error',
            501 => 'Not Implemented',
            502 => 'Bad EndPointsGateway',
            503 => 'Service Unavailable',
            504 => 'EndPointsGateway Timeout',
            505 => 'HTTP Version Not Supported'
        );
        return ($status [$code]) ? $status [$code] : $status [500];
    }
}#BMS#->{"filename":"RoutesAliases.php","checksum":1910328826,"relativePath":"Bartleby\/Core\/RoutesAliases.php","size":8116}<-#BME#
<?php

namespace Bartleby\Core;

require_once __DIR__ . '/Context.php';
require_once __DIR__ . '/Request.php';
require_once __DIR__ . '/Configuration.php';


use Bartleby\Core\Request;
use Bartleby\Core\Configuration;

class RoutesAliases {

    /**
     * Route aliases support path templating and variables extraction.
     *
     * "/user/{userId}/comments/{numberOfComment}"
     * would normally use the class : UserCommentsWith
     *
     * but if there is an alias it will use its alias
     * e.g '/user/{userId}/comments/'=>'CommentsByUser'
     * It will use the CommentsByUser class.
     *
     * userId value will be added Context->parametersInPath['userId']=2992
     * if the string seems to be a numeric value it will be casted to an integer.
     *
     *
     * Routes Configuration by samples
     *
     *  For PAGES explicit mapping is required :
     *
     *  localhost and localhost/ will point to the Start.php page.
     *  ''=>'Start'
     *
     *  localhost/time
     *  'time'=>'Time',
     *
     * You can specify a not found mapping
     * '*' => 'NotFound'
     *
     *
     * For ENDPOINTS :
     *
     *      You can restrict to one method by prefixing the "<HTTPMethod>:"
     *      'GET:/user/{userId}/comments'=>CommentsByUser
     *
     *      You can specify a method name
     *      'POST:/user/{userId}/comments'=>array('CommentsByUser','POST_method_for_demo')
     *
             Explicit mapping like: "'nuggets'=>'Nuggets'" is not usefull
     *
     *       This is simple route alias api/v1/time will call SSTime (for any supported HTTPMethod)
     *      'time'=>'SSETime' // A server sent event sample
     *
     *
     **/

    private $_mapping = array();

    private $_class_name_suffix='';

    private $_parameters_indexes=array();

    /**
     * @var string
     */
    private $_methodName;


    /**
     * RoutesAliases constructor.
     * @param array $mapping
     */
    public function __construct(array $mapping) {
        $this->_mapping = $mapping;
    }


    /**
     * Adds aliases or replaces existing aliases !
     * @param array $aliases
     */
    public function addAliasesToMapping(array $aliases){
        foreach ($aliases as $alias => $destination) {
            $this->_mapping[$alias]=$destination;
        }
    }


    
    /**
     * @param $path
     * @param \Bartleby\Core\Request $request
     * @param \Bartleby\Core\Configuration $configuration
     * @return Context
     */
    public function contextFromPath($path,Request $request,Configuration $configuration) {

        $httpMethod=$request->getHTTPMethod();

        // Aggregates all the variables into the Context
        // HTTP headers, QueryString, Post parameters
        // and even inject url root based based variables e.g "/user/{userId}/comments/{numberOfComment}"
        $allVariables = getallheaders();
        if (!is_array($allVariables)) {
            $allVariables=[];
        }
        $allVariables=array_merge($allVariables, $request->getData());
        // PHP 5.4 support.
        $allVariables=array_merge($allVariables,$_COOKIE);
        // Instantiate the context Descriptor
        $context = new Context($allVariables,$configuration);


        $class_name = '';
        $hasBeenAliased=false;
        if (array_key_exists($path, $this->_mapping)) {
            $class_name =$this->_extractMethodNameAndReturnDescriptor($this->_mapping[$path]);
        } else {
            $filteredPath = ltrim($path, '/');
            $filteredPath = rtrim($filteredPath, '/');
            foreach ($this->_mapping as $alias => $aliased) {

                // Method prefix support in aliases.
                $httpMethods=array('POST','GET','PUT','DELETE');
                $aliasForcedHttpMethod=NULL;
                foreach($httpMethods  as $supportedMethod){
                   if(strpos($alias, $supportedMethod.':')!==false){
                       $aliasForcedHttpMethod=$supportedMethod;
                   }
                }
                if (isset($aliasForcedHttpMethod) && $aliasForcedHttpMethod!=$httpMethod){
                    // That's not the good HTTP method
                    continue;
                }
                if (isset($aliasForcedHttpMethod) && $aliasForcedHttpMethod==$httpMethod){
                    // That's the good HTTP method
                    // Let's remove the prefix
                    $alias=str_replace($httpMethod.':','',$alias);
                }

                $this->_parameters_indexes=array();//reset
                $this->_methodName=NULL;
                if ($this->_mapsTheAlias($filteredPath, $alias, $context)) {
                    if(is_array($aliased)){
                        $class_name =$aliased[0];
                        if (count($aliased)>=1){
                            $this->_methodName=$aliased[1];
                        }
                    }else{
                        $class_name = $aliased;
                    }
                    $hasBeenAliased=true;
                    break;
                }
            }
            if ($class_name === '') {
                $pathParts = explode('/', $filteredPath);
                $i=0;
                foreach($pathParts as $part){
                    if(! in_array($i,$this->_parameters_indexes)){
                        $class_name.=ucfirst($part);
                    }
                    $i++;
                }
            }
        }
        if($hasBeenAliased==false){
            $class_name.=$this->_class_name_suffix;
        }
        $context->controllerClassName = ucfirst($class_name);
        $context->modelClassName = ucfirst($class_name) . 'CallData';
        $context->method=$this->_methodName;// If Null the Gateway we will use generic HTTP methods

        return $context;
    }

    /**
     * @param $path
     * @param $alias
     * @param $contextDescriptor Context
     * @return bool
     */
    private function _mapsTheAlias($path, $alias, $contextDescriptor) {
        if($alias=='*'){
            return true;
        }
        $stringAlias=$this->_extractMethodNameAndReturnDescriptor($alias);
        $a = ltrim($stringAlias, '/');
        $a = rtrim($a, '/');
        $pathParts = explode('/', $path);
        $aliasParts = explode('/', $a);
        if (count($aliasParts) != count($pathParts)) {
            return false;
        }
        $parameters = array();
        $i = 0;
        foreach ($aliasParts as $aliasPart) {
            $starts=substr($aliasPart,0,1);
            $ends=substr($aliasPart, -1,1);
            $isAVariable = ( $starts== "{" && $ends== "}");
            if ($isAVariable == true) {
                $variableName=substr($aliasPart,1,strlen($aliasPart)-2);
                $variableValue=$pathParts[$i];
                if(is_numeric($variableValue)){
                    $variableValue=$variableValue+0;// Convert to Scalar Ohh my God ... PHP! :)
                }
                $parameters[$variableName]=$variableValue;
                $this->_parameters_indexes[]=$i;
            } else if ($pathParts[$i] !== $aliasPart) {
                return false;
            }
            $i++;
        }
        $nbOfPInP=count($parameters);
        if($nbOfPInP==1){
            $this->_class_name_suffix='By';
        }elseif ($nbOfPInP>1){
            $this->_class_name_suffix='With';
        }
        
        // We add the path parameters to the context
        $contextDescriptor->addParameters($parameters);
        return true;
    }


    /**
     * @param $mapping
     * @return bool|mixed
     */
    private function _extractMethodNameAndReturnDescriptor($mapping){
        if(is_array($mapping)){
            if (count($mapping)>=1) {
                $this->_methodName = $mapping[1];
                return $mapping[0];
            }
        }elseif (is_string($mapping)){
            return $mapping;
        }
        // There is no explicit method Name;
        return false;
    }

    /**
     * The mapping array
     * @return array
     */
    public function getMapping(){
        return $this->_mapping;
    }
}#BMS#->{"filename":"ServerSentEvent.php","checksum":2961238825,"relativePath":"Bartleby\/Core\/ServerSentEvent.php","size":1906}<-#BME#
<?php

namespace Bartleby\Core;

use Closure;

require_once BARTLEBY_ROOT_FOLDER.'Core/IResponse.php';

/**
 * Class ServerSentEvent
 * Implements Closure based Server Side events.
 * You should override check SSETime for a concrete Example
 *
 * IMPORTANT NOTE (!)
 * This implementation need to run as MOD on linux apache
 * mod_php (run as Apache's user)
 * the  ob_flush() call Is Needed on Linux
 * This code will not work using FAST CGI or CGI
 *
 * @package Bartleby\Core
 */
class ServerSentEvent extends  \stdClass implements IResponse {

    /* @var $callBack Closure */
    public $callBack;

    private $_frequencyPerHour;

    private $_sleepDuration;

    public function __construct($frequencyPerHour){
        $this->_frequencyPerHour= (isset($frequencyPerHour)&& $frequencyPerHour>0) ? $frequencyPerHour : 10 ;
        $this->_sleepDuration=(3600/$this->_frequencyPerHour);
    }

    public function usePrettyPrint($enabled){
        // We don't want to do anything in this case.
    }


    /**
     * Sends the response
     */
    function send() {
        header('Content-Type: text/event-stream');
        header('Cache-Control: no-cache');
        header("Connection: keep-alive");
        while(true) {
            if ($this->_is_closure($this->callBack)) {
                $this->callBack->__invoke();
            }else{
                throw new \Exception("Closure expected in ServerSentEvent");
            }
            sleep($this->_sleepDuration);
        }
    }

    private function _is_closure($t) {
        return is_object($t) && ($t instanceof Closure);
    }


    public function sendMsg($id,$eventName, $msg) {
        echo "id: $id" . PHP_EOL;
        echo "event: $eventName". PHP_EOL;
        echo "data: $msg" . PHP_EOL;
        echo PHP_EOL;
        if (PHP_OS != "Darwin") {
            ob_flush(); // Needed on Linux (!)
        }
        flush();
    }

}#BMS#->{"filename":"Stages.php","checksum":271076286,"relativePath":"Bartleby\/Core\/Stages.php","size":183}<-#BME#
<?php

namespace Bartleby\Core;

class Stages{
    const LOCAL='local';
    const DEVELOPMENT='development';
    const ALTERNATIVE='alternative';
    const PRODUCTION='production';
}
#BMS#->{"filename":"FAQ.md","checksum":909336307,"relativePath":"Bartleby\/FAQ.md","size":1292}<-#BME#
# FAQ 


## Do i need MongoDB ?
Currently Bartleby's api are relying on : PHP / MONGODB + JSON

## So What are the server prerequisits?

1. Min version of **PHP is 5**
2. **enable mcrypt** 
3. **allow cookies**
4. configure the **MongoDb php client**
5. to support **Server Sent Event** (aka SSE) on LINUX + APACHE we need to run as PHP as a module *apache mod_php* (run as Apache's user). **FAST CGI or CGI do not work currently**
6. Be sure to enable **Semaphore / Shared memory support**

### How to install mcrypt for PHP5 on Debian ?
```
sudo apt-get install php5-mcrypt
sudo php5enmod mcrypt
```
Then restart the web server.

####  How to test that mcrypt is available?
```
<BaseURL>www/Diagnostics/is-mcrypt-supported.php
```

####  How to test that cookies are enabled?
```
<BaseURL>www/Diagnostics/are-cookies-enabled.php
```

####  How to test that semaphores and shared memory support are enabled?
```
<BaseURL>www/Diagnostics/are-semaphores-enabled.php
```


# Known Issues

## PHP 5.6 *always_populate_raw_post_data*
If you are using php 5.6 en encounter the warning "Deprecated: Automatically populating $HTTP_RAW_POST_DATA is deprecated and will be removed in a future version." 
This is a Langage level BUG. You should set 'always_populate_raw_post_data = -1' in your php.ini #BMS#->{"filename":"MongoCallDataRawWrapper.php","checksum":3878857550,"relativePath":"Bartleby\/Mongo\/MongoCallDataRawWrapper.php","size":205}<-#BME#
<?php


namespace Bartleby\mongo;

require_once BARTLEBY_ROOT_FOLDER . 'Core/CallDataRawWrapper.php';

use Bartleby\Core\CallDataRawWrapper;

class MongoCallDataRawWrapper extends CallDataRawWrapper {



}#BMS#->{"filename":"MongoConfiguration.php","checksum":1666506135,"relativePath":"Bartleby\/Mongo\/MongoConfiguration.php","size":264}<-#BME#
<?php


namespace Bartleby\Mongo;

require_once BARTLEBY_ROOT_FOLDER . 'Core/Configuration.php';
require_once BARTLEBY_ROOT_FOLDER . 'Core/Mode.php';

use Bartleby\Core\Configuration;
use Bartleby\Core\Mode;

class MongoConfiguration extends Configuration {
    
}#BMS#->{"filename":"MongoController.php","checksum":1364142954,"relativePath":"Bartleby\/Mongo\/MongoController.php","size":370}<-#BME#
<?php

namespace Bartleby\Mongo;

require_once BARTLEBY_ROOT_FOLDER . 'Mongo/MongoConfiguration.php';
require_once BARTLEBY_ROOT_FOLDER . 'Core/Controller.php';

use Bartleby\Core\Controller;
use Bartleby\Core\IPersistentController;
use \MongoClient;
use \MongoCursorException;
use \MongoDB;
use \Bartleby\Core\JsonResponse;

class MongoController extends Controller {
}#BMS#->{"filename":"MongoEndPoint.php","checksum":1784369403,"relativePath":"Bartleby\/Mongo\/MongoEndPoint.php","size":578}<-#BME#
<?php

namespace Bartleby\Mongo;

require_once BARTLEBY_ROOT_FOLDER . 'Core/CallData.php';
require_once BARTLEBY_ROOT_FOLDER . 'Core/CallDataRawWrapper.php';
require_once BARTLEBY_ROOT_FOLDER . 'Core/JsonResponse.php';
require_once BARTLEBY_ROOT_FOLDER . 'Core/Configuration.php';
require_once BARTLEBY_ROOT_FOLDER . 'Mongo/MongoController.php';
require_once BARTLEBY_ROOT_FOLDER . 'Mongo/MongoCallDataRawWrapper.php';


class MongoEndPoint extends MongoController {

    public $POST = "POST";
    public $GET = "GET";
    public $PUT = "PUT";
    public $DELETE = "DELETE";

}#BMS#->{"filename":"MongoHTML5Page.php","checksum":2435154855,"relativePath":"Bartleby\/Mongo\/MongoHTML5Page.php","size":145}<-#BME#
<?php

namespace Bartleby\Mongo;

require_once BARTLEBY_ROOT_FOLDER . 'Mongo/MongoPage.php';

abstract class MongoHTML5Page extends MongoPage {
}#BMS#->{"filename":"MongoPage.php","checksum":618118755,"relativePath":"Bartleby\/Mongo\/MongoPage.php","size":2803}<-#BME#
<?php

namespace Bartleby\Mongo;

require_once BARTLEBY_ROOT_FOLDER . 'Mongo/MongoController.php';
require_once BARTLEBY_ROOT_FOLDER . 'Core/CallDataRawWrapper.php';
require_once BARTLEBY_ROOT_FOLDER . 'Core/HTMLResponse.php';

use Bartleby\Core\CallDataRawWrapper;
use \MongoClient;


abstract class MongoPage extends MongoController {

    public $POST = "POST";
    public $GET = "GET";

    protected $_title='';
    protected $_charset='utf-8';
    protected $_lang='en';


    // HEAD
    private $_TOP_SCRIPTS=array();
    // End of the document.
    private $_BOTTOM_SCRIPTS=array();
    //
    private $_METAS=array();
    //
    private $_CSS=array();
    


    /***
     * Adds a css file link.
     * @param string $relativePath
     */
    protected  function addCSS($relativePath){
        $this->_CSS[]=$relativePath;
    }

    /***
     * Adds a script
     * @param $script
     */
    protected  function addTopScript($script){
        $this->_TOP_SCRIPTS[]=$script;
    }

    /***
     * Adds a script
     * @param $script
     */
    protected  function addBottomScript($script){
        $this->_BOTTOM_SCRIPTS[]=$script;
    }

    /**
     * Import a JS File 
     * e.g : $this->importJSFile('static/js/TimeSSE.js');
     * @param $relativePath
     */
    protected  function importJSFile($relativePath){
        $this->_BOTTOM_SCRIPTS[]='<script src="'.$this->absoluteUrl($relativePath).'"></script>';
    }
    
    /***
     * Adds a Meta
     * e.g: $this->addMeta('<meta name="keywords" lang="en" content="arts">')
     * @param $metaLine
     */
    protected  function addMeta($metaLine){
        $this->_METAS[]=$metaLine;
    }


    // The accessors

    protected function _CSSLink(){
        $links='';
        foreach ($this->_CSS as $link) {
            $links .= '
    <link href="'.$link.'" rel="stylesheet">';
        }
        return $links;
    }



    protected  function _top_scripts(){
        $scripts='';
        foreach ($this->_TOP_SCRIPTS as $script) {
            $scripts .= $script;
        }
        return $scripts;
    }


    protected  function _bottom_scripts(){
        $scripts='';
        foreach ($this->_BOTTOM_SCRIPTS as $script) {
            $scripts .= $script;
        }
        return $scripts;
    }

    protected  function _metas(){
        $metas='';
        foreach ($this->_METAS as $meta) {
            $metas .= $meta;
        }
        return $metas;
    }

    //

    public function absoluteUrl($relativePath){
        return $this->getConfiguration()->BASE_URL().ltrim($relativePath,'/');
    }


    /**
     * Returns the Api URL
     */
    function  getApiBaseURL(){
        $apiSignature='api/v1/';
        $baseURL=$this->getConfiguration()->BASE_URL().$apiSignature;
        return $baseURL;
    }


    

}#BMS#->{"filename":"ReadMe.md","checksum":1818996625,"relativePath":"Bartleby\/ReadMe.md","size":12417}<-#BME#
# Bartleby Version 1.0 #

Bartleby is a robust framework for Fault Tolerent Natives Distributed Desktop & Mobile Apps. 
It provides a integrated full stack  (clients and servers Api)
Api are written in PHP and uses MongoDB as document store.

It offers a unique distributed execution strategy and a solid permission and security model that enables to build complex collaborative tools efficiently. It has been developed to be used in and is fully integrated with a code generator called 'Flexions'.

Bartleby 1.0 has been developed by Benoit Pereira da Silva [Benoit Pereira da Silva](https://pereira-da-silva.com) for [Chaosmos SAS](http://chaosmos.fr).
Bartleby is licensed to its customers. 

## Code generation ## 

We use a swagger 2.0 descriptor to generate code both server side and client side.
1. You should first proceed to modeling  "swagger.definitions" 
2. You can use the "Flexions/modules/Bartleby/swagger-meta-template" to generate the Swagger paths to provide Entity CRUD, and collection of entities CRUD endpoints.
3. You can generate the server side & clients side components.

### server side API 

- project skeleton
- per entity endpoints (CRUD)/ collections (CRUD) 
- Authentication and permissions.
- pages

### client side libraries

iOS / Mac OS x
- models
- endpoints commands
- collection controllers

## The www folder 

## OTHERS 

- .htacess (when using apache)
- Configuration.php
- destructiveInstaller.php (to be deleted on deployment)
- index.php (routes http://host.ext/ to pages/go.php

### API 

- api/ 
- api/<version>/endpoints/ 
- api/<version>/_generated/
- api/<version>/_generated/endpoints/
- api/<version>/_generated/models/
- api/go.php
- _generated/
- _generated/<version>/GeneratedConfiguration.php

### PAGES 

- pages/
- pages/go.php
- pages/<version>/
- pages/<version>/pages/


# API run cycle

+ index.php or .htacess invokes -> go.php
+ it instanciate the Gateway that resolve the route
+ the route is translated to classes and parameters are deserialized
+ the context is passed to the GateKeeper that allows or rejects the call according to the permissions rules
+ If a filter IN applies the data is proceeded
+ if allowed the Relevent method of the class is called with is parametric context.
+ If a filter OUT applies the data is proceeded


# Bartleby's Permission model 

Bartleby uses permissions that are declared in the configuration file.
Bartleby's Permission model based on levels. 

## Permission levels

From Level 1 (PERMISSION_NO_RESTRICTION access with no restriction) to levele 131072 (PERMISSION_IS_BLOCKED)
The gatekeeper check if the path is allowed in the current context.
The permission are verified on any method call.

+ PERMISSION_IS_STATIC = 0 (implicit)
+ PERMISSION_NO_RESTRICTION = 1 
+ PERMISSION_BY_TOKEN = 2
+ PERMISSION_PRESENCE_OF_A_COOKIE = 3
+ PERMISSION_BY_IDENTIFICATION = 4
+ PERMISSION_RESTRICTED_TO_ENUMERATED_USERS = 5 
+ PERMISSION_RESTRICTED_BY_QUERIES = 6 
+ PERMISSION_RESTRICTED_TO_GROUP_MEMBERS = 9
+ PERMISSION_IS_DYNAMIC=32768 // We reserve the ability to add new permission types
+ PERMISSION_IS_GRANTED_TO_SUPER_ADMIN_ONLY=65536
+ PERMISSION_IS_BLOCKED=131072 // For security purpose we can lock super admin


## The GateKeeper 

Extracts the permission "rule" 
rule A = if there is permission for the local key = 'PathClassName->MethodName'

If the permission is dynanic (rule A or B returns a level >= PERMISSION_IS_DYNAMIC) GateKeeper can deduct the dynamic permission key.
The rule C = the dynamic rule loaded from the permission collection.

If the rule is valid the call occurs, else Bartleby responds an http status code 403=>'Forbidden'  (not 401=>'Unauthorized')
If the current user is SuperAdmin && PERMISSION_IS_BLOCKED the call is blocked.

### Levels descriptions  

#### Level 1 (PERMISSION_NO_RESTRICTION)
Access with no restriction
     
     array ( 'PathClassName->MethodName' => array( 'level' => PERMISSION_NO_RESTRICTION)
     
#### Level 2 (PERMISSION_BY_TOKEN)
Verification of the token 
We check if the token is valid within the context
The $spaceUID can be injected in the name string if there is a #spaceUID in the declaration
To determine the validity we compute the value as  MD5(SHARED_SALT.name)

     array ('PathClassName->MethodName' => array( 'level' => PERMISSION_BY_TOKEN,TOKEN_CONTEXT,'PathClassName#spaceUID') 
     array ('CreateUser->call'=>array('level' => PERMISSION_BY_TOKEN,TOKEN_CONTEXT=>'CreateUser#spaceUID') 
    
#### Level 3 (PERMISSION_PRESENCE_OF_A_COOKIE)
On successful authentication a cookie is placed (the client should store it)
Any call without that cookie is reputed not identified

    array ( 'PathClassName->MethodName' => array( 'level' => PERMISSION_PRESENCE_OF_A_COOKIE,'name'=>'user-#spaceUID','value'=>'') 

#### Level 4 (PERMISSION_BY_IDENTIFICATION)
Verification of the cookie 
We check if the cookie correspond to a valid identified user.

    array ( 'PathClassName->MethodName' => array( 'level' => PERMISSION_BY_IDENTIFICATION) 

#### Level 5 (PERMISSION_RESTRICTED_TO_ENUMERATED_USERS)
Per path permission for enumerated users 

    array ( 'PathClassName->MethodName' => array( 'level' => PERMISSION_RESTRICTED_TO_ENUMERATED_USERS, 'ids' => ['<UserID>'])
    array ( 'PathClassName->MethodName(entityUID)' => array( 'level' => PERMISSION_RESTRICTED_TO_ENUMERATED_USERS_FOR_A_GIVEN_ID,'ids' => ['<UserID>'])

#### Level 6 (PERMISSION_RESTRICTED_BY_QUERIES)

We run queries if one of the query is successfull the action is permitted. 
You can use AND_CURRENT_USERID => true or AND_PARAMETER_KEY=>"<your propertyname>" for the predicate evaluation.

       'UpdateUser->call'=>array(
          'level' => PERMISSION_RESTRICTED_BY_QUERIES,
          ARRAY_OF_QUERIES =>array(
              "hasCreatedCurrentUser"=>array(
                  SELECT_COLLECTION_NAME=>'users',
                  WHERE_VALUE_OF_ENTITY_KEY=>'_id',
                  EQUALS_VALUE_OF_PARAMETERS_KEY_PATH=>'user._id',

                  COMPARE_WITH_OPERATOR=>'==',
                  RESULT_ENTITY_KEY=>'creatorUID',
                  AND_CURRENT_USERID=>true
              ),
              "isCurrentUser"=>array(
                  SELECT_COLLECTION_NAME=>'users',
                  WHERE_VALUE_OF_ENTITY_KEY=>'_id',
                  EQUALS_VALUE_OF_PARAMETERS_KEY_PATH=>'user._id',

                  COMPARE_WITH_OPERATOR=>'==',
                  RESULT_ENTITY_KEY=>'_id',
                  AND_CURRENT_USERID=>true
              )
          )
      ),

      'DeleteUser->call'=>array(
          'level' => PERMISSION_RESTRICTED_BY_QUERIES,
          ARRAY_OF_QUERIES =>array(
              "hasCreatedCurrentUser"=>array(
                  SELECT_COLLECTION_NAME=>'users',
                  WHERE_VALUE_OF_ENTITY_KEY=>'_id',
                  EQUALS_VALUE_OF_PARAMETERS_KEY_PATH=>'userId',

                  COMPARE_WITH_OPERATOR=>'==',
                  RESULT_ENTITY_KEY=>'creatorUID',
                  AND_CURRENT_USERID=>true
          ),
              "isCurrentUser"=>array(
                  SELECT_COLLECTION_NAME=>'users',
                  WHERE_VALUE_OF_ENTITY_KEY=>'_id',
                  EQUALS_VALUE_OF_PARAMETERS_KEY_PATH=>'userId',

                  COMPARE_WITH_OPERATOR=>'==',
                  RESULT_ENTITY_KEY=>'_id',
                  AND_CURRENT_USERID=>true
              )
          )
      )
                  
                  

#### Level 7 (PERMISSION_RESTRICTED_TO_GROUP_MEMBERS)

Before to return or proceed to any operation the gate keeper will check if the root targetted objects entityUID are set to be in one of the current user group.


      array ( 'PathClassName->MethodName(entityUID)' => array( 'level' => PERMISSION_RESTRICTED_TO_GROUP_MEMBERS)

#### Level 32768 PERMISSION_IS_DYNAMIC
Permission level is dynamic we load the permission level from a collection of permissions.
Any permission level can be set e

    array ( 'PathClassName->MethodName()' => array( 'level' => PERMISSION_IS_DYNAMIC)
    array ( 'PathClassName->MethodName(entityUID)' => array( 'level' => PERMISSION_IS_DYNAMIC)
    
#### Level 65536 PERMISSION_IS_GRANTED_TO_SUPER_ADMIN_ONLY
Permission is granted to the declared super admins.


#### Level 131072 (PERMISSION_IS_BLOCKED)
For security purpose we can even block super admins.


# Data Modeling conventions : 

We use a Swagger derived model to modelize the entities.

## Composition 

By default we use AllOf as root of the entity modeling to allow composition.

## References 
External references.

## Aliases 

Aliases are used to maintain loosely coupled sets of entities. 
An alias stores all the necessary data to find a unique set of resource and optionally their labels. 
You can use an alias embedded or use it as an external reference. 


## Triggers 
@todo => equivalent to distributed notification.

## Metadata

We can inject metadata in the Entities. 


# Bartleby's synchronisation 

It is possible to synchronize local collections to a collaborative server.
And to subscribe for server sent event for example for messaging purposes.
The Data of a synchronised package can be regenerated.



# Generated Foundations   

## List of required generated objects

Any Bartleby app should use those reserved object.
You can add properties.

+ User
+ Group
+ Permission 
+ Reference
+ Tag

## Minimal Schema 

TODO create a separate Flexion target to include automatically those.

        "..."
            
         
## Filters 

Sample of a filter IN 
       
        // Is this sample Every user will be named ZORRO before DB insertion
        $data=NULL;// Dummy data for the IDE
        $filterCreateUser=new FilterHookByClosure();
        $filterCreateUser->closure=function($data) {
            KeyPath::setValueByReferenceForKeyPath($data,"user.username","Zorro!");
            return $data;
        };
        $this->addFilterIn('CreateUser->call',$filterCreateUser);
        
       
       

# ********* TO BE REEVALUATED *************

## OFF Line support

Object are created, updated, deleted calling isolated transaction like : "CreateNote"


# Bartleby's Distributed execution strategy

Distributed observer are created lazzyly by posting the first command for a given root object UID.

## COMMANDS
 
The commands identifiers

+ CREATE= 1 
+ READ = 2      
+ UPDATE = 3
+ DELETE = 4 
+ LINK = 5
+ UNLINK = 6
+ ADD_COLLECTION_ITEM = 7
+ INSERT_COLLECTION_ITEM = 8
+ UPDATE_COLLECTION_ITEM = 9
+ DELETE_COLLECTION_ITEM = 10
+ MOVE_COLLECTION_ITEM = 11
+ LINK_COLLECTION_ITEM = 12
+ UNLINK_COLLECTION_ITEM = 13 


## On the client A 

1. self.startDistributedOperations(channelUID)
2. "objx.set(value)" occurs
3. the value is immediately set on objx.
4. the value is added to the related operation eg: updateSentence() && the operation is  provisioned (serialized to DocumentWrapper/.provisioning/)
5. the sequence 2->4 can be repeat X times before : self.stopDistributedOperations(channelUID) occurs
6. operations are then reduced (e.g nuclear updates are mapped to collective updates)
7. operations are declared pending  == serialized  DocumentWrapper/.pending/
8. when possible the operations are called passing the channelUID and its creatorUID as a parameter
9. after successful transmission operation are moved to DocumentWrapper/.stored/

## Server Side 

1. for any CRUD endpoint call if there is a channelUID each call is serialized as a Command

## On the client B (first connection to the channel)  

1. the client GET the root Object of the channel.
2. the callsGET commands (channelUID, fromIndex)  passing 0 as fromIndex
3. the client subscribes to the channel by calling a SSE endpoint (L4 "subscribes:channelUID" access control applies)
4. the SSE endpoints transmits the bunch of commands (excluding the commands that has be emitted by the subscriber ) 
5. if necessary (in case of a disconnection or a hole in the index list) the client can call GET commands (channelUID, fromIndex) 
6. if there are no holes the sequence of command is interpreted and moved to DocumentWrapper/.stored/ the other commands are DocumentWrapper/.delayed/ until there is no more lacking indexes.

## On the client B (next connection)  

1. the client calls GET commands (channelUID, fromIndex)  passing its lastIndex as fromIndex
2. executes the commands and moves them to to DocumentWrapper/.stored/

## The CommandsSSE
Works using Server sent events
Each N seconds#BMS#->{"filename":"Tutorial.md","checksum":3627771930,"relativePath":"Bartleby\/Tutorial.md","size":1207}<-#BME#
<# Command line Tutorial #

## Install HTTPIE if necessary ##

You can install [HTTPie] (https://github.com/jkbrzt/httpie)

## 1- Setup the base URL ##

    BASE_URL=http://localhost/api/v1/

## 2- Reachability and Configuration ## 

### Is the app reachable ? ### 

    http GET ${BASE_URL}/reachable


Successful response 

    HTTP/1.1 200 OK
    Access-Control-Allow-Methods: *
    Access-Control-Allow-Origin: *
    Connection: Keep-Alive
    Content-Length: 4
    Content-Type: application/json
    Date: Wed, 06 Jan 2016 08:26:19 GMT
    Keep-Alive: timeout=5, max=100
    Server: Apache
    X-Powered-By: PHP/5.6.10
    
    "{}"

### How is the app configured ? ###

    http -v GET ${BASE_URL}infos 

## 3- Test of commons services ## 

### Try to create a user (ACL may block the creation) ###

    echo '{"user": {"email": "bpds@me.com", "password":"xxx", "dID":"0000"}}' | http -v -f POST ${BASE_URL}user

If you are blocked you can temporarly add a permissive rule into your configuration 

    'CreateUser->call'=>array('level' =>PERMISSION_NO_RESTRICTION)
    
### 4 - Test the existence of en entity

```shell
http GET ${BASE_URL}exists/<replace by the UID>/in/<replace by the spaceUID>
```#BMS#->{"filename":"default.flx","checksum":3402420805,"relativePath":"BartlebyFlexions\/default.flx","size":1168}<-#BME#
# Created by Benoit Pereira da Silva on 20/04/2013.
# Copyright (c) 2013  http://www.chaosmos.fr
#
# This file is part of Flexions
#
# Flexions is free software: you can redistribute it and/or modify
# it under the terms of the GNU LESSER GENERAL PUBLIC LICENSE as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Flexions is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU LESSER GENERAL PUBLIC LICENSE for more details.
#
# You should have received a copy of the GNU LESSER GENERAL PUBLIC LICENSE
# along with Flexions  If not, see <http://www.gnu.org/license

#This file defies default flexions variables
# you can override those values in your generation shell script.

# Templates list
templates="*"

# Preprocessors list
pre="pre-processor.php"

# Postprocessors list
post="post-processor.php"

# the destination folder
destination="${flexionsFolder}out/"

# the optional web url to invoke from a browser 
webaseUrl="http://flexions.local/flexions.php?"#BMS#->{"filename":"flexions.flx","checksum":825845364,"relativePath":"BartlebyFlexions\/flexions.flx","size":1932}<-#BME#
# Created by Benoit Pereira da Silva on 20/04/2013.
# Copyright (c) 2013  http://www.chaosmos.fr
#
# This file is part of Flexions
#
# Flexions is free software: you can redistribute it and/or modify
# it under the terms of the GNU LESSER GENERAL PUBLIC LICENSE as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Flexions is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU LESSER GENERAL PUBLIC LICENSE for more details.
#
# You should have received a copy of the GNU LESSER GENERAL PUBLIC LICENSE
# along with Flexions  If not, see <http://www.gnu.org/license

# This file must should be called  from a generate.sh script file
# That define the required variables 
# @ Todo 
# ->Check the variable are sets.
# ->Test  source and destination are valid 


########################
# Path definition
########################

# the relative path to flexions.php
cmdPath="${flexionsFolder}src/flexions.php"

# the source folder
source="./"

########################
# Command feed back 
########################

echo \# invoking :
echo php  -f ${cmdPath}flexions.php source=${source} destination=${destination} descriptor=${descriptor} templates=${templates}  preProcessors=${pre} postProcessors=${post}
echo 
echo \# You could alternatively invoke Flexion in you browser by setting the document root to Flexions/src folder
echo ${webpdsaseUrl}source=$(pwd)/\&destination=$(pwd)/${destination}\&descriptor=${descriptor}\&templates=${templates}\&preProcessors=${pre}\&postProcessors=${post}
echo 

########################
# Invoke the command
########################

php  -f ${cmdPath} source=${source} destination=${destination} descriptor=${descriptor} templates=${templates}  preProcessors=${pre} postProcessors=${post}#BMS#->{"filename":"README.md","checksum":245709557,"relativePath":"BartlebyFlexions\/README.md","size":3000}<-#BME#
# Bartleby's Flexions 

Flexions is a simple set of scripts (written in basic PHP) to perform code generation.
Flexions intents to be an easy to use code generator.
The simpliest way to understand how it works is to check our samples in the samples folder.  

Current version is 2.0.


## Flexions life cycle

The flexions.script /src/flexions/Core/flexions.script.php Interprets and validates the command line and then runs through 3 phases : pre-processing / processing / post-processing

### 1- pre-processing : ( you can have multiple pre-processors )
1. can proceed to preparation (pre-generation, data set building per introspection, etc....)
2. loads the "descriptor" and transform them to an Hypotypose instance

#### We create aliases to be used in the templates :
- $h refers to the singleton Hypotypose::instance()
- $d refers whithin the loop to the current focus for example : $d=$actions[19] if the loop runs on the 19th actions.
- $f refers to the current Flexed instance

### 2- processing (usually a triple loop)  :
1. Per entity loop (entity ) enumerates { $entities }
2. Action loop (operations, command) enumerates { $actions }
3. One stop loop (api , http client , shared headers) runs once  per $project

IMPORTANT if the package contains a loops.php file the standard flexion loop is not used.

### 3- post-processing : (you can have multiple post-processors)
Each loop store a collection of Flexed instances  
1. Can use the "Flexed" instances to generate sub-Flexed (for example an header file for all the generated files)
2. Serializes the "Flexed" to sources files to the destination.
3. Perform any other post processing action (notification, push, ....)

## Usage of the Php command line : 
  
```shell
php  -f ${cmdPath} source=${source} destination=${destination} descriptor=${descriptor} templates=${templates}  preProcessors=${pre} postProcessors=${post}
```
### But most of the time you will prefer to create a .sh wrapper 

- source:the generation source folder path
- descriptor:the descriptor file name
- templates:templates relative path separated by commas for advanced cibled generation OR  "* " for recursive generation  for simple hierarchies (default value =="*")
- destination:destination path (default value is =="out/standard/")
- preProcessors:the pre-processors separated by commas
- postProcessors:the post-processors separated by commas


## About templates

To determinate if a template should be used in a loop we check if there is an occurence of the loopname in the path.
To include a template in the "project" loop put it in : templates/project/myTemplate.php


### Prototypes Template

Sample of a prototype template.

```php
include FLEXIONS_SOURCE_DIR.'/Shared.php';
// Define the globals before calling include
$filemame="/LoginUser.swift";
$package="xOS/operations/";
$prototypePath=FLEXIONS_MODULES_DIR.'Bartleby/prototypes/swift/auth/LoginUser.swift';
include FLEXIONS_MODULES_DIR . 'Bartleby/templates/filePrototypeTemplate.php';
```



#BMS#->{"filename":"Enum.php","checksum":3469402293,"relativePath":"BartlebyFlexions\/src\/flexions\/core\/Enum.php","size":426}<-#BME#
<?php

/**
 * Created by PhpStorm.
 * User: bpds
 * Date: 23/07/2015
 * Time: 17:32
 */
abstract class Enum {

    /**
     * @return array
     */
    static  function possibleValues(){
        return array();
    }

    /**
     * @return true if the value is a member of the Enum
     */
     final function isValid($value){
        $a=$this->possibleValues();
         $r=in_array($value,$a);
         return $r;
    }

}#BMS#->{"filename":"Flexed.php","checksum":1821625696,"relativePath":"BartlebyFlexions\/src\/flexions\/core\/Flexed.php","size":2047}<-#BME#
<?php

/*

Created by Benoit Pereira da Silva on 20/04/2013.
Copyright (c) 2013  http://www.chaosmos.fr

This file is part of Flexions

Flexions is free software: you can redistribute it and/or modify
it under the terms of the GNU LESSER GENERAL PUBLIC LICENSE as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Flexions is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU LESSER GENERAL PUBLIC LICENSE for more details.

You should have received a copy of the GNU LESSER GENERAL PUBLIC LICENSE
along with Flexions  If not, see <http://www.gnu.org/Licenses/>

*/

/**
 * @author bpds
 */
class Flexed {

	// Defines if a file is included or not
	const MIN_SOURCE_SIZE=2;


	/**
	 * Populated by the template
	 * @var string
	 */
	var $package;
	
	/**
	 * Populated by the template
	 * @var string
	 */
	var $fileName=NULL;
	
	
	/**
	 * Generated source
	 * @var string
	 */
	var $source='';

	
	/**
	 * @var string
	 */
	var $packagePath=NULL ;
	

	/**
	 * @var string
	 */
	var $description;
	
	/**
	 * @var array
	 */
	var $metadata=array();

	

	/**
	 * You can mark a flexed to be excluded.
	 * @var boolean
	 */
	var $exclude=false;
	
	
	
	// ######################


	/**
	 * Can be used to prefix a class for example
	 * @var string
	 */
	var $prefix="";

	/**
	 * 
	 * @var string
	 */
	var $projectName="PROJECT NAME";
	
	/**
	 * 
	 * @var string
	 */
	var $company="COMPANY";
	
	/**
	 * 
	 * @var string
	 */
	var $year="2015";
	
	 /**
	  * 
	  * @var string
	  */
	var $author="flexions@chaosmos.fr";
	
	
	/**
	 * @var string
	 */
	var $license;

	

	/**
	 * Flexed constructor.
	 */
	public function __construct($prefix='') {
		$this->prefix=$prefix;
	}


	public function fileNameIsIn(array $array){
		foreach ($array as $element){
			if (!(strpos($this->fileName, $element)===false)){
				return true;
			}
		}
		return false;
	}


}

?>#BMS#->{"filename":"flexions.script.php","checksum":4262410111,"relativePath":"BartlebyFlexions\/src\/flexions\/core\/flexions.script.php","size":8798}<-#BME#
<?php
/*

Created by Benoit Pereira da Silva on 20/04/2013.
Copyright (c) 2013  http://www.chaosmos.fr

This file is part of Flexions

Flexions is free software: you can redistribute it and/or modify
it under the terms of the GNU LESSER GENERAL PUBLIC LICENSE as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Flexions is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU LESSER GENERAL PUBLIC LICENSE for more details.

You should have received a copy of the GNU LESSER GENERAL PUBLIC LICENSE
along with Flexions  If not, see <http://www.gnu.org/Licenses/>

*/

require_once FLEXIONS_ROOT_DIR . 'flexions/Core/Flog.php';
require_once FLEXIONS_ROOT_DIR . 'flexions/Core/Hypotypose.php';
require_once FLEXIONS_ROOT_DIR . 'flexions/Core/Flexed.php';
require_once FLEXIONS_ROOT_DIR.  'flexions/Core/functions.script.php';
require_once FLEXIONS_ROOT_DIR.  'flexions/representations/flexions/FlexionsRepresentationsIncludes.php';

error_reporting(E_ALL | E_STRICT);
date_default_timezone_set ( 'UTC' );

// The argument can also be defined from a boot php script
if (! isset($arguments)) {
	// Server & commandline versatile support
	if ($_SERVER ['argc'] == 0 || !defined('STDIN')) {
		// Server mode
		$arguments = $_GET;
		define("COMMANDLINE_MODE", false);
	} else {
		// Command line mode
		$rawArgs = $_SERVER ['argv'];
		array_shift($rawArgs); // shifts the commandline script file flexions.php
		$arguments = array();
		parse_str(implode('&', $rawArgs), $arguments);
		define("COMMANDLINE_MODE", true);
	}
}

// We instanciate the Flog singleton
// and store a time stamp as  first log.
Flog::Instance ()->addMessage ( '##' . fDate () . '##' . cr() );
                                        
$preProcessors = '';
$postProcessors = '';
$source = '';
$descriptorFilePath='';
$destination='';
if (isset ( $arguments ["source"] )) {
	$source = $arguments ["source"];
} else {
	 throw new Exception ( 'Required parameter "source"' . cr() );
}

define ( "FLEXIONS_SOURCE_DIR", $source );

if (isset ( $arguments ["descriptor"] )) {
	if(file_exists($arguments["descriptor"])){
		// We use an absolute path
		$descriptorFilePath=$arguments["descriptor"];
	}else{
		// we use a relative path
		$descriptorFilePath = FLEXIONS_SOURCE_DIR  . $arguments ["descriptor"];
	}
}



if (isset ( $arguments ["templates"] ) && strlen ( $arguments ["templates"] ) >= 1) {
	$templates = $arguments ["templates"];
} else {
	$templates = '*';
}

if (isset ( $arguments ["destination"] ) && strlen ( $arguments ["destination"] ) >= 1) {
	$destination = injectVersionInPath($arguments ["destination"]);
} else {
	$destination = injectVersionInPath(FLEXIONS_ROOT_DIR . '/out/standard/');
	if(file_exists($destination)==false)
		mkdir ( $destination, 0777, true );
}

if (isset ( $arguments ["preProcessors"] ))
	$preProcessors = $arguments ["preProcessors"];

if (isset ( $arguments ["postProcessors"] ))
	$postProcessors = $arguments ["postProcessors"];
	
	// Check if mandatory $arguments are set
	// (Preprocessors and PostProcessors are optionnal)

if (! isset ( $descriptorFilePath )) {
	 throw new Exception( 'Required parameter "descriptor"' . cr() );
}


$baseTemplatePath = FLEXIONS_SOURCE_DIR . 'templates';
// Templates joker.
if ($templates == "*") {
	// We populate the templates with the relative path
	$templatesArray = directoryToArray ( $baseTemplatePath );
	$templates = implode ( ',', $templatesArray );
}else{
	$templatesTempArray= explode(',', $templates);
	$templatesArray=array();
	foreach ( $templatesTempArray as $templatePath ) {
		// Compute the absolute path
		$templatesArray[]=$baseTemplatePath."/".$templatePath;;
	}
}


$specificLoops = FLEXIONS_SOURCE_DIR . 'loops.php';

$m = cr();
$m.=  '# phpversion : '.phpversion().cr();
$m .= '# Invoking flexions  for ' .simplifyPath($descriptorFilePath) . cr();
$m .= '# On template(s): ' . str_replace ( FLEXIONS_SOURCE_DIR . 'templates/', '', $templates ) . cr();
$m .= '# With destination: ' . simplifyPath($destination) . cr();
$m .= '# Using pre-processor: ' . $preProcessors . cr();
$m .= '# And post-processor: ' . $postProcessors . cr();
if (file_exists ( $specificLoops )) {
	$m .= '# Using the loops : ' . $source . '/loops.php' . cr() . cr();
}else{
	$m .=  '# Using the standard loops' . cr() . cr() ;
}
$m .='FLEXIONS_SOURCE_DIR='. FLEXIONS_SOURCE_DIR.cr();
$m .='FLEXIONS_ROOT_DIR='. FLEXIONS_ROOT_DIR;
fLog ( $m, true );

// /////////////////////////////////
// PHASE #1
// PREPROCESSING
// /////////////////////////////////

fLog ( cr().cr().'##'.cr(), true );
fLog ( 'Pre Processing'.cr(), true );
fLog ( '##'.cr().cr(),true );


$arrayOfPreProcessors = explode ( ",", $preProcessors );
foreach ( $arrayOfPreProcessors as $preProcessor ) {
	// Invokes the pre-processor
	$preProcessorPath = FLEXIONS_SOURCE_DIR . $preProcessor;
    fLog ( cr().'Running:'.$preProcessorPath.cr().cr(),true );
	try {
		include $preProcessorPath;
	}catch (Exception $e) {
		fLog('PREPROCESSOR EXCEPTION ' . $e->getMessage(),true);
        dumpLogs();
		return;
	}
}
	
// //////////////////////////////////
// PHASE #2
// PROCESSING
// /////////////////////////////////

/**
 *
 * @var $h Hypotypose
 *     
 */

$destination=$destination.$h->majorVersionPathSegmentString().$h->stagePathSegmentString();
$h=Hypotypose::Instance();
$h->exportFolderPath=$destination;

fLog ( cr().cr().'##'.cr(), true );
fLog ( 'Looping'.cr(), true );
fLog ( '##'.cr().cr(), true );

if (file_exists ( $specificLoops )) {
	// We use the specific loops
	include $specificLoops;
} else {
	
	while ( $h->nextLoop () == true ) {
		$list = $h->getContentForCurrentLoop (); // Returns the current loop items
		fLog ( 'Looping in '.$h->getLoopName().cr(), true );

		foreach ( $list as $descriptions ) {


            try {// It is a description object
                iterateOnTemplates($templatesArray, $h, $descriptions, $destination);
            } catch (Exception $e) {
                fLog('TEMPLATE EXCEPTION ' . $e->getMessage(),true);
                dumpLogs();
                return;
            }
		}
	}
}

/**
 * 
 * @param array $templatePath
 * @param Hypotypose $h
 * @param mixed $d the descriptor (a set of data)
 * @throws Exception
 */
 function iterateOnTemplates(array $templatesArray, Hypotypose $h,  $d,$destination){
 	
	foreach ( $templatesArray as $templatePath ) {
			
		// We need to determine if the template should be used in
		// this loop.
        $loopName=$h->getLoopName ();
		$componentsOfTemplatePath=explode('/',strtolower($templatePath));

        $shouldBeUsedInThisLoop = in_array(strtolower($loopName),$componentsOfTemplatePath);
			
		if ($shouldBeUsedInThisLoop) {
	
			$result = NULL;
			if (! isset ( $d )) {
				throw new Exception( 'Descriptor variable $d must be set for the templates. Your preprocessor should have populated an iterable list of data for the descriptor for the loop : '.$loopName );
			}

			// We instanciate the current Flexed
			// will be used by the templates to define $f->fileName, $f->package
			$f = new Flexed ($h->classPrefix);

			// ( ! ) Template execution
			ob_start ();include $templatePath;$result = ob_get_clean ();
			// (!) End of template execution
	
			if ($f->fileName != null ) {
					
				$f->source = $result; // We store the generation result
				//and the package path
				$f->packagePath = $destination . $f->package;
				 
				// We add the flexed the Hypotypose for the post processors
				$h-> addFlexed($f);
                fLog ( '+Adding '.$f->fileName.cr(), true );
			} else {
				fWarning ( 'fileName or package is not defined in ' . $templatePath );
			}
		}
	}
}


// //////////////////////////////////
// PHASE #3
// POST PROCESSING
// ///////////////////////////////////

fLog ( cr().cr().'##'.cr(), true );
fLog ( 'Post Processing'.cr(), true );
fLog ( '##'.cr().cr(),true );
$arrayOfPostProcessors = explode ( ",", $postProcessors );
foreach ( $arrayOfPostProcessors as $postProcessor ) {
	// Invokes the post-processor
	$postProcessorPath = FLEXIONS_SOURCE_DIR  . $postProcessor;
    fLog ( cr().'Running:'.$postProcessorPath.cr().cr(),true );
    try {
        include $postProcessorPath;
    }catch (Exception $e) {
        fLog('POSTPROCESSOR EXCEPTION ' . $e->getMessage(),true);
        dumpLogs();
        return;
    }
}
dumpLogs();



function dumpLogs(){
    // Dump Flog

    $logFolderPath = FLEXIONS_ROOT_DIR . '../out/logs/';
    if(! file_exists($logFolderPath)){
        mkdir ( $logFolderPath, 0777, true );
    }
    $logsFilePath = $logFolderPath . fDate () . '-logs.txt';
    file_put_contents ( $logsFilePath, Flog::Instance ()->getLogs () );
}#BMS#->{"filename":"Flog.php","checksum":4109505728,"relativePath":"BartlebyFlexions\/src\/flexions\/core\/Flog.php","size":476}<-#BME#
<?php

class Flog {
	/**
	 * Call this method to get singleton
	 *
	 * @return Flog
	 */
	public static function Instance() {
		static $inst = null;
		if ($inst === null) {
			$inst = new Flog();
		}
		return $inst;
	}
	
	/**
	 * @var string
	 */
	private $_logs='';
	
	/**
	 * @return string the $_logs
	 */
	public function getLogs() {
		return $this->_logs;
	}

	/**
	 * @param string $message
	 */
	public function addMessage($message='') {
		$this->_logs.=$message;
	}

}#BMS#->{"filename":"functions.script.php","checksum":1606106354,"relativePath":"BartlebyFlexions\/src\/flexions\/core\/functions.script.php","size":3919}<-#BME#
<?php

require_once FLEXIONS_ROOT_DIR . 'flexions/Core/Flog.php';
require_once FLEXIONS_ROOT_DIR . 'flexions/Core/Hypotypose.php';
require_once FLEXIONS_ROOT_DIR . 'flexions/Core/Flexed.php';


////////////////////////////////////
// FUNCTIONS
/////////////////////////////////////


/**
 * @param string  $dir
 * @param array $result
 * @return array  of path
 */
function directoryToArray($dir, &$result = array()) {
	$dirList = scandir ( $dir );
	foreach ( $dirList as $key => $value ) {
		$dotPos = strpos ( $value, '.' );
		if (($dotPos === false) or ($dotPos != 0)) {
			if (is_dir ( $dir . DIRECTORY_SEPARATOR . $value )) {
				$sub = directoryToArray ( $dir . DIRECTORY_SEPARATOR . $value );
				$result = array_merge ( $result, $sub );
			} else {
				$result [] = $dir . DIRECTORY_SEPARATOR . $value;
			}
		}
	}
	return $result;
}

function fLog($message, $show=false){
	Flog::Instance()->addMessage($message);
	if($show || ECHO_LOGS===true){
		echo $message;
	}
}

/**
 *  Contextual Carriage return
 * @return string
 */
function cr(){
	return COMMANDLINE_MODE?"\n":"</br>";
}

/**
 * 
 * @param int $n
 * @return string
 */
function tabs($n=1){
	$s="";
	for ($i = 0; $i < $n; $i++) {
		$s.=chr(9);
	}
	return $s;
}


/**
 * 
 * @param string $string
 * @param int $n
 */
function echoIndent($string,$n=1){
	 echo (stringIndent($string,$n));
}

function stringIndent($string,$n=1){
    if ($string==''){
        return tabs($n).$string;
    }
	$newString='';
	$lines=explode("\n",$string);
    $counter=0;
    $nbLines=count($lines);
	foreach ($lines as $line) {
        if($line!==''){
            $newString .= tabs($n).$line;
            if($counter>0){
                $newString .= cr();
            }
        }
        $counter++;
	}
	return $newString;
}

function echoIndentCR($string,$n=1){
    echo (stringIndent($string,$n).cr());
}

function stringIndentCR($string,$n=1){
    return stringIndent($string,$n).cr();
}


/**
 * Logs a warning
 * @param string $warning
 */
function fWarning( $warning){
	fLog('WARNING : '.$warning,false);
}

function fDate(){
	$dt = new DateTime();
	return $dt->format('Y-m-d-').microtime(true);
}


function hypotyposeToFiles() {
	$h=Hypotypose::Instance();

	// Delete the export path.
	@rmdir($h->exportFolderPath);

	$history=array();
	foreach ( $h->flexedList as $loopname=>$list ) {
		/* @var $list array */
		foreach ( $list as  $f ) {
			$path=$f->packagePath . $f->fileName;
			// We put to file once only per destination
			if(in_array($path, $history)==false){

				$shouldBeExcluded=false;
				foreach ($h->excludePath as $pathToExclude ) {
					if(strpos($path,$pathToExclude)!==false){
						$shouldBeExcluded=true;
					}
				}
				if($shouldBeExcluded==true){
					continue;
				}

				/* @var $f Flexed */
				file_put_Flexed ( $f );
				$history[]=$path;
			}
		}
	}
	if (VERBOSE_FLEXIONS)
		fLog("\nSerializing hypotypose to ".count($history)." file(s)"." with loop name == ".$loopname.cr(),true);
}

function file_put_Flexed(Flexed $f){
	if ( isset($f->source) && strlen($f->source) > Flexed::MIN_SOURCE_SIZE ){
		// Create the package folder if necessary
		if (! file_exists ( $f->packagePath )) {
			if (VERBOSE_FLEXIONS)
				fLog("-> creating package " .  $f->package . cr(),true);
			mkdir ( $f->packagePath, 0777,true );
		}
		// Save the generated file
		file_put_contents ( $f->packagePath . $f->fileName, $f->source );
		if (VERBOSE_FLEXIONS)
			fLog("Writing : ".$f->packagePath . $f->fileName.cr(),true);
	}else{
		// We can return NULL sources to exclude a file from generation
	}

}

/**
 * 
 * @param string $path
 * @return string
 */
function simplifyPath($path){
	$path=realpath($path);
	$path=str_replace(FLEXIONS_ROOT_DIR,"", $path);
	return $path;
}



function injectVersionInPath($path){
	$h=Hypotypose::Instance();
	$newPath= str_ireplace('{version.major}',$h->majorVersionPathSegmentString(),$path);
	return $newPath;
}
#BMS#->{"filename":"Hypotypose.php","checksum":2958261388,"relativePath":"BartlebyFlexions\/src\/flexions\/core\/Hypotypose.php","size":6573}<-#BME#
<?php

//  Created by Benoit Pereira da Silva on 20/04/2013.
//  Copyright (c) 2013  http://www.chaosmos.fr

// This file is part of Flexions

// Flexions is free software: you can redistribute it and/or modify
// it under the terms of the GNU LESSER GENERAL PUBLIC LICENSE as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// Flexions is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU LESSER GENERAL PUBLIC LICENSE for more details.

// You should have received a copy of the GNU LESSER GENERAL PUBLIC LICENSE
// along with Flexions  If not, see <http://www.gnu.org/Licenses/>


class DefaultLoops {
    const ENTITIES = 'entities'; // Generaly for generating models
    const ACTIONS = 'actions'; // For example for endpoints generations
    const PROJECT = 'project'; // For a glob
}

class DefaultStages{
    const NO_STAGE='';
    const STAGE_PRODUCTION='production';
    const STAGE_DEVELOPMENT='development';
    const STAGE_BETA='beta';

}

/**
 *  An hypotypose is a structured description that
 *  uses  agnostic data structure
 *
 *  An  hypotypose instance is persistent during all flexions phases
 *
 *  Preprocessing    :
 *  hypotypose is instanciated and populated from sources.
 *
 *  Processing        :
 *  hypotypose is used by the loops and passed to the templates.
 *  if the template returns some contents its content is stored in a Flexed instance
 *
 *  PostProcessing :
 *  hypotypose->flexedList(s) are iterated to generate the files from  $f->source
 *
 * @package   flexions
 * @author    benoit@chaosmos.fr
 * @version   1.0.0
 */
final class Hypotypose extends stdClass {
    

    /**
     * Excluded path are generated but not dumped
     * @var array
     */
    public $excludePath = array();


    /**
     * @var string the current global stage
     */
    public $stage = DefaultStages::NO_STAGE;



    public $version = '';// No version by default

    function majorVersionPathSegmentString(){
        $components=explode('.',$this->version);
        if (count($components)>0 && $components[0]!=''){
            return 'v'.$components[0].'/';
        }else{
            return '';
        }
    }

    function stagePathSegmentString(){
        if ($this->stage!=DefaultStages::NO_STAGE){
            return $this->stage.'/';
        }else{
            return '';
        }
    }


    function  majorVersionString(){
        $components=explode('.',$this->version);
        if (count($components)>0){
            return $components[0];
        }else{
            return '';
        }
    }

    /**
     *
     * @var array
     */
    protected $_descriptor = array();

    /**
     *
     * @var int
     */
    private $_loopIndex;

    /**
     *
     * @var array
     */
    protected $_loopNameList;


    /**
     * The list of the flexed files
     * @var array
     */
    public $flexedList = array();

    /**
     * class prefix
     * @var string
     */
    public $classPrefix = "";


    /**
     * @var string a facility to gain access to command line destination
     */
    public $exportFolderPath ='';


    /**
     * Call this method to get singleton
     *
     * @return Hypotypose
     */
    public static function Instance() {
        static $inst = NULL;
        if ($inst === NULL) {
            $inst = new Hypotypose ();
        }
        return $inst;
    }

    /**
     */
    function __construct( ) {
        $this->_loopIndex = -1;
        $this->_loopNameList = array();
    }

    /**
     * Returns the current loop name
     * @return string
     */
    public function getLoopName() {
        if ($this->_loopIndex >= 0) {
            return $this->_loopNameList [$this->_loopIndex];
        } else {
            return NULL;
        }
    }

    /**
     *
     * @return  array
     */
    public function getContentForCurrentLoop() {
        $name = $this->getLoopName();
        if ($name != NULL) {
            if (array_key_exists($name, $this->_descriptor)) {
                return $this->_descriptor[$name];
            }
        }
        return NULL;
    }

    /**
     *
     * @param string $name
     * @return array:|NULL
     */
    public function getContentForLoopWithName($name) {
        if (array_key_exists($name, $this->_descriptor)) {
            return $this->_descriptor[$name];
        }
        return NULL;
    }

    /**
     *
     * @return boolean
     */
    public function nextLoop() {
        $this->_loopIndex++;
        if ($this->_loopIndex < count($this->_loopNameList)) {
            return true;
        } else {
            $this->_loopIndex = -1;
            return false;
        }
    }

    /**
     * Sets the descriptor for a given loop name
     * this is done once per loop in the preprocessor
     *
     * @param array $descriptor
     * @param string $loopName
     * @return boolean
     */
    public function setLoopDescriptor($descriptor, $loopName) {
        if (!array_key_exists($loopName, $this->_loopNameList)) {
            // We add the descriptor
            $this->_loopNameList[] = $loopName;
            $this->_descriptor[$loopName] = $descriptor;
            $this->flexedList[$loopName] = array();
            $this->_descriptor[$loopName] = $descriptor;
            return true;
        }
        return false;
    }

    /**
     *
     * @param Flexed $flexed
     */
    public function  addFlexed(Flexed $flexed) {
        // Do not copy flexed files that are excluded or not
        if((strlen($flexed->source) > Flexed::MIN_SOURCE_SIZE )
            && ($flexed->fileNameIsIn($this->excludePath)===false)) {
            $this->flexedList [$this->getLoopName()] [] = $flexed;
        }
    }


    public function getFlatFlexedList() {
        $flatList = array();
        foreach ($this->flexedList as $subList) {
            if (is_array($subList)) {
                $flatList = array_merge($flatList, $subList);
            }
        }
        return $flatList;
    }


    public function removePrefixFromString($string){
        if(isset($this->classPrefix)&& $this->classPrefix!="" && strpos($string,$this->classPrefix)===0){
            return substr($string,strlen($this->classPrefix));
        }else{
            return $string;
        }

    }


    public function ucFirstRemovePrefixFromString($string){
        return ucfirst($this->removePrefixFromString($string));
    }


}
?>#BMS#->{"filename":"ActionRepresentation.php","checksum":4262232052,"relativePath":"BartlebyFlexions\/src\/flexions\/representations\/flexions\/ActionRepresentation.php","size":6906}<-#BME#
<?php

/*
 Created by Benoit Pereira da Silva on 20/04/2013.
Copyright (c) 2013  http://www.chaosmos.fr

This file is part of Flexions

Flexions is free software: you can redistribute it and/or modify
it under the terms of the GNU LESSER GENERAL PUBLIC LICENSE as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Flexions is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU LESSER GENERAL PUBLIC LICENSE for more details.

You should have received a copy of the GNU LESSER GENERAL PUBLIC LICENSE
along with Flexions  If not, see <http://www.gnu.org/Licenses/>
*/

class ActionRepresentation {

    /**
     * @var string Name of the Action
     */
    public $name;

    /**
     * @var string Class of the Action object
     */
    public $class;


    /* @var string the collection name if relevent*/
    public $collectionName;

    /**
     * @var array of PropertyRepresentation
     */
    public $parameters = array();

    /**
     * @var array  an associative array  of PropertyRepresentation per status
     * e.g:
     * { "200"=> PropertyRepresentation,"400"=> PropertyRepresentation }
     * or { "success" => PropertyRepresentation, "failure" => PropertyRepresentation }
     * for each errors that could occur when running the Action
     */
    public $responses = array();


    /**
     * The security context for the action.
     * @var SecurityContextRepresentation
     */
    public $security;


    ////////////////////
    // END POINTS ONLY
    ////////////////////

    /**
     * @var string
     */
    public $path;

    /**
     * @var string HTTP method
     */
    public $httpMethod;


    //////////////////
    // DESCRIPTION
    //////////////////


    /**
     * @var string This is a short summary of what the Action does
     */
    public $summary;

    /**
     * @var string A longer text field to explain the behavior of the operation.
     */
    public $notes;

    /**
     * @var string Information about the response returned by the Action
     */
    public $responseNotes;



    //////////////////
    // METADATA
    //////////////////


    /**
     * @var array an associative array to pass specific metadata (including urdMode)
     */
    public $metadata=array();


    /**
     * if set to true Actions could be URD ( Upsert Read Delete)
     * instead of CRUD (Create Read Update Delete)
     * @return boolean
     */
    public function usesUrdMode() {
        return array_key_exists(METADATA_KEY_FOR_USE_URD_MODE, $this->metadata ) ? $this->metadata[METADATA_KEY_FOR_USE_URD_MODE] : DEFAULT_USE_URD_MODE ;
    }
    

    //////////////////////////
    // PARAMETERS ITERATORS
    //////////////////////////


    /**
     * Current iteration parameter
     * @var int
     */
    protected $_parameterIndex = -1;


    /**
     * Return true while there is a parameter
     * @return boolean
     */
    public function iterateOnParameters() {
        $this->_parameterIndex++;
        if ($this->_parameterIndex < count($this->parameters)) {
            return true;
        } else {
            // Reinitialise
            $this->_parameterIndex = -1;
            return false;
        }
    }

    /**
     * Returns the current iterated parameter
     * @return PropertyRepresentation
     */
    public function getParameter() {
        $nb = count($this->parameters);
        if ($this->_parameterIndex < $nb && $nb > 0) {
            $keys = array_keys($this->parameters);
            return $this->parameters[$keys[$this->_parameterIndex]];
        }
        return null;
    }

    /**
     *
     * @return boolean
     */
    public function firstParameter() {
        return ($this->_parameterIndex == 0);
    }

    /**
     *
     * @return boolean
     */
    public function lastParameter() {
        return ($this->_parameterIndex == count($this->parameters) - 1);
    }

    //////////////////////////
    // RESPONSE ITERATORS
    //////////////////////////


    /**
     * Current iteration response
     * @var int
     */
    protected $_responseIndex = -1;


    /**
     * Return true while there is a response
     * @return boolean
     */
    public function iterateOnResponses() {
        $this->_responseIndex++;
        if ($this->_responseIndex < count($this->responses)) {
            return true;
        } else {
            // Reinitialise
            $this->_responseIndex = -1;
            return false;
        }
    }

    /**
     * Returns the current iterated response
     * @return PropertyRepresentation
     */
    public function getresponse() {
        $nb = count($this->responses);
        if ($this->_responseIndex < $nb && $nb > 0) {
            $keys = array_keys($this->responses);
            return $this->responses[$keys[$this->_responseIndex]];
        }
        return null;
    }

    /**
     *
     * @return boolean
     */
    public function firstResponse() {
        return ($this->_responseIndex == 0);
    }

    /**
     *
     * @return boolean
     */
    public function lastResponse() {
        return ($this->_responseIndex == count($this->responses) - 1);
    }

    //////////////////////////////////////
    // GENERATIVE FACILITY
    /////////////////////////////////////


    /**
     * Returns true if there are parameters out of the path
     *
     * e.g:$path="/user/{username}"
     * "parameters": [ { "name": "username",...}]
     * Would return false
     * @return bool
     */
    public function containsParametersOutOfPath(){
        preg_match_all('/{(.*?)}/', $this->path, $matches);
        $variablesInPath=$matches[1];
        /* @var $parameter PropertyRepresentation */
        foreach ($this->parameters as $parameter) {
            if (!in_array($parameter->name, $variablesInPath)){
                return true;
            }
        }
        return false;
    }

    public function parameterIsInPath($parameterName){
        preg_match_all('/{(.*?)}/', $this->path, $matches);
        $variablesInPath=$matches[1];
        return in_array($parameterName, $variablesInPath);
    }


    /**
     * @return PropertyRepresentation
     */
    public function getSuccessResponse(){
        /*@var $propertyInstance PropertyRepresentation */
        foreach ($this->responses as $key => $propertyInstance) {
            if( $propertyInstance->name=="200" ||
                $propertyInstance->name=="201" ||
                $propertyInstance->name=="202" ||
                $propertyInstance->name=="success"){
                return $propertyInstance;
            }
        }
        $default=new PropertyRepresentation();
        $default->name="default";
        $default->type=FlexionsTypes::VOID;
        return $default;
    }







}

?>#BMS#->{"filename":"EntityRepresentation.php","checksum":2676740919,"relativePath":"BartlebyFlexions\/src\/flexions\/representations\/flexions\/EntityRepresentation.php","size":4412}<-#BME#
<?php


/*
 Created by Benoit Pereira da Silva on 20/04/2013.
Copyright (c) 2013  http://www.chaosmos.fr

This file is part of Flexions

Flexions is free software: you can redistribute it and/or modify
it under the terms of the GNU LESSER GENERAL PUBLIC LICENSE as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Flexions is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU LESSER GENERAL PUBLIC LICENSE for more details.

You should have received a copy of the GNU LESSER GENERAL PUBLIC LICENSE
along with Flexions  If not, see <http://www.gnu.org/Licenses/>
*/



class EntityRepresentation {


    /**
     * @var string  Documentation  of the Entity
     */
    public $description;

    /**
     * @var string Name of the object
     */
    public $name;

    /**
     * @var array of PropertyRepresentation of the object
     */
    public $properties=array();


    /**
     * @var  string When the type is an object, you can specify the class that the object must implement
     */
    public $instanceOf;

    /**
     * @var array of interface names
     */
    public $implements=array();

    /**
     * Will be DEPRECATED but still used by XCDDataXMLToFlexionsRepresentation
     * @var bool
     */
    public $generateCollectionClass=DEFAULT_GENERATE_COLLECTION_CLASSES;



    //////////////////
    // METADATA
    //////////////////

    /**
     * @var array an associative array to pass specific metadata
     */
    public $metadata=array();


    /**** Collection & distribution ****/



    /**
     * if set to true Actions could be URD ( Upsert Read Delete)
     * instead of CRUD (Create Read Update Delete)
     * @return bool
     */
    public function usesUrdMode() {
        return array_key_exists(METADATA_KEY_FOR_USE_URD_MODE, $this->metadata ) ? $this->metadata[METADATA_KEY_FOR_USE_URD_MODE] : DEFAULT_USE_URD_MODE ;
    }

    /**
     * Can be used by undo managers
     * @return bool
     */
    public function isUndoable(){
        return array_key_exists(METADATA_KEY_FOR_IS_UNDOABLE, $this->metadata ) ? $this->metadata[METADATA_KEY_FOR_IS_UNDOABLE] : DEFAULT_IS_UNDOABLE ;
    }

    /**
     * @return bool
     */
    public function shouldPersistsLocallyOnlyInMemory() {
        return array_key_exists(METADATA_KEY_FOR_PERSISTS_LOCALLY_ONLY_IN_MEMORY, $this->metadata ) ? $this->metadata[METADATA_KEY_FOR_PERSISTS_LOCALLY_ONLY_IN_MEMORY] : DEFAULT_PERSISTS_LOCALLY_ONLY_IN_MEMORY ;
    }

    /**
     *
     * @return bool
     */
    public function groupedOnCommit() {
        return array_key_exists(METADATA_KEY_FOR_CAN_BE_GROUPED_ON_COMMIT, $this->metadata ) ? $this->metadata[METADATA_KEY_FOR_CAN_BE_GROUPED_ON_COMMIT] : DEFAULT_CAN_BE_GROUPED_ON_COMMIT ;
    }



    public function isDistantPersistencyOfCollectionAllowed() {
        return array_key_exists(METADATA_KEY_FOR_DISTANT_PERSISTENCY_IS_ALLOWED, $this->metadata ) ? $this->metadata[METADATA_KEY_FOR_DISTANT_PERSISTENCY_IS_ALLOWED] : DEFAULT_DISTANT_PERSISTENCY_IS_ALLOWED ;
    }

    //////////////////
    // ITERATORS
    //////////////////


    /**
     * Current iteration property
     * @var int
     */
    protected  $_propertyIndex=-1;


    /**
     * Return true while there is a property
     * @return boolean
     */
    public function iterateOnProperties(){
        $this->_propertyIndex++;
        if($this->_propertyIndex< count($this->properties)){
            return true;
        }else{
            // Reinitialise
            $this->_propertyIndex=-1;
            return  false;
        }
    }

    /**
     * Returns the current iterated property
     * @return PropertyRepresentation
     */
    public function getProperty(){
        $nb=count($this->properties);
        if($this->_propertyIndex<$nb && $nb>0 ){
            $keys  = array_keys( $this->properties);
            return $this->properties[$keys[$this->_propertyIndex]];
        }
        return null;
    }

    /**
     *
     * @return boolean
     */
    public function firstProperty(){
        return( $this->_propertyIndex==0);
    }
    /**
     *
     * @return boolean
     */
    public function lastProperty(){
        return ( $this->_propertyIndex== count($this->properties)-1);
    }

}

?>#BMS#->{"filename":"FlexionsRepresentationsIncludes.php","checksum":3615192653,"relativePath":"BartlebyFlexions\/src\/flexions\/representations\/flexions\/FlexionsRepresentationsIncludes.php","size":2288}<-#BME#
<?php

/*
 Created by Benoit Pereira da Silva on 20/04/2013.
Copyright (c) 2013  http://www.chaosmos.fr

This file is part of Flexions

Flexions is free software: you can redistribute it and/or modify
it under the terms of the GNU LESSER GENERAL PUBLIC LICENSE as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Flexions is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU LESSER GENERAL PUBLIC LICENSE for more details.

You should have received a copy of the GNU LESSER GENERAL PUBLIC LICENSE
along with Flexions  If not, see <http://www.gnu.org/Licenses/>
*/


if (!defined('DEFAULT_USE_URD_MODE')) {

    // METADATA
    // Keys
    define('METADATA_KEY_FOR_USE_URD_MODE','urdMode');
    define('METADATA_KEY_FOR_IS_UNDOABLE','undoable');
    define('METADATA_KEY_FOR_PERSISTS_LOCALLY_ONLY_IN_MEMORY','persistsLocallyOnlyInMemory');
    define('METADATA_KEY_FOR_DISTANT_PERSISTENCY_IS_ALLOWED','allowDistantPersistency');
    define('METADATA_KEY_FOR_CAN_BE_GROUPED_ON_COMMIT','groupable');
    
    // Default Values
    define('DEFAULT_USE_URD_MODE',false);
    define('DEFAULT_IS_UNDOABLE',true);
    define('DEFAULT_PERSISTS_LOCALLY_ONLY_IN_MEMORY',false);
    define('DEFAULT_CAN_BE_GROUPED_ON_COMMIT',true);
    define('DEFAULT_DISTANT_PERSISTENCY_IS_ALLOWED',true);


    // Will be DEPRECATED but still used by XCDDataXMLToFlexionsRepresentation
    define('DEFAULT_GENERATE_COLLECTION_CLASSES',false);

}

require_once FLEXIONS_ROOT_DIR . 'flexions/representations/flexions/ProjectRepresentation.php';
require_once FLEXIONS_ROOT_DIR . 'flexions/representations/flexions/ActionRepresentation.php';
require_once FLEXIONS_ROOT_DIR . 'flexions/representations/flexions/EntityRepresentation.php';
require_once FLEXIONS_ROOT_DIR . 'flexions/representations/flexions/PropertyRepresentation.php';
require_once FLEXIONS_ROOT_DIR . 'flexions/representations/flexions/SecurityContextRepresentation.php';
require_once FLEXIONS_ROOT_DIR . 'flexions/representations/flexions/PermissionRepresentation.php';
require_once FLEXIONS_ROOT_DIR . 'flexions/representations/flexions/FlexionsTypes.php';#BMS#->{"filename":"FlexionsTypes.php","checksum":2084329154,"relativePath":"BartlebyFlexions\/src\/flexions\/representations\/flexions\/FlexionsTypes.php","size":1571}<-#BME#
<?php


require_once FLEXIONS_ROOT_DIR.'flexions/Core/Enum.php';

/**
 * Class FlexionsTypes
 * Enumerates the "primitive" type of Flexions as const
 */
class FlexionsTypes extends Enum {
    // Basic types
    const STRING='string';
    const INTEGER='integer';
    const BOOLEAN='boolean';
    const FLOAT='float';
    const DOUBLE='double';
    //
    const BYTE='byte';
    const DATETIME='dateTime';
    const URL='url';
    const DATA='data';

    const FILE='file';

    // Generic structure
    const DICTIONARY='dictionary';
    //
    const OBJECT='object'; // Used to reference an $instanceOf
    const COLLECTION='collection';// Used to reference a collection of $instanceOf that can be any FlexionsType
    const ENUM='enum';// Used to reference a enumeration of $instanceOf that can be any FlexionsType
    //
    const NOT_SUPPORTED='Not_Supported';

    const VOID='void';

    /**
     * @return array
     */
    static  function possibleValues(){
        return array(
            FlexionsTypes::STRING,
            FlexionsTypes::INTEGER,
            FlexionsTypes::BOOLEAN,
            FlexionsTypes::FLOAT,
            FlexionsTypes::DOUBLE,
            FlexionsTypes::BYTE,
            FlexionsTypes::DATETIME,
            FlexionsTypes::URL,
            FlexionsTypes::FILE,
            FlexionsTypes::DICTIONARY,
            FlexionsTypes::OBJECT,
            FlexionsTypes::COLLECTION,
            FlexionsTypes::ENUM,
            FlexionsTypes::NOT_SUPPORTED,
            FlexionsTypes::VOID,
            FlexionsTypes::DATA
        );
    }
}#BMS#->{"filename":"IFlexionsLanguageMapping.php","checksum":4128488904,"relativePath":"BartlebyFlexions\/src\/flexions\/representations\/flexions\/IFlexionsLanguageMapping.php","size":179}<-#BME#
<?php

interface IFlexionsLanguageMapping{

    /**
     * @param  $flexionsType
     * @return String the native type
     */
    static function nativeTypeFor($flexionsType);

}#BMS#->{"filename":"PermissionRepresentation.php","checksum":2159840485,"relativePath":"BartlebyFlexions\/src\/flexions\/representations\/flexions\/PermissionRepresentation.php","size":3520}<-#BME#
<?php

/**
 * Created by PhpStorm.
 * User: bpds
 * Date: 23/07/2015
 * Time: 12:14
 */

require_once FLEXIONS_ROOT_DIR.'flexions/Core/Enum.php';

class PermissionType extends Enum{

    const API_KEY='api_key';
    const OAUTH_2="OAUTH_2";

    static  function possibleValues(){
        return array(
            PermissionType::API_KEY,
            PermissionType::OAUTH_2
        );
    }
}



class PermissionLocation extends Enum{

    const UNDEFINED='undefined';
    const IN_HEADERS='in_headers';
    const IN_PARAMETERS='in_parameters';

    static  function possibleValues(){
        return array(
            PermissionLocation::IN_HEADERS,
            PermissionLocation::IN_PARAMETERS
        );
    }
}


class PermissionRepresentation {

    const DEFAULT_PERMISSION_NAME="identification";

    /**
     * @var String the name of the permission.
     */
    public $permission_name=PermissionRepresentation::DEFAULT_PERMISSION_NAME;


    /* @var string in PermissionLocation */
    private $_location=PermissionLocation::UNDEFINED;

    /**
     * @return string
     */
    public function getLocation() {
        return $this->_location;
    }

    /**
     * @param string $location
     */
    public function setLocation($location) {
        $p=new PermissionLocation();
        if($p->isValid($location)){
            $this->_location = $location;
        }else{
            throw new exception("invalid PermissionLocation ".$location);
        }
    }



    /**
     * @return String
     */
    public function getPermissionName() {
        return $this->permission_name;
    }

    /**
     * @param String $permission_name
     */
    public function setPermissionName($permission_name) {
        $this->permission_name = $permission_name;
    }



}


class PermissionRepresentationWithAccessRights extends PermissionRepresentation{

    /**
     * Inspired by UNIX files systems permissions.
     * https://en.wikipedia.org/wiki/File_system_permissions
     * @var int according to posix file systems permissions
     */
     private $_access_rights=777;

    /**
     * @return int
     */
    public function getAccessRights() {
        return $this->_access_rights;
    }

    /**
     * @param int $access_rights
     */
    public function setAccessRights($access_rights) {
        $this->_access_rights = $access_rights;
    }

    /**
     * @return string in PermissionType
     */
    public function getPermissionType(){
        return PermissionType::API_KEY;
    }

}



class PermissionRepresentationOauth extends PermissionRepresentation {




    /**
     * Scopes let you specify exactly what type of access you need.
     * Scopes limit access for OAuth tokens.
     *
     * e.g :
     *
     *  "user:email"=>"access to the user mail",
     *  "repo:status"=>"grants read/write access to public and private repository "
     *
     * @var array
     */
    private $_scopes=array();

    public  $authorizationUrl;

    /**
     * PermissionRepresentationOauth constructor.
     */
    public function __construct() {
        $this->setLocation(PermissionLocation::IN_HEADERS);
    }


    /**
     * @return array
     */
    public function getScopes() {
        return $this->_scopes;
    }

    /**
     * @param array $scope
     */
    public function addScope(Array $scope) {
        $this->_scopes[]=$scope;
    }



    /**
     * @return string in PermissionType
     */
    public function getPermissionType(){
        return PermissionType::OAUTH_2;
    }

}#BMS#->{"filename":"ProjectRepresentation.php","checksum":1727883422,"relativePath":"BartlebyFlexions\/src\/flexions\/representations\/flexions\/ProjectRepresentation.php","size":3867}<-#BME#
<?php

/*
 Created by Benoit Pereira da Silva on 20/04/2013.
Copyright (c) 2013  http://www.chaosmos.fr

This file is part of Flexions

Flexions is free software: you can redistribute it and/or modify
it under the terms of the GNU LESSER GENERAL PUBLIC LICENSE as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Flexions is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU LESSER GENERAL PUBLIC LICENSE for more details.

You should have received a copy of the GNU LESSER GENERAL PUBLIC LICENSE
along with Flexions  If not, see <http://www.gnu.org/Licenses/>
*/

class ProjectRepresentation {

    /**
     * @var array Array of ActionRepresentation
     */
    public $actions = array();

    /**
     * @var array Array of API entities (models)
     */
    public $entities = array();

    /**
     * @var array Any extra API data
     */
    public $extraData = array();


    /**
     * @var string Name of the API
     */
    public $name;

    /**
     * @var string API version
     */
    public $apiVersion;

    /**
     * @var string Summary of the API
     */
    public $description;

    /**
     * @var string baseUrl/basePath
     */
    public $baseUrl;


    /**
     *  Project wide class prefix
     * @var string
     */
    public $classPrefix = "";


    /**
     * @var array an associative array to pass specific metadata
     */
    public $metadata=array();


    // Actions


    /**
     * Current iteration action index
     * @var int
     */
    protected $_actionIndex = -1;

    /**
     * Return true while there is an action
     * @return boolean
     */
    public function iterateOnActions() {
        $this->_actionIndex++;
        if ($this->_actionIndex < count($this->actions)) {
            return true;
        } else {
            // Reinitialize
            $this->_actionIndex = -1;
            return false;
        }
    }

    /**
     * Returns the current iterated action
     * @return ActionRepresentation
     */
    public function getAction() {
        $nb = count($this->actions);
        if ($this->_actionIndex < $nb && $nb > 0) {
            $keys = array_keys($this->actions);
            return $this->actions[$keys[$this->_actionIndex]];
        }
        return null;
    }


    /**
     *
     * @return boolean
     */
    public function firstAction(){
        return( $this->_actionIndex==0);
    }
    /**
     *
     * @return boolean
     */
    public function lastAction(){
        return ( $this->_actionIndex== count($this->actions)-1);
    }



    // Entities

    /**
     * Current iteration action index
     * @var int
     */
    protected $_entityIndex = -1;

    /**
     * Return true while there is an entity
     * @return boolean
     */
    public function iterateOnEntities() {
        $this->_entityIndex++;
        if ($this->_entityIndex < count($this->entities)) {
            return true;
        } else {
            // Reinitialise
            $this->_entityIndex = -1;
            return false;
        }
    }

    /**
     * Returns the current iterated entity
     * @return EntityRepresentation
     */
    public function getEntity() {
        $nb = count($this->entities);
        if ($this->_entityIndex < $nb && $nb > 0) {
            $keys = array_keys($this->entities);
            return $this->entities[$keys[$this->_entityIndex]];
        }
        return null;
    }

    /**
     *
     * @return boolean
     */
    public function firstEntity(){
        return( $this->_entityIndex==0);
    }
    /**
     *
     * @return boolean
     */
    public function lastEntity(){
        return ( $this->_entityIndex== count($this->entities)-1);
    }



}

?>#BMS#->{"filename":"PropertyRepresentation.php","checksum":4232840327,"relativePath":"BartlebyFlexions\/src\/flexions\/representations\/flexions\/PropertyRepresentation.php","size":3413}<-#BME#
<?php

/*
 Created by Benoit Pereira da Silva on 20/04/2013.
Copyright (c) 2013  http://www.chaosmos.fr

This file is part of Flexions

Flexions is free software: you can redistribute it and/or modify
it under the terms of the GNU LESSER GENERAL PUBLIC LICENSE as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Flexions is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU LESSER GENERAL PUBLIC LICENSE for more details.

You should have received a copy of the GNU LESSER GENERAL PUBLIC LICENSE
along with Flexions  If not, see <http://www.gnu.org/Licenses/>
*/

class  PropertyRepresentation {

    /**
     * @var string unique Name of the property
     */
    public $name=NULL;

    /**
     * @var string  Documentation  of the property
     */
    public $description=NULL;

    /**
     * @var string Type  const enumerated in FlexTypes
     */
    public $type=NULL;

    /**
     * @var  string When the type is an OBJECT or a COLLECTION or an ENUM, you can specify its class
     */
    public $instanceOf=NULL;

    /**
     *  When the type is an ENUM, you can specify its precise type.
     * Swift enum can be typed. We want to be able to cast the enums.
     * E.g : property status type=enum, instanceOf=string , enumPreciseType=User.status
     *
     *  @var  string
     */
    public $emumPreciseType=NULL;

    /**
     * When $type is an ENUM you can enumerate the values in an array
     * @var array
     */
    public $enumerations = array();


    /**
     * Set to true if the type is generated (allow to to discriminate primitive from generated types)
     * @var bool
     */
    public $isGeneratedType = false;



    /**
     * Whether or not the property is required
     * @var  bool
     */
    public $required=false;

    /**
     * Default value to use if no value is supplied
     * @var  mixed
     */
    public $default=NULL;

    /**
     * When the type is a string, you can specify the regex pattern that a value must match
     * @var string
     */
    public $pattern=NULL;


    /**
     * Defines if the property should be serialized.
     * @var bool
     */
    public $isSerializable = true;

    /**
     * Defines if the property changes should be supervised
     * @var bool
     */
    public $isSupervisable = true;


    /**
     * Defines if the property should be crypted on Serialization
     * @var bool
     */
    public $isCryptable = false;


    /**
     * Defines if the class exists and is external to the generative package.
     * @var bool
     */
    public $isExternal = false;


    /**
     * @var bool set to false if the property is not extractible in a sub-graph copy operation
     */
    public $isExtractible = true;

    /**
     * Set to true to allow for example cocoa bindings.
     * @var bool
     */
    public $isDynamic = true;

    /**
     * @var NULL or an  array of PropertyRepresentation used to propose a serialization re-mapping
     * Usage sample : in cuds.withWeakLogic.swift.template.php to deal with Operation(s) partial graph mapping
     */
    public $customSerializationMapping=NULL;

    /**
     * An associative array to pass specific metadata
     * @var array
     */
    public $metadata=array();

}

?>#BMS#->{"filename":"SecurityContextRepresentation.php","checksum":4211258615,"relativePath":"BartlebyFlexions\/src\/flexions\/representations\/flexions\/SecurityContextRepresentation.php","size":1461}<-#BME#
<?php

/**
 * Created by PhpStorm.
 * User: bpds
 * Date: 23/07/2015
 * Time: 12:10
 */

require_once FLEXIONS_ROOT_DIR.'flexions/Core/Enum.php';


class RelationToPermission extends Enum{
    const UNDEFINED='undefined';
    const REQUIRES='requires';  // authentication required
    const PROVIDES='provides';  // e.g log in
    const DISCARDS='discards';  // e.g log out

    static  function possibleValues(){
        return array(
            RelationToPermission::UNDEFINED,
            RelationToPermission::REQUIRES,
            RelationToPermission::PROVIDES,
            RelationToPermission::DISCARDS
        );

    }

}


class SecurityContextRepresentation {

    /**
     * @var PermissionRepresentation
     */
    private  $permission;

    /**
     * @var string one of RelationToPermission consts
     */
    private $_relation=RelationToPermission::UNDEFINED;



    /**
     * @return PermissionRepresentation
     */
    public function getPermission() {
        return $this->permission;
    }

    /**
     * @param PermissionRepresentation $permission
     */
    public function setPermission(PermissionRepresentation $permission) {
        $this->permission = $permission;
    }


    /**
     * @return string
     */
    public function getRelation() {
        return $this->_relation;
    }

    /**
     * @param string $relation
     */
    public function setRelation($relation) {
        $this->_relation = $relation;
    }

}
#BMS#->{"filename":"flexions.php","checksum":1221777291,"relativePath":"BartlebyFlexions\/src\/flexions.php","size":1072}<-#BME#
<?php

/*
Created by Benoit Pereira da Silva on 20/04/2013.
Copyright (c) 2013  http://www.chaosmos.fr

This file is part of Flexions

Flexions is free software: you can redistribute it and/or modify
it under the terms of the GNU LESSER GENERAL PUBLIC LICENSE as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Flexions is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU LESSER GENERAL PUBLIC LICENSE for more details.

You should have received a copy of the GNU LESSER GENERAL PUBLIC LICENSE
along with Flexions  If not, see <http://www.gnu.org/Licenses/>

*/

define ( "ECHO_LOGS", false );
define ( "FLEXIONS_ROOT_DIR", __DIR__ . '/' );
define ( "FLEXIONS_MODULES_DIR", FLEXIONS_ROOT_DIR . 'modules/' );
define ( "VERBOSE_FLEXIONS", true );

try {
    include_once "flexions/Core/flexions.script.php";
}catch (Exception $e){
    echo 'ROOT EXCEPTION '.$e->getMessage();
}
#BMS#->{"filename":"endPoints.json.template.php","checksum":2882801176,"relativePath":"BartlebyFlexions\/src\/modules\/Bartleby\/modeling-meta-templates\/project\/endPoints.json.template.php","size":18661}<-#BME#
<?php

include  FLEXIONS_SOURCE_DIR.'/Shared.php';

// URD == Upsert Read Delete
// CRUD == Create Read Update Delete

/* @var $f Flexed */
/* @var $d EntityRepresentation */

if (isset ( $f )) {
    $f->fileName = 'pathsFragment.json';
    $f->package = '';
}

/* TEMPLATES STARTS HERE -> */?>
{ "paths" : {
<?php
/* @var $d ProjectRepresentation */
/* @var $entity EntityRepresentation */

$counter=0;
$blocks=array();
foreach ($d->entities as $entity ) {
    $name = $entity->name;

    if (isset($prefix)) {
        $name = str_replace($prefix, '', $name);
    }


    //$pluralized=lcfirst(P

    //luralization::pluralize($name));
    $counter++;

    // EXCLUSION FROM CRUD
    // You can exclude entities containing a given string

    $shouldBeExcluded = false;
    $exclusion = array();
    if (isset($excludeActionsWith)) {
        $exclusion = $excludeActionsWith;
    }
    foreach ($exclusion as $exclusionString) {
        if (strpos($name, $exclusionString) !== false) {
            $shouldBeExcluded = true;
        }
    }

    if ($shouldBeExcluded) {
        continue;//Let's exclude this entity from the CRUD
    }


    // UPDATE EXCLUSION
    $isUnModifiable = false;
    $unModifiable = array();
    if (isset($unModifiableEntitiesWith)) {
        $unModifiable = $unModifiableEntitiesWith;
    }
    foreach ($unModifiable as $unModifiableString) {
        if (strpos($name, $unModifiableString) !== false) {
            $isUnModifiable = true;
        }
    }

    // DELETION EXCLUSION
    $isUndeletable = false;
    $undeletable = array();
    if (isset($unDeletableEntitiesWith)) {
        $undeletable = $unDeletableEntitiesWith;
    }
    foreach ($undeletable as $undeletableString) {
        if (strpos($name, $undeletableString) !== false) {
            $isUndeletable = true;
        }
    }

    $pluralizedName = lcfirst(Pluralization::pluralize($name));


    ////////////////////////////
    // SINGLE INSTANCE
    ///////////////////////////


    // The read block is the only one with the id in the path
    $readBlock = '
        "/' . lcfirst($name) . '/{' . lcfirst($name) . 'Id}" : {
        "get" : {
            "tags" : [
                "' . $pluralizedName . '"
            ],
            "summary" : "Find ' . $name . ' by ID",
            "description" : "Returns a single ' . $name . '",
            "operationId" : "read' . ucfirst($name) . 'ById",
            "produces" : [
                    "application/json"
                ],
            "parameters" : [
              {
                "name" : "' . lcfirst($name) . 'Id",
                "in" : "path",
                "description" : "The unique identifier the the of ' . $name . '",
                "required" : true,
                "type" : "string"
              }


            ],
            "responses" : {
                    "200" : {
                        "description" : "successful operation",
                         "schema" : {
                            "$ref" : "#/definitions/' . ucfirst($name) . '"
                        }
                    },
                    "404" : {
                         "description" : "' . ucfirst($name) . ' not found"
                    }
            }
          }
        },';

    if ($entity->usesUrdMode() == true) {
        $upsertBlock = '
    "/' . lcfirst($name) . '" :
     {
        "post" : {
            "tags" : [
                "' . $pluralizedName . '"
            ],
        "summary" : "Creates or insert a new ' . $name . ' to the system",
        "description" : "",
        "operationId" : "upsert' . ucfirst($name) . '",
        "consumes" : [
                "application/json"
            ],
        "produces" : [
                "application/json"
            ],
        "parameters" : [
          {
            "in" : "body",
            "name" : "' . lcfirst($name) . '",
            "description" : "The instance of' . $name . ' that needs to be inserted or updated",
            "required" : true,
            "schema" : {
              "$ref" : "#/definitions/' . ucfirst($name) . '"
            }
          }
        ],
        "responses" : {
                "405" : {
                    "description" : "Invalid input"
          }
        },
         "metadata": {
              "urdMode": true
          }
      }
    ';

    } else {

        $createBlock = '
    "/' . lcfirst($name) . '" :
     {
        "post" : {
            "tags" : [
                "' . $pluralizedName . '"
            ],
        "summary" : "Creates a new ' . $name . ' to the system",
        "description" : "",
        "operationId" : "create' . ucfirst($name) . '",
        "consumes" : [
                "application/json"
            ],
        "produces" : [
                "application/json"
            ],
        "parameters" : [


          {
            "in" : "body",
            "name" : "' . lcfirst($name) . '",
            "description" : "The instance of' . $name . ' that needs to be added",
            "required" : true,
            "schema" : {
              "$ref" : "#/definitions/' . ucfirst($name) . '"
            }
          }
        ],
        "responses" : {
                "405" : {
                    "description" : "Invalid input"
          }
        },
         "metadata": {
              "urdMode": false
          }
      }
    ';


        $updateBlock = ',
        "put" : {
            "tags" : [
                "' . $pluralizedName . '"
            ],
        "summary" : "Update an existing ' . $name . '",
        "description" : "",
        "operationId" : "update' . ucfirst($name) . '",
        "consumes" : [
                "application/json"
            ],
        "produces" : [
                "application/json"
            ],
        "parameters" : [
          {
            "in" : "body",
            "name" : "' . lcfirst($name) . '",
            "description" : "The ' . ucfirst($name) . ' instance to update",
            "required" : true,
            "schema" : {
              "$ref" : "#/definitions/' . ucfirst($name) . '"
            }
          }
        ],
        "responses" : {
          "400" : {
             "description" : "Invalid ID supplied"
          },
          "404" : {
                    "description" : "' . ucfirst($name) . ' not found"
          },
          "405" : {
                    "description" : "Validation exception"
          }
        }
      }';

    }


    $deleteBlock = ',
        "delete" : {
            "tags" : [
                "' . $pluralizedName . '"
            ],
            "summary" : "Deletes a ' . $name . '",
            "description" : "",
            "operationId" : "delete' . ucfirst($name) . '",
            "produces" : [
                    "application/json"
                ],
            "parameters" : [
              {
                "name" : "' . lcfirst($name) . 'Id",
                "in" : "path",
                "description" : "The identifier of the ' . ucfirst($name) . ' to be deleted",
                "required" : true,
                "type" : "string"
              }
            ],
            "responses" : {
                    "400" : {
                        "description" : "Invalid ' . $name . ' value"
              }
            }
        }
     ';

    $block = $readBlock;
    if ($entity->usesUrdMode() == true) {
        $block .= $upsertBlock;
    } else {
        $block .= $createBlock;
        if ($isUnModifiable == false) {
            $block .= $updateBlock;
        }
    }

    if ($isUndeletable == false) {
        $block .= $deleteBlock;
    }
    $block .= '}';
    $block .= ',';


    ////////////////////////////
    // COLLECTIONS
    ////////////////////////////

    if ($entity->usesUrdMode() == true) {

        $upsertCollectionBlock = '
    "/' . lcfirst($pluralizedName) . '" : {
        "post" : {
            "tags" : [
                "' . $pluralizedName . '"
            ],
            "summary" : "Creates or updates ' . $pluralizedName . '",
            "description" : "",
            "operationId" : "upsert' . ucfirst($pluralizedName) . '",
            "consumes" : [
                    "application/json"
                ],
            "produces" : [
                    "application/json"
                ],
            "parameters" : [
             {
                "in" : "body",
                "name" : "' . lcfirst($pluralizedName) . '",
                "description" : "Collection of ' . $name . ' that needs to be upserted",
                "required" : true,
                "schema": {
                            "type": "array",
                            "items":
                            {
                                "$ref": "#/definitions/' . ucfirst($name) . '"
                             }
                         }
              }
            ],
            "responses" : {
                    "405" : {
                        "description" : "Invalid input"
                     }
            },
         "metadata": {
              "urdMode": true
          }
     },
    ';
    } else {

        $createCollectionBlock = '
    "/' . lcfirst($pluralizedName) . '" : {
        "post" : {
            "tags" : [
                "' . $pluralizedName . '"
            ],
            "summary" : "Create ' . $pluralizedName . ' to the system",
            "description" : "",
            "operationId" : "create' . ucfirst($pluralizedName) . '",
            "consumes" : [
                    "application/json"
                ],
            "produces" : [
                    "application/json"
                ],
            "parameters" : [
             {
                "in" : "body",
                "name" : "' . lcfirst($pluralizedName) . '",
                "description" : "Collection of ' . $name . ' that needs to be added",
                "required" : true,
                "schema": {
                            "type": "array",
                            "items":
                            {
                                "$ref": "#/definitions/' . ucfirst($name) . '"
                             }
                         }
              }
            ],
            "responses" : {
                    "405" : {
                        "description" : "Invalid input"
                     }
            },
         "metadata": {
              "urdMode": false
          }
     },
    ';

    }
    $readCollectionBlock = '    "get" : {
            "tags" : [
                "' . $pluralizedName . '"
            ],
            "summary" : "Find ' . $pluralizedName . ' by ID",
            "description" : "Returns a collection of ' . $name . '",
            "operationId" : "read' . ucfirst($pluralizedName) . 'ByIds",
            "produces" : [
                    "application/json"
                ],
            "parameters" : [
              {
                "name" : "ids",
                "in" : "path",
                "description" : "The IDS of the ' . $pluralizedName . ' to return",
                "required" : true,
                 "type": "array",
                 "items": {
                     "type": "string"
                  }
              },
              {
                "in" : "body",
                "name" : "result_fields",
                "description" : "the result fields (MONGO DB)",
                "required" : true,
                "schema": {
                            "type": "array",
                            "items":
                            {
                                "type": "string"
                             }
                         }
              },
              {
                "in" : "body",
                "name" : "sort",
                "description" : "the sort (MONGO DB)",
                "required" : false,
                "type":  "dictionary"
               }
            ],
            "responses" : {
               "200" : {

                       "description" : "successful operation",
                       "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/' . ucfirst($name) . '"
                            }
                       }

              },
              "400" : {
                        "description" : "Invalid IDS supplied"
              },
              "404" : {
                        "description" : "' . ucfirst($pluralizedName) . ' not found"
              }
            }
          }
        ';

    if ($entity->usesUrdMode() == false) {
        $updateCollectionBlock = ',
        "put" : {
            "tags" : [
                "' . $pluralizedName . '"
            ],
            "summary" : "Update an existing ' . $name . '",
            "description" : "",
            "operationId" : "update' . ucfirst($pluralizedName) . '",
            "consumes" : [
                    "application/json"
                ],
            "produces" : [
                    "application/json"
                ],
            "parameters" : [
              {
                "in" : "body",
                "name" : "' . lcfirst($pluralizedName) . '",
                "description" : "Collection of ' . ucfirst($name) . ' to update",
                "required" : true,
                "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/' . ucfirst($name) . '"
                             }
                    }
              }
            ],
            "responses" : {
              "400" : {
                 "description" : "Invalid IDS supplied"
              },
              "404" : {
                        "description" : "' . ucfirst($pluralizedName) . ' not found"
              },
              "405" : {
                        "description" : "Validation exception"
              }
            }
      }';

    }

    $deleteCollectionBlock = ',
        "delete" : {

            "tags" : [
                "' . $pluralizedName . '"
            ],
            "summary" : "Deletes some ' . $pluralizedName . '",
            "description" : "",
            "operationId" : "delete' . ucfirst($pluralizedName) . '",
            "produces" : [
                    "application/json"
                ],
            "parameters" : [
              {
                "name" : "ids",
                "in" : "path",
                "description" : "The ids of ' . $pluralizedName . ' to delete",
                "required" : true,
                 "type": "array",
                 "items": {
                     "type": "string"
                  }
              }
            ],
            "responses" : {
                    "400" : {
                        "description" : "Invalid ' . $pluralizedName . ' value"
                    }
            }
        }';


    if ($entity->usesUrdMode() == true) {

        $block .= $upsertCollectionBlock;
        $block .= $readCollectionBlock;

        if ($isUndeletable == false) {
            $block .= $deleteCollectionBlock;
        }

        $block .= cr() . '}';
        $block .= ',';

    } else {

        $block .= $createCollectionBlock;
        $block .= $readCollectionBlock;
        if ($isUnModifiable == false) {
            $block .= $updateCollectionBlock;
        }
        if ($isUndeletable == false) {
            $block .= $deleteCollectionBlock;
        }
        $block .= cr() . '}';
        $block .= ',';

    }


    ////////////////////////////
    // GETTER BY QUERY
    ////////////////////////////


    // We use POST to pass a query
    // Other Reading endpoint are cachable not those one ()

    $genericQueryGetPathBlock = '
        "/' . lcfirst($pluralizedName) . 'ByQuery" : {
            "get" : {
                "tags" : [
                    "' . $pluralizedName . '"
                ],
                "summary" : "Find ' . $pluralizedName . ' by query (check $q, $s, $f in Bartleby\'s MongoCallDataRawWrapper)",
                "description" : "Returns a collection of ' . $name . '",
                "operationId" : "read' . ucfirst($pluralizedName) . 'ByQuery",
                "produces" : [
                        "application/json"
                    ],
                 "parameters" : [
                     {
                        "in" : "body",
                        "name" : "result_fields",
                        "description" : "the result fields (MONGO DB)",
                        "required" : true,
                        "schema": {
                                    "type": "array",
                                    "items":
                                    {
                                        "type": "string"
                                     }
                                 }
                      },
                       {
                        "in" : "body",
                        "name" : "sort",
                        "description" : "the sort (MONGO DB)",
                        "required" : false,
                        "type":  "dictionary"
                      },
                      {
                        "in" : "body",
                        "name" : "query",
                        "description" : "the query (MONGO DB)",
                        "required" : false,
                        "type":  "dictionary"
                      }
                  ]
                ,
                "responses" : {
                   "200" : {
                             "description" : "successful operation",
                              "schema": {
                                    "type": "array",
                                    "items": {
                                        "$ref": "#/definitions/' . ucfirst($name) . '"
                                    }
                              }
                   },
                  "400" : {
                            "description" : "Invalid IDS supplied"
                  },
                  "404" : {
                            "description" : "' . ucfirst($pluralizedName) . ' not found"
                  }
                }
            }
        },';
    $block .= $genericQueryGetPathBlock;
    $blocks[] = $block;
}
// Let's echo the blocks
$nbOfBlocks=count($blocks);
for ($i=0;$i<$nbOfBlocks;$i++){
    $currentBlock=$blocks[$i];
    if($i==$nbOfBlocks-1){
        // Delete the last comma.
        $currentBlock=substr($currentBlock,0,strlen($currentBlock)-1);
    }
    echo($currentBlock);
}
?>
    }
}
<?php /*<- END OF TEMPLATE */

?>#BMS#->{"filename":"cuds.withWeakLogic.swift.template.php","checksum":285726359,"relativePath":"BartlebyFlexions\/src\/modules\/Bartleby\/templates\/actions\/cuds.withWeakLogic.swift.template.php","size":23760}<-#BME#
<?php

/*
 * SWIFT 2.X template
 * This weak logic template is compliant with Bartleby 1.0 approach.
 * It allows to update easily very complex templates.gt
 * It is not logic less but the logic intent to be as weak as possible
 */
require_once FLEXIONS_MODULES_DIR . '/Bartleby/templates/Requires.php';

/* @var $flexed Flexed */
/* @var $actionRepresentation ActionRepresentation*/
/* @var $hypotypose Hypotypose */

if (isset( $f,$d,$h)) {

    /* @var $f Flexed */
    /* @var $d ActionRepresentation*/
    /* @var $h Hypotypose */

    // We use explicit name (!)
    // And reserve $f , $d , $h possibly for blocks

    /* @var $flexed Flexed*/
    /* @var $actionRepresentation ActionRepresentation*/
    /* @var $hypotypose Hypotypose*/

    $flexed=$f;
    $actionRepresentation=$d;
    $hypotypose=$h;

    $flexed->fileName = $actionRepresentation->class . '.swift';
    $flexed->package = 'xOS/operations/';

}else{
    return NULL;
}

/////////////////
// EXCLUSIONS
/////////////////

// Should this Action be excluded ?

$exclusionName = str_replace($h->classPrefix, '', $d->class);
if (isset($excludeActionsWith)) {
    foreach ($excludeActionsWith as $exclusionString) {
        if (strpos($exclusionName, $exclusionString) !== false) {
            return NULL; // We return null
        }
    }
}


// This template cannot be used for GET Methods
if ($actionRepresentation->httpMethod==='GET'){
    return NULL;
}

// We want also to exclude by query

if (!(strpos($d->class,'ByQuery')===false)){
    return NULL;
}

/////////////////////////
// VARIABLES COMPUTATION
/////////////////////////

// Compute ALL the Variables you need in the template

$httpMethod=$actionRepresentation->httpMethod;
$pluralizedName=lcfirst($actionRepresentation->collectionName);
$singularName=lcfirst(Pluralization::singularize($pluralizedName));
$baseClassName=ucfirst($actionRepresentation->class);
$ucfSingularName=ucfirst($singularName);
$ucfPluralizedName=ucfirst($pluralizedName);

$actionString=NULL;
$localAction=NULL;

$registrySyntagm='inRegistryWithUID';


if ($httpMethod=="POST"){
    $actionString='creation';
    $localAction='upsert';
}elseif ($httpMethod=="PUT"){
    $actionString='update';
    $localAction='upsert';
}elseif ($httpMethod=="PATCH"){
    $actionString='update';
    $localAction='upsert';
}elseif ($httpMethod=="DELETE"){
    $actionString=NULL;
    $localAction=NULL;
    $registrySyntagm='fromRegistryWithUID';
}else{
    $actionString='NO_FOUND';
    $localAction='NO_FOUND';
}

$firstParameterName=NULL;
$firstParameterTypeString=NULL;
$varName=NULL;
$executeArgumentSerializationBlock=NULL;
/* @var $firstParameter PropertyRepresentation */
$firstParameter=NULL;


while($actionRepresentation->iterateOnParameters()){
    /*@var $parameter PropertyRepresentation*/
    $parameter=$actionRepresentation->getParameter();
    // We use the first parameter.
    if (!isset($varName,$firstParameterName,$firstParameterTypeString)){
        if ($parameter->type == FlexionsTypes::COLLECTION){
            $firstParameter=$parameter;
            $firstParameterName=$parameter->name;
            if($httpMethod!='DELETE'){
                $firstParameterTypeString='['.$ucfSingularName.']';
                $executeArgumentSerializationBlock="
                var parameters=Dictionary<String, Any>()
                var collection=[Dictionary<String, Any>]()

                for $singularName in $pluralizedName{
                    let serializedInstance=Mapper<$ucfSingularName>().toJSON($singularName)
                    collection.append(serializedInstance)
                }
                parameters[\"$pluralizedName\"]=collection".cr();
            }else{
                $actionString='deleteByIds';
                $localAction='deleteByIds';
                $firstParameterTypeString='[String]';
                $executeArgumentSerializationBlock="
                var parameters=Dictionary<String, Any>()
                parameters[\"ids\"]=ids".cr();
            }
            $varName=$pluralizedName;
        }else{
            $firstParameter=$parameter;
            $firstParameterName=$parameter->name;
            if($httpMethod!='DELETE'){
                $firstParameterTypeString=$ucfSingularName;
                $executeArgumentSerializationBlock="
                var parameters=Dictionary<String, Any>()
                parameters[\"$singularName\"]=Mapper<$firstParameterTypeString>().toJSON($firstParameterName)".cr();
            }else{
                $actionString='deleteById';
                $localAction='deleteById';
                $firstParameterTypeString='String';
                $executeArgumentSerializationBlock="
                var parameters=Dictionary<String, Any>()
                parameters[\"".$singularName."Id\"]=".$singularName."Id".cr();
            }
            $varName=$singularName;
        }
    }
}


/////////////////////////
// TEMPLATE
/////////////////////////

/* TEMPLATES STARTS HERE -> */?>
<?php echo GenerativeHelperForSwift::defaultHeader($flexed,$actionRepresentation); ?>

import Foundation
#if !USE_EMBEDDED_MODULES
<?php
if (isset($isIncludeInBartlebysCommons) && $isIncludeInBartlebysCommons==true){
    echoIndent(cr(),0);
    echoIndentCR("import Alamofire",0);
    echoIndentCR("import ObjectMapper",0);
}else{
    echoIndent(cr(),0);
    echoIndentCR("import Alamofire",0);
    echoIndentCR("import ObjectMapper",0);
    echoIndentCR("import BartlebyKit",0);
}
/*@var array */
$GLOBAL_GENERATED_ACTIONS[]=$baseClassName;

?>
#endif

@objc(<?php echo$baseClassName ?>) public class <?php echo$baseClassName ?> : <?php echo GenerativeHelperForSwift::getBaseClass($f,$d); ?>,JHTTPCommand{

    // Universal type support
    override open class func typeName() -> String {
        return "<?php echo $baseClassName ?>"
    }

    fileprivate var _<?php echo$firstParameterName ?>:<?php echo$firstParameterTypeString ?> = <?php echo$firstParameterTypeString ?>()

    fileprivate var _registryUID:String=Default.NO_UID

    required public convenience init(){
        self.init(<?php echo$firstParameterTypeString ?>(), <?php echo$registrySyntagm ?>:Default.NO_UID)
    }



<?php

//////////////////////////////
//
// THIS IS A COMPLEX CASE
// READ CAREFULLY
//
// We want to serialize the parameters has Mappable & NSSecureCoding
// and  not serialize globally the operation
// as the operation will serialize this instance in its data dictionary.
//
// We Gonna inject the relevant private properties.
// #1 Create a virtual entity
// #2 Inject the PropertyRepresentation
////////////////////////////////

/* @var $virtualEntity EntityRepresentation */

$privateMemberName='_'.$firstParameterName;

$virtualEntity=new EntityRepresentation();

$_ENTITY_rep=new PropertyRepresentation();
$_ENTITY_rep->name=$privateMemberName;


$_ENTITY_rep->type=$firstParameter->type;
$_ENTITY_rep->instanceOf=$firstParameter->instanceOf;
$_ENTITY_rep->required=true;
$_ENTITY_rep->isDynamic=false;
$_ENTITY_rep->default=NULL;
$_ENTITY_rep->isGeneratedType=true;
$virtualEntity->properties[]=$_ENTITY_rep;


$_spaceUID_rep=new PropertyRepresentation();
$_spaceUID_rep->name="_registryUID";
$_spaceUID_rep->type=FlexionsTypes::STRING;
$_spaceUID_rep->required=true;
$_spaceUID_rep->isDynamic=false;
$_spaceUID_rep->default="Default.NO_UID";
$_spaceUID_rep->isGeneratedType=false;
$virtualEntity->properties[]=$_spaceUID_rep;

/*

// Operation is a very special object.
// Used By bartleby interact with a collaborative api
// (!) Do not serialize globally the operation
// as the operation will serialize this instance in its data dictionary.

$_opUID_operation_rep=new PropertyRepresentation();
$_opUID_operation_rep->name="_operation.registryUID";
$_opUID_operation_rep->type=FlexionsTypes::STRING;
$_opUID_operation_rep->required=true;
$_opUID_operation_rep->default="\\(Default.NO_UID)";
$_opUID_operation_rep->isGeneratedType=true;

$_creatorUID_operation_rep=new PropertyRepresentation();
$_creatorUID_operation_rep->name="_operation.creatorUID";
$_creatorUID_operation_rep->type=FlexionsTypes::STRING;
$_creatorUID_operation_rep->required=true;
$_creatorUID_operation_rep->default="\\(Default.NO_UID)";
$_creatorUID_operation_rep->isGeneratedType=true;

$_status_operation_rep=new PropertyRepresentation();
$_status_operation_rep->name="_operation.status";
$_status_operation_rep->type=FlexionsTypes::ENUM;
$_status_operation_rep->instanceOf="string";
$_status_operation_rep->emumPreciseType="PushOperation.Status";
$_status_operation_rep->required=true;
$_status_operation_rep->default='.None';
$_status_operation_rep->isGeneratedType=true;

$_counter_operation_rep=new PropertyRepresentation();
$_counter_operation_rep->name="_operation.counter";
$_counter_operation_rep->type=FlexionsTypes::INTEGER;
$_counter_operation_rep->required=true;
$_counter_operation_rep->default=0;
$_counter_operation_rep->isGeneratedType=true;

$_creationDate_operation_rep=new PropertyRepresentation();
$_creationDate_operation_rep->name="_operation.creationDate";
$_creationDate_operation_rep->type=FlexionsTypes::DATETIME;
$_creationDate_operation_rep->required=false;
$_creationDate_operation_rep->isGeneratedType=true;


$_operation_rep=new PropertyRepresentation();
$_operation_rep->name="_operation";
$_operation_rep->type="Operation";
$_operation_rep->required=true;
$_operation_rep->isDynamic=false;
$_operation_rep->default="Operation()";
$_operation_rep->isGeneratedType=true;



// So we use a customSerializationMapping
$_operation_rep->customSerializationMapping=array(
                                                    $_opUID_operation_rep,
                                                    $_creatorUID_operation_rep,
                                                    $_status_operation_rep,
                                                    $_counter_operation_rep,
                                                    $_creationDate_operation_rep
                                                );
$virtualEntity->properties[]=$_operation_rep;
*/
$blockRepresentation=$virtualEntity;

// Mappable
include  FLEXIONS_MODULES_DIR.'/Bartleby/templates/blocks/Mappable.swift.block.php';
if( $modelsShouldConformToNSCoding ) {
    // NSSecureCoding
    include  FLEXIONS_MODULES_DIR.'/Bartleby/templates/blocks/NSSecureCoding.swift.block.php';
}

?>


    /**
    This is the designated constructor.

    - parameter <?php echo$firstParameterName ?>: the <?php echo$firstParameterName ?> concerned the operation
    - parameter registryUID the registry or document UID

    */
    init (_ <?php echo$firstParameterName ?>:<?php echo$firstParameterTypeString ?>=<?php echo$firstParameterTypeString."()" ?>, <?php echo$registrySyntagm ?> registryUID:String) {
        self._<?php echo$firstParameterName ?>=<?php echo$firstParameterName.cr() ?>
        self._registryUID=registryUID
        super.init()
    }

    /**
     Returns an operation with self.UID as commandUID

     - returns: return the operation
     */
    fileprivate func _getOperation()->PushOperation{
        if let document = Bartleby.sharedInstance.getDocumentByUID(self._registryUID) {
            if let ic:PushOperationsCollectionController = try? document.getCollection(){
                let operations=ic.filter({ (operation) -> Bool in
                    return operation.commandUID==self.UID
                })
                if let operation=operations.first {
                    return operation
                }}
        }
        let operation=PushOperation()
        operation.disableSupervision()
        operation.commandUID=self.UID
        operation.defineUID()
        return operation
    }


    /**
    Creates the operation and proceeds to commit

    - parameter <?php echo$firstParameterName ?>: the instance
    - parameter registryUID:     the registry or document UID
    */
    static func commit(_ <?php echo$firstParameterName ?>:<?php echo$firstParameterTypeString ?>, <?php echo$registrySyntagm ?> registryUID:String){
        let operationInstance=<?php echo$baseClassName ?>(<?php echo$firstParameterName ?>,<?php echo$registrySyntagm ?>:registryUID)
        operationInstance.commit()
    }


    func commit(){
        let context=Context(code:<?php echo crc32($baseClassName.'.commit') ?>, caller: "<?php echo$baseClassName ?>.commit")
        if let document = Bartleby.sharedInstance.getDocumentByUID(self._registryUID) {
            // Provision the operation.
            do{
                let ic:PushOperationsCollectionController = try document.getCollection()
                let operation=self._getOperation()
                operation.counter += 1
                operation.status=PushOperation.Status.pending
                operation.creationDate=Date()
<?php
if ($httpMethod=="DELETE"){
    if ($parameter->type == FlexionsTypes::COLLECTION){
        echoIndentCR('                let stringIDS=PString.ltrim(self._'.$firstParameterName.'.reduce("", { $0+","+$1 }),characters:",")',0);
        echoIndentCR('                operation.summary="'.$baseClassName.'(\(stringIDS))"',0);
    }else{
        echoIndentCR('                operation.summary="'.$baseClassName.'(\(self._'.$firstParameterName.'))"',0);
    }
}else{
    if ($parameter->type == FlexionsTypes::COLLECTION){
        echoIndentCR('                let stringIDS=PString.ltrim(self._'.$firstParameterName.'.reduce("", { $0+","+$1.UID }),characters:",")',0);
        echoIndentCR('                operation.summary="'.$baseClassName.'(\(stringIDS))"',0);
    }else{
        echoIndentCR('                operation.summary="'.$baseClassName.'(\(self._'.$firstParameterName.'.UID))"',0);
    }
}
?>
                if let currentUser=document.registryMetadata.currentUser{
                    operation.creatorUID=currentUser.UID
                    self.creatorUID=currentUser.UID
                }
<?php
    if ($httpMethod!="DELETE"){
        if ($parameter->type == FlexionsTypes::COLLECTION){
            echo("                for item in self._$firstParameterName{
                    item.committed=true
                }".cr());
        }else{
            echo("                self._$firstParameterName.committed=true".cr());
        }
    }?>
                operation.toDictionary=self.dictionaryRepresentation()
                operation.enableSupervision()
                ic.add(operation, commit:false)
            }catch{
                Bartleby.sharedInstance.dispatchAdaptiveMessage(context,
                    title: "Structural Error",
                    body: "Operation collection is missing in  <?php echo($baseClassName);?>",
                    onSelectedIndex: { (selectedIndex) -> () in
                })
            }
        }else{
            // This document is not available there is nothing to do.
            let m=NSLocalizedString("Registry is missing", comment: "Registry is missing")
            Bartleby.sharedInstance.dispatchAdaptiveMessage(context,
                    title: NSLocalizedString("Structural error", comment: "Structural error"),
                    body: "\(m) registryUID =\(self._registryUID) in <?php echo($baseClassName);?>",
                    onSelectedIndex: { (selectedIndex) -> () in
                    }
            )
        }
    }

    open func push(sucessHandler success:@escaping (_ context:JHTTPResponse)->(),
        failureHandler failure:@escaping (_ context:JHTTPResponse)->()){
        // The unitary operation are not always idempotent
        // so we do not want to push multiple times unintensionnaly.
        // Check BartlebyDocument+Operations.swift to understand Operation status
        let operation=self._getOperation()
        if  operation.canBePushed(){
            // We try to execute
            operation.status=PushOperation.Status.inProgress
            <?php echo$baseClassName ?>.execute(<?php echo"self._$firstParameterName,
                $registrySyntagm:self._registryUID,".cr() ?>
                sucessHandler: { (context: JHTTPResponse) -> () in
<?php
                if ($httpMethod!="DELETE"){
                    if ($parameter->type == FlexionsTypes::COLLECTION){
                        echo("                    for item in self._$firstParameterName{
                        item.distributed=true
                    }".cr());
                    }else{
                        echo("                    self._$firstParameterName.distributed=true".cr());
                    }
                }
?>
                    operation.counter=operation.counter+1
                    operation.status=PushOperation.Status.completed
                    operation.responseDictionary=Mapper<JHTTPResponse>().toJSON(context)
                    operation.lastInvocationDate=Date()
                    let completion=Completion.successStateFromJHTTPResponse(context)
                    completion.setResult(context)
                    operation.completionState=completion
                    success(context)
                },
                failureHandler: {(context: JHTTPResponse) -> () in
                    operation.counter=operation.counter+1
                    operation.status=PushOperation.Status.completed
                    operation.responseDictionary=Mapper<JHTTPResponse>().toJSON(context)
                    operation.lastInvocationDate=Date()
                    let completion=Completion.failureStateFromJHTTPResponse(context)
                    completion.setResult(context)
                    operation.completionState=completion
                    failure(context)
                }
            )
        }else{
            // This document is not available there is nothing to do.
            let context=Context(code:<?php echo crc32($baseClassName.'.push') ?>, caller: "<?php echo$baseClassName ?>.push")
            Bartleby.sharedInstance.dispatchAdaptiveMessage(context,
                title: NSLocalizedString("Push error", comment: "Push error"),
                body: "\(NSLocalizedString("Attempt to push an operation with status \"",comment:"Attempt to push an operation with status =="))\(operation.status)\"",
                onSelectedIndex: { (selectedIndex) -> () in
            })
        }
    }

    static open func execute(_ <?php echo$firstParameterName ?>:<?php echo$firstParameterTypeString ?>,
            <?php echo$registrySyntagm ?> registryUID:String,
            sucessHandler success: @escaping(_ context:JHTTPResponse)->(),
            failureHandler failure: @escaping(_ context:JHTTPResponse)->()){
            if let document = Bartleby.sharedInstance.getDocumentByUID(registryUID) {
                let pathURL = document.baseURL.appendingPathComponent("<?php echo$varName ?>")<?php echo $executeArgumentSerializationBlock?>
                let urlRequest=HTTPManager.requestWithToken(inRegistryWithUID:document.UID,withActionName:"<?php echo$baseClassName ?>" ,forMethod:"<?php echo$httpMethod?>", and: pathURL)
                do {
                    let r=try <?php if ($httpMethod=='GET') {echo"URLEncoding()";}else{echo"JSONEncoding()";}?>.encode(urlRequest,with:parameters)
                    request(r).validate().responseJSON(completionHandler: { (response) in

                    // Store the response
                    let request=response.request
                    let result=response.result
                    let response=response.response

                    // Bartleby consignation
                    let context = JHTTPResponse( code: <?php echo crc32($baseClassName.'.execute') ?>,
                        caller: "<?php echo$baseClassName ?>.execute",
                        relatedURL:request?.url,
                        httpStatusCode: response?.statusCode ?? 0,
                        response: response,
                        result:result.value)

                    // React according to the situation
                    var reactions = Array<Bartleby.Reaction> ()
                    reactions.append(Bartleby.Reaction.track(result: result.value, context: context)) // Tracking

                    if result.isFailure {
                        let m = NSLocalizedString("<?php echo$actionString ?>  of <?php echo$varName ?>",
                            comment: "<?php echo$actionString ?> of <?php echo$varName ?> failure description")
                        let failureReaction =  Bartleby.Reaction.dispatchAdaptiveMessage(
                            context: context,
                            title: NSLocalizedString("Unsuccessfull attempt result.isFailure is true",
                            comment: "Unsuccessfull attempt"),
                            body:"\(m) \n \(response)" ,
                            transmit:{ (selectedIndex) -> () in
                        })
                        reactions.append(failureReaction)
                        failure(context)
                    }else{
                        if let statusCode=response?.statusCode {
                            if 200...299 ~= statusCode {
                                // Acknowledge the trigger if there is one
                                if let dictionary = result.value as? Dictionary< String,AnyObject > {
                                    if let index=dictionary["triggerIndex"] as? NSNumber{
                                        document.acknowledgeOwnedTriggerIndex(index.intValue)
                                    }
                                }
                                success(context)
                            }else{
                                // Bartlby does not currenlty discriminate status codes 100 & 101
                                // and treats any status code >= 300 the same way
                                // because we consider that failures differentiations could be done by the caller.

                                let m=NSLocalizedString("<?php echo$actionString ?> of <?php echo$varName ?>",
                                        comment: "<?php echo$actionString ?> of <?php echo$varName ?> failure description")
                                let failureReaction =  Bartleby.Reaction.dispatchAdaptiveMessage(
                                    context: context,
                                    title: NSLocalizedString("Unsuccessfull attempt",
                                    comment: "Unsuccessfull attempt"),
                                    body: "\(m) \n \(response)",
                                    transmit:{ (selectedIndex) -> () in
                                    })
                                reactions.append(failureReaction)
                                failure(context)
                            }
                        }
                     }
                    //Let's react according to the context.
                    Bartleby.sharedInstance.perform(reactions, forContext: context)
                })
                }catch{
                    let context = JHTTPResponse( code:2 ,
                    caller: "<?php echo$baseClassName ?>.execute",
                    relatedURL:nil,
                    httpStatusCode:500,
                    response:nil,
                    result:"{\"message\":\"\(error)}")
                    failure(context)
                }

            }else{
                let context = JHTTPResponse( code:1 ,
                    caller: "<?php echo$baseClassName ?>.execute",
                    relatedURL:nil,
                    httpStatusCode:417,
                    response:nil,
                    result:"{\"message\":\"Unexisting document with registryUID \(registryUID)\"}")
                    failure(context)
            }
        }
}
<?php /*<- END OF TEMPLATE */?>#BMS#->{"filename":"endpoint.php.template.php","checksum":285666229,"relativePath":"BartlebyFlexions\/src\/modules\/Bartleby\/templates\/actions\/endpoint.php.template.php","size":22153}<-#BME#
<?php
require_once FLEXIONS_MODULES_DIR . '/Bartleby/templates/Requires.php';

/* @var $f Flexed */
/* @var $d ActionRepresentation*/

if (isset ( $f )) {
    $classNameWithoutPrefix=$h->ucFirstRemovePrefixFromString($d->class);
    $callDataClassName=$classNameWithoutPrefix.'CallData';
    $f->fileName = $classNameWithoutPrefix.'.php';
    $f->package = 'php/api/'.$h->majorVersionPathSegmentString().'_generated/EndPoints/';
}

// Exclusion

$exclusionName = str_replace($h->classPrefix, '', $d->class);
if (isset($excludeActionsWith)) {
    foreach ($excludeActionsWith as $exclusionString) {
        if (strpos($exclusionName, $exclusionString) !== false) {
            return NULL; // We return null
        }
    }
}


/* TEMPLATES STARTS HERE -> */?>
<?php echo '<?php'?>
<?php echo GenerativeHelperForPhp::defaultHeader($f,$d); ?>

namespace Bartleby\EndPoints;

require_once BARTLEBY_ROOT_FOLDER . 'Core/KeyPath.php';
require_once BARTLEBY_ROOT_FOLDER . 'Mongo/MongoEndPoint.php';
require_once BARTLEBY_ROOT_FOLDER . 'Mongo/MongoCallDataRawWrapper.php';
require_once BARTLEBY_PUBLIC_FOLDER . 'Configuration.php';

use Bartleby\Mongo\MongoEndPoint;
use Bartleby\Mongo\MongoCallDataRawWrapper;
use Bartleby\Core\JsonResponse;
use \MongoCollection;
use Bartleby\Configuration;
use Bartleby\Core\KeyPath;

class  <?php echo $callDataClassName; ?> extends MongoCallDataRawWrapper {
<?php
$name=null;
$parameterIsAcollection=false;
while ($d->iterateOnParameters() === true) {
    $parameter = $d->getParameter();
    $name=$parameter->name;
    $typeOfProp=$parameter->type;
    $o=FlexionsTypes::OBJECT;
    $c=FlexionsTypes::COLLECTION;
    $parameterIsAcollection=($typeOfProp===$c);
    if (($typeOfProp===$o)||($typeOfProp===$c)) {
        $typeOfProp = $h->ucFirstRemovePrefixFromString($parameter->instanceOf);
        if($typeOfProp==$c){
            $typeOfProp=' array of '.$typeOfProp;
        }
    }

    if($parameter->type==FlexionsTypes::ENUM){
        $enumTypeName=ucfirst($name);
        $typeOfProp=$parameter->instanceOf.' '.$typeOfProp;
        echoIndentCR('// Enumeration of possibles values of '.$name, 1);
        foreach ($parameter->enumerations as $element) {
            if($parameter->instanceOf==FlexionsTypes::STRING){
                echoIndentCR('const ' .$enumTypeName.'_'.ucfirst($element).' = "'.$element.'";' ,1);
            }else{
                echoIndentCR('const ' .$enumTypeName.'_'.ucfirst($element).' = '.$element.';', 1);
            }
        }
    }
    if(isset($parameter->description) && strlen($parameter->description)>1){
        echoIndentCR('/* '.$parameter->description.' */',1);
    }

    echoIndentCR('const '.$name.'=\''.$name.'\';',1);
}
?>
}

 class  <?php echo $classNameWithoutPrefix; ?> extends MongoEndPoint {
<?php


// We use the last and unique parameter for CRUD endpoints (ids based)
// If there is no parameters it means it is a generic Get endpoint based on request.

$lastParameterName=isset($name)?$name:'NO_PARAMETERS';




$parameterIsNotAcollection=(!$parameterIsAcollection);

$successP = $d->getSuccessResponse();
if ($successP->type == FlexionsTypes::COLLECTION) {
    $resultIsNotACollection = false;
}else{
    $resultIsNotACollection=true;
}

$isReadByQueryEndpoint = (strpos($d->class, 'ByQuery') !== false);
$isGETByIdsEndpoint=(strpos($d->class,'ByIds')!==false);
if ($isReadByQueryEndpoint == false && $isGETByIdsEndpoint == false) {
    $isGETByIdEndpoint=true;
}else{
    $isGETByIdEndpoint=false;
}
$isACreateEndpoint=(strpos($d->class,'Create')===0);

if($d->httpMethod=='POST') {
    if ($d->usesUrdMode()==true){

    // URD MODE

        echo('
    function call() {
        /* @var '.$callDataClassName.' */
        $parameters=$this->getModel();
        $db=$this->getDB();
        /* @var \MongoCollection */
        $collection = $db->'.$d->collectionName.';@
        // Default write policy
        $options = array (
            "w" => 1,
            "j" => true,
            "upsert" => true
        );
        '.
            (
            ($parameterIsNotAcollection===true)?
                '$obj=$parameters->getValueForKey('.$callDataClassName.'::'.$lastParameterName.');
         if(!isset($obj) || count($parameters->getDictionary())==0){
          return new JsonResponse(\'Invalid void object\',406);
        }
        // Inject the rootUID and the spaceUID in any entity
        $obj[OBSERVATION_UID_KEY]=$this->getObservationUID(false);
        $obj[SPACE_UID_KEY]=$this->getSpaceUID(false);
            
        
        $q = array (MONGO_ID_KEY =>$obj[MONGO_ID_KEY]);'
                :
                '$arrayOfObject=$parameters->getValueForKey('.$callDataClassName.'::'.$lastParameterName.');
        if(!isset($arrayOfObject) || (is_array($arrayOfObject) && count($arrayOfObject)<1) ){
            return new JsonResponse(\'Invalid void array\',406);
        }'
            )
            .'
        try {
            '.(($parameterIsNotAcollection===true)?
                '$r = $collection->update ($q, $obj,$options );
            if ($r[\'ok\']==1) {
                $s=$this->responseStringWithTriggerIndex($this->createTrigger($parameters),NULL);
                return new JsonResponse($s,200);
            } else {
                return new JsonResponse($r,412);
            }'
                :
                'foreach ($arrayOfObject as $obj){
                  // Inject the rootUID and the spaceUID in any entity
                  $obj[OBSERVATION_UID_KEY]=$this->getObservationUID(false);
                  $obj[SPACE_UID_KEY]=$this->getSpaceUID(false);
        
                $q = array (MONGO_ID_KEY => $obj[MONGO_ID_KEY]);
                $r = $collection->update( $q, $obj,$options);
                if ($r[\'ok\']==1) {
                    if (array_key_exists(\'updatedExisting\', $r)) {
                        $existed = $r[\'updatedExisting\'];
                        if ($existed == false) {
                            return new JsonResponse($q,404);
                        }
                    }
                }else{
                    return new JsonResponse($q,412);
                }
             }
             $s=$this->responseStringWithTriggerIndex($this->createTrigger($parameters),NULL);
            return new JsonResponse($s,200);'
            ).'

        } catch ( \Exception $e ) {
            return new JsonResponse( [  \'code\'=>$e->getCode(),
                                        \'message\'=>$e->getMessage(),
                                        \'file\'=>$e->getFile(),
                                        \'line\'=>$e->getLine(),
                                        \'trace\'=>$e->getTraceAsString()
                                      ],
                                      417
                                    );
        }
     }'
        );
    }else {

        // CRUD MODE

        echo('
    function call() {
        /* @var '.$callDataClassName.' */
        $parameters=$this->getModel();
        $db=$this->getDB();
        /* @var \MongoCollection */
        $collection = $db->' . $d->collectionName . ';
        // Default write policy
        $options = array (
            "w" => 1,
            "j" => true
        );' . (

            ($parameterIsNotAcollection === true) ?

                '
        $obj=$parameters->getValueForKey(' . $callDataClassName . '::' . $lastParameterName . ');
        if(!isset($obj) || count($parameters->getDictionary())==0){
            return new JsonResponse(\'Void submission\',406);
        }'

                :

                '
        $arrayOfObject=$parameters->getValueForKey(' . $callDataClassName . '::' . $lastParameterName . ');
        if(!isset($arrayOfObject) || (is_array($arrayOfObject) && count($arrayOfObject)<1) ){
            return new JsonResponse(\'Invalid void array\',406);
        }'

            )

            . '
        try {' . (

            ($parameterIsNotAcollection === true) ?

                '
            // Inject the rootUID and the spaceUID in any entity
            $obj[OBSERVATION_UID_KEY]=$this->getObservationUID(false);
            $obj[SPACE_UID_KEY]=$this->getSpaceUID(false);
            
            $r = $collection->insert ( $obj,$options );'

                    :

                    '
            // Inject the rootUID and the spaceUID in any entity
            foreach ($arrayOfObject as &$element) {
                if (is_array($element)){
                    $element[OBSERVATION_UID_KEY]=$this->getObservationUID(false);
                    $element[SPACE_UID_KEY]=$this->getSpaceUID(false);
                }
            }

            
            $r = $collection->batchInsert( $arrayOfObject,$options );'

            )

            . '
             if ($r[\'ok\']==1) {
                $s=$this->responseStringWithTriggerIndex($this->createTrigger($parameters),NULL);
                return new JsonResponse($s,201);
            } else {
                return new JsonResponse($r,412);
            }
        } catch ( \Exception $e ) {
            '.(($isACreateEndpoint===true) ? ' 
            // MONGO E11000 duplicate key error
            if ( $e->getCode() == 11000 && $this->getConfiguration()->IGNORE_MULTIPLE_CREATION_IN_CRUD_MODE() == true){
                // We return A 200 not a 201
                $s=$this->responseStringWithTriggerIndex($this->createTrigger($parameters),\'This is not the first attempt.\');
                return new JsonResponse($s,200);
            }
            ':'').'
            return new JsonResponse( [  \'code\'=>$e->getCode(),
                                        \'message\'=>$e->getMessage(),
                                        \'file\'=>$e->getFile(),
                                        \'line\'=>$e->getLine(),
                                        \'trace\'=>$e->getTraceAsString()
                                     ],
                                      417
                                    );
        }
     }');
    }
} elseif ($d->httpMethod == 'GET' || $isReadByQueryEndpoint === true) {


    echo('
     function call() {
        /* @var '.$callDataClassName.' */
        $parameters=$this->getModel();
        $db=$this->getDB();
        /* @var \MongoCollection */
        $collection = $db->'.$d->collectionName.';'.cr());

    if ($isGETByIdEndpoint===true){
        echo(
'         $q = array (MONGO_ID_KEY =>$parameters->getValueForKey('.$callDataClassName.'::'.$lastParameterName.'));
        if (isset($q)&& count($q)>0){
        }else{
            return new JsonResponse(\'Query is void\',412);
        }');
    }elseif ($isGETByIdsEndpoint===true){
        echo(
'        $ids=$parameters->getValueForKey('.$callDataClassName.'::ids);
        $f=$parameters->getValueForKey('.$callDataClassName.'::result_fields);
        if(isset ($ids) && is_array($ids) && count($ids)){
            $q = array( MONGO_ID_KEY=>array( \'$in\' => $ids ));
        }else{
            return new JsonResponse(VOID_RESPONSE,204);
        }'
    );
    } elseif ($isReadByQueryEndpoint === true) {
        echo(
'      $q = $parameters->getValueForKey('.$callDataClassName.'::'.$lastParameterName.');
       if(!isset($q)){
           return new JsonResponse(VOID_RESPONSE,417);
       }
       $f=$parameters->getValueForKey('.$callDataClassName.'::result_fields);');
    }


    echo('
        try {'.
    (

        ($resultIsNotACollection===true)?

            // RESULT IS NOT A COLLECTION

            '
            $r = $collection->findOne($q);
            if (isset($r)) {
                return new JsonResponse($r,200);
            } else {
                return new JsonResponse(VOID_RESPONSE,404);
            }'

            :
            // RESULT IS A COLLECTION

            '
            $r=array();
            if(isset($f)){
                $cursor = $collection->find( $q , $f );
            }else{
                $cursor = $collection->find($q);
            }
           
            // Sort ?
            $s=$parameters->getCastedDictionaryForKey(' . $callDataClassName . '::sort);
            if (isset($s) && count($s)>0){
              $cursor=$cursor->sort($s);
            }
            
            if ($cursor->count ( TRUE ) > 0) {
               foreach ( $cursor as $obj ) {
                $r[] = $obj;
               }
            }
           ' . (($isReadByQueryEndpoint === false) ?

                // Read by Ids

                ' 
            if (count($r)==count($ids)) {
                //All the entity has been found.
                return new JsonResponse($r,200);
            } else {
                $foundIds=array();
                $notFoundIds=array();
                foreach ($r as $o) {
                    if (array_key_exists(\'_id\', $r)) {
                        $id = $o[\'_id\'];
                        $foundIds[] = $id;
                    }
                }
                foreach ($ids as $id) {
                    if ( !in_array($id,$foundIds)){
                        $notFoundIds=$id;
                    }
                }
                $details=array(\'found\'=>$r,\'notFound\'=>$notFoundIds);
                return new JsonResponse($details,404);
            }
            '

                :
                // isReadByQueryEndpoint
                '
            if (count($r)>0 ) {
                 return new JsonResponse(array(\'found\'=>$r),200);
            } else {
                return new JsonResponse(VOID_RESPONSE,404);
            }')

    ) .'
        } catch ( \Exception $e ) {
            return new JsonResponse( [  \'code\'=>$e->getCode(),
                                    \'message\'=>$e->getMessage(),
                                    \'file\'=>$e->getFile(),
                                    \'line\'=>$e->getLine(),
                                    \'trace\'=>$e->getTraceAsString()
                                  ],
                                  417
                                );
            }
    }');



}elseif ($d->httpMethod=='PUT'){
    echo('
    function call() {
        /* @var '.$callDataClassName.' */
        $parameters=$this->getModel();
        $db=$this->getDB();
        /* @var \MongoCollection */
        $collection = $db->'.$d->collectionName.';
        // Default write policy
        $options = array (
            "w" => 1,
            "j" => true
        );
        '.
        (
            ($parameterIsNotAcollection===true) ?
        '$obj=$parameters->getValueForKey('.$callDataClassName.'::'.$lastParameterName.');
         if(!isset($obj) || count($parameters->getDictionary())==0){
          return new JsonResponse(\'Invalid void object\',406);
        }
        $q = array (MONGO_ID_KEY =>$obj[MONGO_ID_KEY]);'

            :

            '$arrayOfObject=$parameters->getValueForKey('.$callDataClassName.'::'.$lastParameterName.');
        if(!isset($arrayOfObject) || (is_array($arrayOfObject) && count($arrayOfObject)<1) ){
            return new JsonResponse(\'Invalid void array\',406);
        }'

        )
        .'
        try {
            '.(
            ($parameterIsNotAcollection===true) ?

            '
            /// Inject the rootUID and the spaceUID in any entity
            $obj[OBSERVATION_UID_KEY]=$this->getObservationUID(false);
            $obj[SPACE_UID_KEY]=$this->getSpaceUID(false);
            
            $r = $collection->update ($q, $obj,$options );
            if ($r[\'ok\']==1) {
                if(array_key_exists(\'updatedExisting\',$r)){
                    $existed=$r[\'updatedExisting\'];
                    if($existed==true){
                        $s=$this->responseStringWithTriggerIndex($this->createTrigger($parameters),NULL);
                        return new JsonResponse($s,200);
                    }else{
                        return new JsonResponse(VOID_RESPONSE,404);
                    }
                }
                $s=$this->responseStringWithTriggerIndex($this->createTrigger($parameters),NULL);
                return new JsonResponse($s,200);
            } else {
                return new JsonResponse($r,412);
            }'

                :

                '
            foreach ($arrayOfObject as $obj){     
                $q = array (MONGO_ID_KEY => $obj[MONGO_ID_KEY]);
                if (is_array($obj)){
                    // Inject the rootUID and the spaceUID in any entity
                    $obj[OBSERVATION_UID_KEY]=$this->getObservationUID(false);
                    $obj[SPACE_UID_KEY]=$this->getSpaceUID(false);
                }
                $r = $collection->update( $q, $obj,$options);
                if ($r[\'ok\']==1) {
                    if (array_key_exists(\'updatedExisting\', $r)) {
                        $existed = $r[\'updatedExisting\'];
                         if ($existed == false) {
                             return new JsonResponse($q,404);
                         }
                    }
                }else{
                    return new JsonResponse($q,412);
                }
            }
            $s=$this->responseStringWithTriggerIndex($this->createTrigger($parameters),NULL);
            return new JsonResponse($s,200);'
        )

        .'

        } catch ( \Exception $e ) {
            return new JsonResponse( [  \'code\'=>$e->getCode(),
                                        \'message\'=>$e->getMessage(),
                                        \'file\'=>$e->getFile(),
                                        \'line\'=>$e->getLine(),
                                        \'trace\'=>$e->getTraceAsString()
                                      ],
                                      417
                                    );
        }
     }'
    );


}elseif ($d->httpMethod=='DELETE'){
    // DELETE
    echo('
    function call() {
        /* @var '.$callDataClassName.' */
        $parameters=$this->getModel();
        $db=$this->getDB();
        /* @var \MongoCollection */
        $collection = $db->'.$d->collectionName.';
        // Default write policy
        $options = array (
            "w" => 1,
            "j" => true
        );
        '.
    (
        ($parameterIsNotAcollection===true)?

            '$q = array (MONGO_ID_KEY =>$parameters->getValueForKey('.$callDataClassName.'::'.$lastParameterName.'));'

            :

            '$ids=$parameters->getValueForKey('.$callDataClassName.'::'.$lastParameterName.');
        if(isset ($ids) && count($ids)>0){
            $q = array( MONGO_ID_KEY =>array( \'$in\' => $ids ));
        }else{
            $s=$this->responseStringWithTriggerIndex($this->createTrigger($parameters),NULL);
            return new JsonResponse(s,204);
        }'

    )
        .'
        try {
            $r = $collection->remove ( $q,$options );
             if ($r[\'ok\']==1) {
                 $hasBeenRemoved=($r[\'n\'] >= 1);
                 if( $hasBeenRemoved ){
                     $s=$this->responseStringWithTriggerIndex($this->createTrigger($parameters),$hasBeenRemoved?NULL:\'Already deleted\');
                     return new JsonResponse($s,200);
                 }else if  ($this->getConfiguration()->IGNORE_MULTIPLE_DELETION_ATTEMPT() === true) {
                      return new JsonResponse(\'Already deleted\',200);
                 }else{
                     return new JsonResponse(VOID_RESPONSE,404);
                 }
            } else {
                return new JsonResponse($r,412);
            }
        } catch ( \Exception $e ) {
            return new JsonResponse( [  \'code\'=>$e->getCode(),
                                        \'message\'=>$e->getMessage(),
                                        \'file\'=>$e->getFile(),
                                        \'line\'=>$e->getLine(),
                                        \'trace\'=>$e->getTraceAsString()
                                     ],
                                     417
                                    );
        }
     }'
    );
}else{
    echo('// STRANGE METHOD '.$d->httpMethod);
}

/////////////////////////////
//Create the trigger method
/////////////////////////////

if ($d->httpMethod != 'GET' && $isReadByQueryEndpoint === false) {

    if ($d->httpMethod=='DELETE'){
        $action=$classNameWithoutPrefix;
    }else{
        $baseName=str_replace('Create','',$classNameWithoutPrefix);
        $baseName=str_replace('Update','',$baseName);
        $baseName=str_replace('Upsert','',$baseName);
        $action='Read'.$baseName;
        if ($resultIsNotACollection){
            $action .= "ById";
        }else{
            $action .= "ByIds";
        }
    }

    // Normal senderUID block
    $senderUIDBlock='$senderUID=$this->getCurrentUserID($this->getSpaceUID(true));';

    //senderUID block for CreateUser
    if ($classNameWithoutPrefix=="CreateUser"){
        $senderUIDBlock='$senderUID=KeyPath::valueForKeyPath($parameters->getDictionary(),\'user.creatorUID\');';
    }

    // senderUID block for CreateUsers
    if ($classNameWithoutPrefix=="CreateUsers"){
        $senderUIDBlock='$senderUID=NO_UID;
        $users=$parameters->getValueForKey(CreateUserCallData::users);
        if (is_array($users) && count($users)>0){
            $firstUser=$users[0];
            $senderUID=KeyPath::valueForKeyPath($firstUser,"creatorUID");
        }else{
           throw new \Exception("No valid sender UID can be extracted from users");
        }';
    }

    echo('
    
    
    /**
     * Creates and relay the action using a trigger
     * 
     * @param '.$callDataClassName.' $parameters
     * @return  int  -1 if an error has occured and the trigger index on success
     * @throws \Exception
     */
    function createTrigger('.$callDataClassName.' $parameters){
        $ref=$parameters->getValueForKey('.$callDataClassName.'::'.$lastParameterName.');
        $homologousAction="'.$action.'";
        '.$senderUIDBlock.'
        return $this->relayTrigger($senderUID,"'.$d->collectionName.'","'.$classNameWithoutPrefix.'",$homologousAction,$ref);
    }');

}?>
 }
<?php echo '?>'?><?php /*<- END OF TEMPLATE */?>#BMS#->{"filename":"endpoint.swift.template.php","checksum":2276393156,"relativePath":"BartlebyFlexions\/src\/modules\/Bartleby\/templates\/actions\/endpoint.swift.template.php","size":15344}<-#BME#
<?php
require_once FLEXIONS_MODULES_DIR . '/Bartleby/templates/Requires.php';

/* @var $f Flexed */
/* @var $d ActionRepresentation */

if (isset ($f)) {
    $f->fileName = $d->class . '.swift';
    $f->package = 'xOS/operations/';
}

// Exclusion
$exclusionName = str_replace($h->classPrefix, '', $d->class);
if (isset($excludeActionsWith)) {
    foreach ($excludeActionsWith as $exclusionString) {
        if (strpos($exclusionName, $exclusionString) !== false) {
            return NULL; // We return null
        }
    }
}


$dataSpaceSyntagm='inDataSpace';

/* TEMPLATES STARTS HERE -> */?>
<?php echo GenerativeHelperForSwift::defaultHeader($f,$d); ?>

import Foundation
#if !USE_EMBEDDED_MODULES
<?php
if (isset($isIncludeInBartlebysCommons) && $isIncludeInBartlebysCommons==true){
    echoIndent(cr(),0);
    echoIndentCR("import Alamofire",0);
    echoIndentCR("import ObjectMapper",0);
}else{
    echoIndent(cr(),0);
    echoIndentCR("import Alamofire",0);
    echoIndentCR("import ObjectMapper",0);
    echoIndentCR("import BartlebyKit",0);
}
?>
#endif
<?php

//////////////////////////////
/// START OF PARAMETER MODEL
/////////////////////////////


/*@var array */
$GLOBAL_GENERATED_ACTIONS[]=$d->class.'Parameters';

// We generate the parameter class if there is a least one parameter.
if ($d->containsParametersOutOfPath()) {
    echoIndentCR('@objc('.$d->class .'Parameters'.') public class ' . $d->class . 'Parameters : ' . GenerativeHelperForSwift::getBaseClass($f, $d) . ' {', 0);

    // Universal type support
    echoIndentCR('');
    echoIndentCR('// Universal type support',1);
    echoIndentCR('override open class func typeName() -> String {',1);
        echoIndentCR(' return "'.$d->class . 'Parameters"',2);
    echoIndentCR('}',1);
    while ($d->iterateOnParameters() === true) {
        $parameter = $d->getParameter();
        $name = $parameter->name;

        if (!$d->parameterIsInPath($name)) {
            echoIndentCR('// ' . $parameter->description . cr(), 1);
            if ($d->firstParameter()) {
            }
            if ($parameter->type == FlexionsTypes::ENUM) {
                $enumTypeName = $d->name . ucfirst($name);
                echoIndentCR('public enum ' . $enumTypeName . ' : ' . ucfirst($parameter->instanceOf) . '{', 1);
                foreach ($parameter->enumerations as $element) {
                    if ($parameter->instanceOf == FlexionsTypes::STRING) {
                        echoIndentCR('case ' . ucfirst($element) . ' = "' . $element . '"', 2);
                    } else {
                        echoIndentCR('case ' . ucfirst($element) . ' = ' . $element . '', 2);
                    }
                }
                echoIndentCR('}', 1);
                echoIndentCR('public var ' . $name . ':' . $enumTypeName . '?', 1);
            } else if ($parameter->type == FlexionsTypes::COLLECTION) {
                echoIndentCR('public var ' . $name . ':[' . ucfirst($parameter->instanceOf) . ']?', 1);
            } else if ($parameter->type == FlexionsTypes::OBJECT) {
                echoIndentCR('public var ' . $name . ':' . ucfirst($parameter->instanceOf) . '?', 1);
            } else {
                $nativeType = FlexionsSwiftLang::nativeTypeFor($parameter->type);
                if (strpos($nativeType, FlexionsTypes::NOT_SUPPORTED) === false) {
                    echoIndentCR('public var ' . $name . ':' . $nativeType . '?', 1);
                } else {
                    echoIndentCR('public var ' . $name . ':Not_Supported = Not_Supported//' . ucfirst($parameter->type), 1);
                }
            }
        }
    }
    echo('
    required public init(){
        super.init()
    }
');
    $blockRepresentation = $d;
    // Mappable
    include FLEXIONS_MODULES_DIR . '/Bartleby/templates/blocks/Mappable.swift.block.php';
    // NSSecureCoding?
    if ($modelsShouldConformToNSCoding) {
        include FLEXIONS_MODULES_DIR . '/Bartleby/templates/blocks/NSSecureCoding.swift.block.php';
    }
    echoIndentCR("}",0);
}

?>



<?php
///////////////////////////////////
/// START OF END POINT EXEC CLASS
//////////////////////////////////
?>
@objc(<?php echo $d->class; ?>) open class <?php echo $d->class; ?> : <?php echo GenerativeHelperForSwift::getBaseClass($f,$d) ?>{

    // Universal type support
    override open class func typeName() -> String {
           return "<?php echo $d->class; ?>"
    }


    public static func execute(<?php
// We want to inject the path variable into the
$pathVariables=GenerativeHelper::variablesFromPath($d->path);
$pathVCounter=0;
$hasRegistryUID= in_array('registryUID',$pathVariables);
if (!$hasRegistryUID){
    echoIndentCR('fromRegistryWithUID registryUID:String,',$pathVCounter>0);
}

if(count($pathVariables)>0){
    foreach ($pathVariables as $pathVariable ) {
        if ($pathVariable=='registryUID'){
            $hasRegistryUID=true;
        }
        // Suspended
        echoIndentCR($pathVariable.':String,',6);
        $pathVCounter++;
    }
}

?>
<?php

$successP = $d->getSuccessResponse();
$successTypeString = '';
if ($successP->type == FlexionsTypes::COLLECTION) {
    $successTypeString = '['.$successP->instanceOf.']';
} else if ($successP->type == FlexionsTypes::OBJECT) {
    $successTypeString = ucfirst($successP->instanceOf);
} else if ($successP->type == FlexionsTypes::DICTIONARY) {
    $successTypeString = 'Dictionary<String, Any>';
}else {
    $nativeType = FlexionsSwiftLang::nativeTypeFor($successP->type);
    if($nativeType==FlexionsTypes::NOT_SUPPORTED){
        $successTypeString='';
    }else{
        $successTypeString=$nativeType;
    }
}

$resultSuccessIsACollection=($successP->type == FlexionsTypes::COLLECTION);
if($resultSuccessIsACollection){
    $successParameterName= Pluralization::pluralize(lcfirst($h->ucFirstRemovePrefixFromString($successP->instanceOf)));
}else{
    if($successP->isGeneratedType==true){
        $successParameterName=lcfirst($h->ucFirstRemovePrefixFromString($successTypeString));
    }else{
        $successParameterName='result';
    }
}


$resultSuccessTypeString=$successTypeString!=''?$successParameterName.':'.$successTypeString:'';
if ($d->containsParametersOutOfPath()) {
    echoIndentCR('parameters:' . $d->class . 'Parameters,' , 6);
    echoIndentCR('sucessHandler success:@escaping(_ ' . $resultSuccessTypeString . ')->(),', 6);
} else {
    echoIndentCR('sucessHandler success:@escaping(_ ' . $resultSuccessTypeString . ')->(),', 6);
}

// We want to inject the path variable
$pathVariables=GenerativeHelper::variablesFromPath($d->path);
$path= (strpos($d->path,'/')!==false) ? substr($d->path,1):$d->path;
if(count($pathVariables)>0){
    foreach ($pathVariables as $pathVariable ) {
        $path=str_ireplace('{'.$pathVariable.'}','\('.$pathVariable.')',$path);
    }
}
echoIndentCR('failureHandler failure:@escaping(_ context:JHTTPResponse)->()){', 6);
echoIndentCR('');
    $parametersString='';
    if ($d->containsParametersOutOfPath()) {
        $parametersString='[';
        while ($d->iterateOnParameters() === true) {
            $parameter = $d->getParameter();
            $name = $parameter->name;
            $parametersString.='"'.$name.'":parameters.'.$name;
            if($parameter->type==FlexionsTypes::ENUM) {
                $parametersString.='?.rawValue';
            }
            if (!$d->lastParameter()){
                $parametersString.=',';
            }
        }
        $parametersString.=']';
    }
// We need to parse the responses.

$status2XXHasBeenDefined=false;
$successMicroBlock=NULL;
ksort($d->responses); // We sort the key by codes
foreach ($d->responses as $rank=>$responsePropertyRepresentation ) {
    /* @var  $responsePropertyRepresentation PropertyRepresentation */
    $code = $responsePropertyRepresentation->name;
    if (strpos($code, '2') === 0) {
        // THERE SHOULD HAVE ONE 2XX HTTP CODE per endpoint
        // THE OTHER WILL CURRENTLY BE IGNORED
        // DEFINE AT LEAST ONE IF YOU WANT TO DETERMINE THE RESPONSE MODEL
        // ELSE IT WILL BE INFERRED
        // YOU CAN CHECK $successTypeString TO UNDERSTAND THE INFERENCE MECANISM
        if ($status2XXHasBeenDefined == false) {
            $status2XXHasBeenDefined = true;

            if($responsePropertyRepresentation->isGeneratedType) {
                // We wanna cast the result if there is one specified
                $successMicroBlock = stringIndent(
''.(

    ($resultSuccessIsACollection)?
'
                            if let string=result.value{
                                if let instance = Mapper <' . $successP->instanceOf . '>().mapArray(JSONString:string){'
                            :
        '
                            if let string=result.value{
                                if let instance = Mapper <' . $successTypeString . '>().map(JSONString:string){'
)
                                    .'
                                    success(instance)
                                }else{
                                    let failureReaction =  Bartleby.Reaction.dispatchAdaptiveMessage(
                                        context: context,
                                        title: NSLocalizedString("Deserialization issue",
                                        comment: "Deserialization issue"),
                                        body:"(result.value)",
                                        transmit:{ (selectedIndex) -> () in
                                    })
                                    reactions.append(failureReaction)
                                    failure(context)
                                }
                            }else{
                                let failureReaction =  Bartleby.Reaction.dispatchAdaptiveMessage(
                                    context: context,
                                    title: NSLocalizedString("No String Deserialization issue",
                                                             comment: "No String Deserialization issue"),
                                    body:"(result.value)",
                                    transmit: { (selectedIndex) -> () in
                                })
                                reactions.append(failureReaction)
                                failure(context)
                            }');

            }
        }
    }
}

if( !isset($successMicroBlock)){

    if($successTypeString==''){
        // there is no return type
        $successMicroBlock = 'success()';
    }else{
        $successMicroBlock ='

if let r=result.value as? ' . $successTypeString . '{
    success(r)
 }else{
    let failureReaction =  Bartleby.Reaction.dispatchAdaptiveMessage(
        context: context,
        title: NSLocalizedString("Deserialization issue",
            comment: "Deserialization issue"),
        body:"(result.value)",
        transmit:{ (selectedIndex) -> () in
    })
   reactions.append(failureReaction)
   failure(context)
}';
    }


}

$parameterEncodingString='JSON';
if($d->httpMethod=='GET'){
    $parameterEncodingString='URL';
}
echo('
        if let document = Bartleby.sharedInstance.getDocumentByUID(registryUID) {
            let pathURL=document.baseURL.appendingPathComponent("'.$path.'")
            '.(($d->containsParametersOutOfPath()?'let dictionary:Dictionary<String, Any>?=Mapper().toJSON(parameters)':'let dictionary:Dictionary<String, Any>=Dictionary<String, Any>()')).'
            let urlRequest=HTTPManager.requestWithToken(inRegistryWithUID:document.UID,withActionName:"'.$d->class.'" ,forMethod:"'.$d->httpMethod.'", and: pathURL)
            
            do {
                let r=try '.($parameterEncodingString=='JSON' ? 'JSONEncoding()' : 'URLEncoding()').'.encode(urlRequest,with:dictionary)
                request(r).responseString(completionHandler: { (response) in
                  
                    let request=response.request
                    let result=response.result
                    let response=response.response
            
                    // Bartleby consignation
            
                    let context = JHTTPResponse( code: '.crc32($d->class).',
                        caller: "'.$d->class.'.execute",
                        relatedURL:request?.url,
                        httpStatusCode: response?.statusCode ?? 0,
                        response: response,
                        result:result.value)
            
                    // React according to the situation
                    var reactions = Array<Bartleby.Reaction> ()
                    reactions.append(Bartleby.Reaction.track(result: result.value, context: context)) // Tracking
            
                    if result.isFailure {
                       let failureReaction =  Bartleby.Reaction.dispatchAdaptiveMessage(
                            context: context,
                            title: NSLocalizedString("Unsuccessfull attempt",comment: "Unsuccessfull attempt"),
                            body:NSLocalizedString("Explicit Failure",comment: "Explicit Failure"),
                            transmit:{ (selectedIndex) -> () in
                        })
                        reactions.append(failureReaction)
                        failure(context)
            
                    }else{
                        if let statusCode=response?.statusCode {
                              if 200...299 ~= statusCode {
'.
    $successMicroBlock
.
'                         }else{
                                // Bartlby does not currenlty discriminate status codes 100 & 101
                                // and treats any status code >= 300 the same way
                                // because we consider that failures differentiations could be done by the caller.
                                let failureReaction =  Bartleby.Reaction.dispatchAdaptiveMessage(
                                    context: context,
                                    title: NSLocalizedString("Unsuccessfull attempt",comment: "Unsuccessfull attempt"),
                                    body:NSLocalizedString("Implicit Failure",comment: "Implicit Failure"),
                                    transmit:{ (selectedIndex) -> () in
                                })
                               reactions.append(failureReaction)
                               failure(context)
                            }
                        }
                 }
                 //Let s react according to the context.
                 Bartleby.sharedInstance.perform(reactions, forContext: context)
            })
        }catch{
                let context = JHTTPResponse( code:2 ,
                caller: "<?php echo$baseClassName ?>.execute",
                relatedURL:nil,
                httpStatusCode:500,
                response:nil,
                result:"{\"message\":\"\(error)}")
                failure(context)
        }
      }else{
         let context = JHTTPResponse( code: 1,
                caller: "'.$d->class.'.execute",
                relatedURL:nil,
                httpStatusCode: 417,
                response: nil,
                result:"{\"message\":\"Unexisting document with registryUID \(registryUID)\"}")
         failure(context)
       }
    }
}
');
?><?php /*<- END OF TEMPLATE */ ?>#BMS#->{"filename":"Mappable.swift.block.php","checksum":11155918,"relativePath":"BartlebyFlexions\/src\/modules\/Bartleby\/templates\/blocks\/Mappable.swift.block.php","size":4196}<-#BME#
<?php

/*
 *
 * This is a Block template (not a full template)
 * That can be used to generate a NSCoding block in an entity.
 * $blockRepresentation must be set.
 *
 *  usage sample :
 *
 *      if( $modelsShouldConformToNSCoding ) {
 *          $blockRepresentation=$d // ActionRepresentation || EntityRepresentation
 *          include  FLEXIONS_MODULES_DIR.'/Bartleby/templates/blocks/Mappable.swift.block.php';
 *      }
 *
 */
require_once FLEXIONS_MODULES_DIR . '/Bartleby/templates/Requires.php';
require_once FLEXIONS_MODULES_DIR . 'Languages/FlexionsSwiftLang.php';


/* @var $f Flexed */
/* @var $blockRepresentation ActionRepresentation || EntityRepresentation */

/* @var $blockEndContent string */

if (!isset($blockRepresentation)){
    return NULL;
}

?>


    // MARK: Mappable

    required public init?(map: Map) {
        super.init(map:map)
    }

    override open func mapping(map: Map) {
        super.mapping(map: map)
        self.silentGroupedChanges {
<?php

// We use includes so we need to declare the functions once
if (!defined('MAPPABLE_BLOCK')){
    define('MAPPABLE_BLOCK',true);
    /* @var $property PropertyRepresentation */
    function mappable_block_property_Loop($property){
        $name = $property->name;
        if ($property->isSerializable==false){
            return;
        }
        if (!isset($property->customSerializationMapping)){
            // STANDARD MAPPING
            if ($property->type == FlexionsTypes::DATETIME){
                echoIndentCR('self.'.$name . ' <- ( map["' . $name . '"], ISO8601DateTransform() )', 3);
            } else if ($property->type == FlexionsTypes::URL) {
                echoIndentCR('self.'.$name . ' <- ( map["' . $name . '"], URLTransform() )', 3);
            }else if($property->type == FlexionsTypes::STRING ){
                if ($property->isCryptable){
                    echoIndentCR('self.'.$name . ' <- ( map["' . $name . '"], CryptedStringTransform() )', 3);
                }else{
                    echoIndentCR('self.'.$name . ' <- ( map["' . $name . '"] )', 3);
                }
            }else if($property->type == FlexionsTypes::DATA) {
                if ($property->isCryptable) {
                    echoIndentCR('self.' . $name . ' <- ( map["' . $name . '"], CryptedDataTransform() )', 3);
                } else {
                    echoIndentCR('self.' . $name . ' <- ( map["' . $name . '"], DataTransform() )', 3);
                }
            }else if ($property->isGeneratedType){
                if ($property->isCryptable){
                    echoIndentCR('self.' . $name . ' <- ( map["' . $name . '"], CryptedSerializableTransform() )', 3);
                }else {
                    echoIndentCR('self.' . $name . ' <- ( map["' . $name . '"] )', 3);
                }
            }else{
                if ($property->isCryptable){
                    echoIndentCR('self.' . $name . ' <- ( map["' . $name . '"] )// @todo marked generatively as Cryptable Should be crypted!', 3);
                }else {
                    echoIndentCR('self.' . $name . ' <- ( map["' . $name . '"] )', 3);
                }

            }

        }else{
            // RECURSIVE CALL FOR CUSTOMSERIALIZATION
            foreach ($property->customSerializationMapping as $property) {
                mappable_block_property_Loop($property);
            }
        }
    }
}

// Mappable support for entities and parameters classes.
// $d may be ActionRepresentation or EntityRepresentation
$isEntity=($blockRepresentation instanceof EntityRepresentation);
while ($isEntity?$blockRepresentation->iterateOnProperties():$blockRepresentation->iterateOnParameters() === true) {
    /* @var $property PropertyRepresentation */
    $property = $isEntity?$blockRepresentation->getProperty():$blockRepresentation->getParameter();
    mappable_block_property_Loop($property);
}

if (isset($blockEndContent)){
    echoIndentCR($blockEndContent, 3);
}
if (strpos($blockRepresentation->name,"CollectionController")!==false){
    echo('          if map.mappingType == .fromJSON {
                forEach { $0.collection=self }
            }
');
}
?>
        }
    }

<?php // End of Block ?>#BMS#->{"filename":"NSSecureCoding.swift.block.php","checksum":4077339361,"relativePath":"BartlebyFlexions\/src\/modules\/Bartleby\/templates\/blocks\/NSSecureCoding.swift.block.php","size":1404}<-#BME#
<?php

/*
 *
 * This is a Block template (not a full template)
 * That can be used to generate a NSCoding block in an entity.
 * $blockRepresentation must be set.
 *
 *  usage sample :
 *
 *      if( $modelsShouldConformToNSCoding ) {
 *          $blockRepresentation=$d // ActionRepresentation || EntityRepresentation
 *          include  FLEXIONS_MODULES_DIR.'/Bartleby/templates/blocks/NSSecureCoding.swift.block.php';
 *      }
 *
 */

require_once FLEXIONS_MODULES_DIR . '/Bartleby/templates/Requires.php';
require_once FLEXIONS_MODULES_DIR . 'Languages/FlexionsSwiftLang.php';


/* @var $f Flexed */
/* @var $blockRepresentation ActionRepresentation || EntityRepresentation */
/* @var $blockEndContent string */

if (!isset($blockRepresentation)){
    return NULL;
}

?>

    // MARK: NSSecureCoding

    required public init?(coder decoder: NSCoder) {
        super.init(coder: decoder)
        self.silentGroupedChanges {
<?php GenerativeHelperForSwift::echoBodyOfInitWithCoder($blockRepresentation, 3);
    if (isset($blockEndContent)){
        echoIndentCR($blockEndContent, 3);
    }
    ?>
        }
    }

    override open func encode(with coder: NSCoder) {
        super.encode(with:coder)
<?php GenerativeHelperForSwift::echoBodyOfEncodeWithCoder($blockRepresentation, 2);?>
    }

    override open class var supportsSecureCoding:Bool{
        return true
    }

<?php // End of Block ?>#BMS#->{"filename":"model.php.template.php","checksum":2190756060,"relativePath":"BartlebyFlexions\/src\/modules\/Bartleby\/templates\/entities\/model.php.template.php","size":4744}<-#BME#
<?php

require_once FLEXIONS_MODULES_DIR . '/Bartleby/templates/Requires.php';


/* @var $f Flexed */
/* @var $d EntityRepresentation */

if (isset ( $f )) {
    $classNameWithoutPrefix=ucfirst(substr($d->name,strlen($h->classPrefix)));
    $f->fileName = $classNameWithoutPrefix.'.php';
    $f->package = 'php/api/'.$h->majorVersionPathSegmentString().'_generated/Models/';
}


// Exclusion

$exclusion = array();
$exclusionName = str_replace($h->classPrefix, '', $d->name);

if (isset($excludeEntitiesWith)) {
    $exclusion = $excludeEntitiesWith;
}
foreach ($exclusion as $exclusionString) {
    if (strpos($exclusionName, $exclusionString) !== false) {
        return NULL; // We return null
    }
}



/* TEMPLATES STARTS HERE -> */?><?php echo '<?php'?>
<?php echo GenerativeHelperForPhp::defaultHeader($f,$d); ?>
namespace Bartleby\Models;

require_once BARTLEBY_ROOT_FOLDER.'Core/Model.php';
require_once BARTLEBY_PUBLIC_FOLDER . 'Configuration.php';

use Bartleby\Core\Model;
<?php
$hasBeenImported=array();
while ($d->iterateOnProperties()){
    $property=$d->getProperty();
    if($property->isGeneratedType){
        $className=$property->instanceOf;
        $className=$h->ucFirstRemovePrefixFromString($className);

        /*
            Bartleby swift uses Alias<T> to resolve typed external reference
         */

        $genericMarker='\<';
        $genericRes=preg_replace('/<(.*)>/','$0',$className);
        if (preg_match('/^(.*)'.$genericMarker.'/', $className, $matches)) {
            $className = $matches[1];
        }
        $notGenerated=array('Alias');

        if (! in_array($className,$hasBeenImported)) {
            if (in_array($className,$notGenerated)){
                echoIndentCR('require_once BARTLEBY_ROOT_FOLDER.\'/Commons/Models/'.$className.'.php\';',0);
            }else{
                if ($className!=='Dictionary'){
                    echoIndentCR('require_once __DIR__.\'/'.$className.'.php\';',0);
                }
            }
            echoIndentCR('use Bartleby\Models\\'.$className.';//'.$genericRes,0);
            $hasBeenImported[]=$className;
        }

    }
} ?>

class <?php echo $classNameWithoutPrefix?> extends Model{

<?php
/* @var $property PropertyRepresentation */

// You can distinguish the first, and last property
while ( $d ->iterateOnProperties() === true ) {
    $property = $d->getProperty();
    $name=$property->name;
    $typeOfProp=$property->type;
    $o=FlexionsTypes::OBJECT;
    $c=FlexionsTypes::COLLECTION;
    if (($typeOfProp===$o)||($typeOfProp===$c)) {
        $typeOfProp = $h->ucFirstRemovePrefixFromString($property->instanceOf);
        if($typeOfProp==$c){
            $typeOfProp=' array of '.$typeOfProp;
        }
    }
    if($property->type==FlexionsTypes::ENUM){
        $enumTypeName=ucfirst($name);
        $typeOfProp=$property->instanceOf.' '.$typeOfProp;
        echoIndentCR('// Enumeration of possibles values of '.$name, 1);
        $enumCounter=0;
        foreach ($property->enumerations as $element) {
            if($property->instanceOf==FlexionsTypes::STRING){
                echoIndentCR('const ' .$enumTypeName.'_'.ucfirst($element).' = "'.$element.'";' ,1);
            }else if($property->instanceOf==FlexionsTypes::INTEGER){
                echoIndentCR('const ' .$enumTypeName.'_'.ucfirst($element).' = '.$enumCounter.';', 1);
                $enumCounter++;
            }else{
                echoIndentCR('const ' .$enumTypeName.'_'.ucfirst($element).' = '.$element.';', 1);
            }
        }
    }
    echoIndentCR('/* @var '.$typeOfProp.' '.$property->description.' */',1);
    if($d->firstProperty()){
        echoIndentCR('public $'.$name.';',1);
    }else if ($d->lastProperty()){
        echoIndent('public $'.$name.';',1);
    }else{
        echoIndentCR('public $'.$name.';',1);
    };
    echoIndentCR('',0);

    if($d->lastProperty()){
        echoIndent(cr(),0);
    }
}
?>


    function classMapping(array $mapping=array()){
<?php while ($d->iterateOnProperties()){
    $property=$d->getProperty();
    $typeOfProp=$property->type;
    $o=FlexionsTypes::OBJECT;
    $c=FlexionsTypes::COLLECTION;
    if (($typeOfProp===$o)||($typeOfProp===$c)) {
        $type = $property->instanceOf;
        if ($property->isGeneratedType) {
            $type = $h->ucFirstRemovePrefixFromString($type);
        }
        if ($property->type == FlexionsTypes::COLLECTION) {
            echoIndentCR('$mapping[\'' . $property->name . '\']=array(\'' . $type . '\');', 2);
        } else {
            echoIndentCR('$mapping[\'' . $property->name . '\']=\'' . $type . '\';', 2);
        }
    }


}?>
        return parent::classMapping($mapping);
    }

}

<?php echo '?>'?><?php /*<- END OF TEMPLATE */?>#BMS#->{"filename":"model.swift.template.php","checksum":3149611976,"relativePath":"BartlebyFlexions\/src\/modules\/Bartleby\/templates\/entities\/model.swift.template.php","size":6055}<-#BME#
<?php

require_once FLEXIONS_MODULES_DIR . '/Bartleby/templates/Requires.php';
require_once FLEXIONS_MODULES_DIR . 'Languages/FlexionsSwiftLang.php';

/* @var $f Flexed */
/* @var $d EntityRepresentation */

if (isset ( $f )) {
    // We determine the file name.
    $f->fileName = GenerativeHelperForSwift::getCurrentClassNameWithPrefix($d).'.swift';
    // And its package.
    $f->package = 'xOS/models/';
}

// Exclusion

$exclusion = array();
$exclusionName = str_replace($h->classPrefix, '', $d->name);

if (isset($excludeEntitiesWith)) {
    $exclusion = $excludeEntitiesWith;
}
foreach ($exclusion as $exclusionString) {
    if (strpos($exclusionName, $exclusionString) !== false) {
        return NULL; // We return null
    }
}

if (!defined('_propertyValueString_DEFINED')){
    define("_propertyValueString_DEFINED",true);
    function _propertyValueString(PropertyRepresentation $property){
        if ($property->isSupervisable===false){

            ////////////////////////////
            // Property isn't supervisable
            ////////////////////////////
            if(isset($property->default)){
                if($property->type==FlexionsTypes::STRING){
                    return " = \"$property->default\"";
                }else{
                    return " = $property->default";
                }
            }
            return "?";
        }else{
            //////////////////////////
            // Property is supervisable
            //////////////////////////
        if(isset($property->default)){
            if($property->type==FlexionsTypes::STRING){
                return " = \"$property->default\"{\n 
    didSet { 
       if $property->name != oldValue {
            self.provisionChanges(forKey: \"$property->name\",oldValue: oldValue,newValue: $property->name) 
       } 
    }
}";
            }else{
                return " = $property->default  {\n 
    didSet { 
       if $property->name != oldValue {
            self.provisionChanges(forKey: \"$property->name\",oldValue: oldValue".($property->type==FlexionsTypes::ENUM ? ".rawValue" : "" ).",newValue: $property->name".($property->type==FlexionsTypes::ENUM ? ".rawValue" : "" ).")  
       } 
    }
}";
}

        }
        return "? {\n 
    didSet { 
       if $property->name != oldValue {
            self.provisionChanges(forKey: \"$property->name\",oldValue: oldValue".($property->type==FlexionsTypes::ENUM ? "?.rawValue" : "" ).",newValue: $property->name".( $property->type==FlexionsTypes::ENUM ? "?.rawValue" : "" ) .") 
       } 
    }
}";
        }
    }
}


/* TEMPLATES STARTS HERE -> */?>
<?php echo GenerativeHelperForSwift::defaultHeader($f,$d); ?>

import Foundation
#if !USE_EMBEDDED_MODULES
<?php
if (isset($isIncludeInBartlebysCommons) && $isIncludeInBartlebysCommons==true){
    echoIndentCR("import Alamofire",0);
    echoIndentCR("import ObjectMapper",0);
}else{
    echoIndentCR("import Alamofire",0);
    echoIndentCR("import ObjectMapper",0);
    echoIndentCR("import BartlebyKit",0);
}
?>
#endif

// MARK: <?php echo $d->description?>

@objc(<?php echo ucfirst($d->name)?>) open class <?php echo ucfirst($d->name)?> : <?php echo GenerativeHelperForSwift::getBaseClass($f,$d); ?>{

    // Universal type support
    override open class func typeName() -> String {
        return "<?php echo ucfirst($d->name)?>"
    }

<?php

while ( $d ->iterateOnProperties() === true ) {
    $property = $d->getProperty();
    $name = $property->name;
    $dynanicString=($property->isDynamic ? 'dynamic ':'');
    if($property->description!=''){
        echoIndentCR('//' .$property->description. cr(), 1);
    }
    if($property->type==FlexionsTypes::ENUM){
        $enumTypeName=ucfirst($name);
        echoIndentCR($dynanicString.'public enum ' .$enumTypeName.':'.ucfirst(FlexionsSwiftLang::nativeTypeFor($property->instanceOf)). '{', 1);
        foreach ($property->enumerations as $element) {
            if($property->instanceOf==FlexionsTypes::STRING){
                echoIndentCR('case ' .lcfirst($element).' = "'.$element.'"', 2);
            }elseif ($property->instanceOf==FlexionsTypes::INTEGER){
                echoIndentCR('case ' .lcfirst($element), 2);
            } else{
                echoIndentCR('case ' .lcfirst($element).' = '.$element, 2);
            }
        }
        echoIndentCR('}', 1);
        echoIndentCR($dynanicString.'open var ' . $name .':'.$enumTypeName._propertyValueString($property), 1);
    }else if($property->type==FlexionsTypes::COLLECTION){
        $instanceOf=FlexionsSwiftLang::nativeTypeFor($property->instanceOf);
        if ($instanceOf==FlexionsTypes::NOT_SUPPORTED){
            $instanceOf=$property->instanceOf;
        }
        echoIndentCR($dynanicString.'open var ' . $name .':['.ucfirst($instanceOf). ']'._propertyValueString($property), 1);
    }else if($property->type==FlexionsTypes::OBJECT){
        echoIndentCR($dynanicString.'open var ' . $name .':'.ucfirst($property->instanceOf)._propertyValueString($property), 1);
    }else{
        $nativeType=FlexionsSwiftLang::nativeTypeFor($property->type);
        if(strpos($nativeType,FlexionsTypes::NOT_SUPPORTED)===false){
            echoIndentCR($dynanicString.'open var ' . $name .':'.$nativeType._propertyValueString($property), 1);
        }else{
            echoIndentCR($dynanicString.'open var ' . $name .':Not_Supported = Not_Supported()//'. ucfirst($property->type), 1);
        }
    }
}

$blockRepresentation=$d;
include  FLEXIONS_MODULES_DIR.'Bartleby/templates/blocks/Mappable.swift.block.php';
if( $modelsShouldConformToNSCoding ) {
    include  FLEXIONS_MODULES_DIR.'Bartleby/templates/blocks/NSSecureCoding.swift.block.php';
}
?>

    required public init() {
        super.init()
    }

    // MARK: Identifiable

    override open class var collectionName:String{
        return "<?php echo lcfirst(Pluralization::pluralize($d->name)) ?>"
    }

    override open var d_collectionName:String{
        return <?php echo ucfirst($d->name)?>.collectionName
    }


}

<?php /*<- END OF TEMPLATE */?>#BMS#->{"filename":"modelCollectionController.swift.template.php","checksum":3882259906,"relativePath":"BartlebyFlexions\/src\/modules\/Bartleby\/templates\/entities\/modelCollectionController.swift.template.php","size":17305}<-#BME#
<?php

require_once FLEXIONS_MODULES_DIR . '/Bartleby/templates/Requires.php';
require_once FLEXIONS_MODULES_DIR . 'Languages/FlexionsSwiftLang.php';

/* @var $f Flexed */
/* @var $d EntityRepresentation*/
/* @var $h Hypotypose */


if (isset( $f,$d,$h)) {
    // We use explicit name (!)
    // And reserve $f , $d , $h possibly for blocks

    /* @var $flexed Flexed*/
    /* @var $entityRepresentation EntityRepresentation*/
    /* @var $hypotypose Hypotypose*/

    $flexed=$f;
    $entityRepresentation=$d;
    $hypotypose=$h;

    // We determine the file name.
    $f->fileName = ucfirst(Pluralization::pluralize($d->name)) . 'CollectionController.swift';
    // And its package.
    $f->package = 'xOS/collectionControllers/';

}else{
    return NULL;
}

$usesUrdMode=$d->usesUrdMode()==true;

// Exclusion -

//Collection controllers are related to actions.

$exclusion = array();
$exclusionName = str_replace($h->classPrefix, '', $entityRepresentation->name);

$includeCollectionController = false;
if (isset($xOSIncludeCollectionControllerForEntityNamed)) {
    foreach ($xOSIncludeCollectionControllerForEntityNamed as $inclusion) {
        if (strpos($exclusionName, $inclusion) !== false) {
            $includeCollectionController = true;
        }

    }
    if (!$includeCollectionController) {
        if (isset($excludeActionsWith)) {
            $exclusion = $excludeActionsWith;
        }
        foreach ($exclusion as $exclusionString) {
            if (strpos($exclusionName, $exclusionString) !== false) {
                return NULL; // We return null
            }
        }
    }
}


$collectionControllerClass=ucfirst(Pluralization::pluralize($entityRepresentation->name)).'CollectionController';

/* TEMPLATES STARTS HERE -> */?>
<?php echo GenerativeHelperForSwift::defaultHeader($f,$entityRepresentation); ?>

import Foundation
#if os(OSX)
import AppKit
#endif
#if !USE_EMBEDDED_MODULES
<?php
if (isset($isIncludeInBartlebysCommons) && $isIncludeInBartlebysCommons==true){
    echoIndent(cr(),0);
    echoIndentCR("import Alamofire",0);
    echoIndentCR("import ObjectMapper",0);
}else{
    echoIndentCR(cr(),0);
    echoIndentCR("import Alamofire",0);
    echoIndentCR("import ObjectMapper",0);
    echoIndentCR("import BartlebyKit",0);
}
?>
#endif

// MARK: A  collection controller of "<?php echo lcfirst(Pluralization::pluralize($entityRepresentation->name)); ?>"

// This controller implements data automation features.

@objc(<?php echo $collectionControllerClass ?>) open class <?php echo $collectionControllerClass ?> : <?php echo GenerativeHelperForSwift::getBaseClass($f,$entityRepresentation); ?>,IterableCollectibleCollection{

    // Universal type support
    override open class func typeName() -> String {
        return "<?php echo $collectionControllerClass ?>"
    }

    open var spaceUID:String {
        get{
            return self.document?.spaceUID ?? Default.NO_UID
        }
    }

    open var registryUID:String{
        get{
            return self.document?.UID ?? Default.NO_UID
        }
    }

    /// Init with prefetched content
    ///
    /// - parameter items: itels
    ///
    /// - returns: the instance
    required public init(items:[<?php echo ucfirst($entityRepresentation->name)?>]) {
        super.init()
        self.items=items
    }

    required public init() {
        super.init()
    }

    weak open var undoManager:UndoManager?

    #if os(OSX) && !USE_EMBEDDED_MODULES

    // We auto configure most of the array controller.
    open weak var arrayController:NSArrayController? {
        didSet{
            self.document?.setValue(self, forKey: "<?php echo lcfirst(Pluralization::pluralize($entityRepresentation->name)); ?>")
            arrayController?.objectClass=<?php echo ucfirst($entityRepresentation->name)?>.self
            arrayController?.entityName=<?php echo ucfirst($entityRepresentation->name)?>.className()
            arrayController?.bind("content", to: self, withKeyPath: "items", options: nil)
        }
    }

    #endif

    weak open var tableView: BXTableView?

    // The underling items storage
    fileprivate dynamic var items:[<?php echo ucfirst($entityRepresentation->name)?>]=[<?php echo ucfirst($entityRepresentation->name)?>](){
        didSet {
            if items != oldValue {
                self.provisionChanges(forKey: "items",oldValue: oldValue,newValue: items)
            }
        }
    }

    open func generate() -> AnyIterator<<?php echo ucfirst($entityRepresentation->name)?>> {
        var nextIndex = -1
        let limit=self.items.count-1
        return AnyIterator {
            nextIndex += 1
            if (nextIndex > limit) {
                return nil
            }
            return self.items[nextIndex]
        }
    }


    open subscript(index: Int) -> <?php echo ucfirst($entityRepresentation->name)?> {
        return self.items[index]
    }

    open var startIndex:Int {
        return 0
    }

    open var endIndex:Int {
        return self.items.count
    }

    /// Returns the position immediately after the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    open func index(after i: Int) -> Int {
        return i+1
    }


    open var count:Int {
        return self.items.count
    }

    open func indexOf(element:@escaping(<?php echo ucfirst($entityRepresentation->name)?>) throws -> Bool) rethrows -> Int?{
        return self._getIndexOf(element as! Collectible)
    }

    open func item(at index:Int)->Collectible?{
        return self[index]
    }


    fileprivate func _getIndexOf(_ item:Collectible)->Int?{
        if item.collectedIndex >= 0 {
            return item.collectedIndex
        }else{
            if let idx=items.index(where:{return $0.UID == item.UID}){
                self[idx].collectedIndex=idx
                return idx
            }
        }
        return nil
    }

    fileprivate func _incrementIndexes(greaterThan lowerIndex:Int){
        let count=items.count
        if count > lowerIndex{
            for i in lowerIndex...count-1{
                self[i].collectedIndex += 1
            }
        }
    }

    fileprivate func _decrementIndexes(greaterThan lowerIndex:Int){
        let count=items.count
        if count > lowerIndex{
            for i in lowerIndex...count-1{
                self[i].collectedIndex -= 1
            }
        }
    }
    /**
    An iterator that permit dynamic approaches.
    The Registry ignores the real types.
    - parameter on: the closure
    */
    open func superIterate(_ on:@escaping(_ element: Collectible)->()){
        for item in self.items {
            on(item)
        }
    }

<?php if ($entityRepresentation->isDistantPersistencyOfCollectionAllowed()) {

   if ($entityRepresentation->groupedOnCommit()){
       echo('
    /**
    Commit all the changes in one bunch
    Marking commit on each item will toggle hasChanged flag.
    */
    open func commitChanges() -> [String] {
        var UIDS=[String]()
        if self.toBeCommitted{ // When one member has to be committed its collection _shouldBeCommited flag is turned to true
            let changedItems=self.items.filter { $0.toBeCommitted == true }
            bprint("\(changedItems.count) \( changedItems.count>1 ? "'.lcfirst(Pluralization::pluralize($entityRepresentation->name)).'" : "'.lcfirst($entityRepresentation->name).'" )  has changed in '.$collectionControllerClass.'",file:#file,function:#function,line:#line,category: Default.BPRINT_CATEGORY)
            if  changedItems.count > 0 {
                UIDS=changedItems.map({$0.UID})
               '.($usesUrdMode?'Upsert':'Update'). ucfirst(Pluralization::pluralize($entityRepresentation->name)) . '.commit(changedItems,inRegistryWithUID:self.registryUID)
            }
            self.committed=true
         }
        return UIDS
    }
');
   }else{
       echo('
    /**
    Commit all the changes in one bunch
    Marking commit on each item will toggle hasChanged flag.
    */
    open func commitChanges() -> [String] {
        var UIDS=[String]()
        if self.toBeCommitted{ // When one member has to be committed its collection _shouldBeCommited flag is turned to true
            let changedItems=self.items.filter { $0.toBeCommitted == true }
            bprint("\(changedItems.count) \( changedItems.count>1 ? "'.lcfirst(Pluralization::pluralize($entityRepresentation->name)).'" : "'.lcfirst($entityRepresentation->name).'" )  has changed in '.$collectionControllerClass.'",file:#file,function:#function,line:#line,category: Default.BPRINT_CATEGORY)
            for changed in changedItems{
                UIDS.append(changed.UID)
                '.($usesUrdMode?'Upsert':'Update'). ucfirst($entityRepresentation->name) . '.commit(changed, inRegistryWithUID:self.registryUID)
            }
            self.committed=true
        }
        return UIDS
    }
');
   }




}else{
echo('

    /**
     Commit is ignored because
     Distant persistency is not allowed for '.$entityRepresentation->name.'
    */
    open func commitChanges() ->[String] {
        return [String]()
    }
    
');
}
?>

    // MARK: Identifiable

    override open class var collectionName:String{
        return <?php echo ucfirst($entityRepresentation->name)?>.collectionName
    }

    override open var d_collectionName:String{
        return <?php echo ucfirst($entityRepresentation->name)?>.collectionName
    }

<?php


    // We just want to inject an item property Items
    $virtualEntity=new EntityRepresentation();
    $virtualEntity->name=$collectionControllerClass;
    $itemsProperty=new PropertyRepresentation();
    $itemsProperty->name="items";
    $itemsProperty->type=FlexionsTypes::COLLECTION;
    $itemsProperty->instanceOf=ucfirst($entityRepresentation->name);
    $itemsProperty->required=true;
    $itemsProperty->isDynamic=true;
    $itemsProperty->default=NULL;
    $itemsProperty->isGeneratedType=true;

    $virtualEntity->properties[]=$itemsProperty;
    $blockRepresentation=$virtualEntity;

$blockEndContent="";// This is injected in the block
include  FLEXIONS_MODULES_DIR.'Bartleby/templates/blocks/Mappable.swift.block.php';
if( $modelsShouldConformToNSCoding ) {
    include  FLEXIONS_MODULES_DIR.'Bartleby/templates/blocks/NSSecureCoding.swift.block.php';
}?>



    // MARK: Upsert

    open func upsert(_ item: Collectible, commit:Bool){

        if let idx=items.index(where:{return $0.UID == item.UID}){
            // it is an update
            // we must patch it
            let currentInstance=items[idx]
            if commit==false{
                // When upserting from a trigger
                // We do not want to produce Larsen effect on data.
                // So we lock the auto commit observer before applying the patch
                // And we unlock the autoCommit Observer after the patch.
                currentInstance.disableAutoCommit()
            }

            let dictionary=item.dictionaryRepresentation()
            currentInstance.patchFrom(dictionary)
            if commit==false{
                currentInstance.enableAutoCommit()
            }
        }else{
            // It is a creation
            self.add(item, commit:commit)
        }
    }

    // MARK: Add


    open func add(_ item:Collectible, commit:Bool){
        self.insertObject(item, inItemsAtIndex: items.count, commit:commit)
    }

    // MARK: Insert

    /**
    Inserts an object at a given index into the collection.

    - parameter item:   the item
    - parameter index:  the index in the collection (not the ArrayController arranged object)
    - parameter commit: should we commit the insertion?
    */
    open func insertObject(_ item: Collectible, inItemsAtIndex index: Int, commit:Bool) {
        if let item=item as? <?php echo ucfirst($entityRepresentation->name)?>{

            item.collection = self // Reference the collection
            item.collectedIndex = index // Update the index
            self._incrementIndexes(greaterThan:index)

<?php if ($entityRepresentation->isUndoable()) {
    echo('
            if let undoManager = self.undoManager{
                // Has an edit occurred already in this event?
                if undoManager.groupingLevel > 0 {
                    // Close the last group
                    undoManager.endUndoGrouping()
                    // Open a new group
                    undoManager.beginUndoGrouping()
                }
            }

            // Add the inverse of this invocation to the undo stack
            if let undoManager: UndoManager = undoManager {
                (undoManager.prepare(withInvocationTarget: self) as AnyObject).removeObjectFromItemsAtIndex(index, commit:commit)
                if !undoManager.isUndoing {
                    undoManager.setActionName(NSLocalizedString("Add' . ucfirst($entityRepresentation->name) . '", comment: "Add' . ucfirst($entityRepresentation->name) . ' undo action"))
                }
            }
            ');
}
?>
            // Insert the item
            self.items.insert(item, at: index)
            #if os(OSX) && !USE_EMBEDDED_MODULES
            if let arrayController = self.arrayController{

                // Re-arrange (in case the user has sorted a column)
                arrayController.rearrangeObjects()

                if let tableView = self.tableView{
                    DispatchQueue.main.async(execute: {
                        let sorted=self.arrayController?.arrangedObjects as! [<?php echo ucfirst($entityRepresentation->name)?>]
                        // Find the object just added
                        if let row=sorted.index(where:{ $0.UID==item.UID }){
                            // Start editing
                            tableView.editColumn(0, row: row, with: nil, select: true)
                        }
                    })
                }
            }
            #endif

<?php if ($entityRepresentation->isDistantPersistencyOfCollectionAllowed()){
    echo("
            if item.committed==false && commit==true{
               ".($usesUrdMode?'Upsert':'Create').$entityRepresentation->name.".commit(item, inRegistryWithUID:self.registryUID)
            }".cr());
}else{
        echo('
            // Commit is ignored because
            // Distant persistency is not allowed for '.$entityRepresentation->name.'
            ');
}
?>

        }else{

        }
    }




    // MARK: Remove

    /**
    Removes an object at a given index from the collection.

    - parameter index:  the index in the collection (not the ArrayController arranged object)
    - parameter commit: should we commit the removal?
    */
    open func removeObjectFromItemsAtIndex(_ index: Int, commit:Bool) {
       let item : <?php echo ucfirst($entityRepresentation->name)?> =  self[index]
        self._decrementIndexes(greaterThan:index)
<?php if ($entityRepresentation->isUndoable()) {
echo(
'
        // Add the inverse of this invocation to the undo stack
        if let undoManager: UndoManager = undoManager {
            // We don\'t want to introduce a retain cycle
            // But with the objc magic casting undoManager.prepareWithInvocationTarget(self) as? UsersCollectionController fails
            // That\'s why we have added an registerUndo extension on UndoManager
            undoManager.registerUndo({ () -> Void in
               self.insertObject(item, inItemsAtIndex: index, commit:commit)
            })
            if !undoManager.isUndoing {
                undoManager.setActionName(NSLocalizedString("Remove' . ucfirst($entityRepresentation->name) . '", comment: "Remove ' . ucfirst($entityRepresentation->name) . ' undo action"))
            }
        }
        ');
}
?>

        // Unregister the item
        Registry.unRegister(item)

        //Update the commit flag
        item.committed=false

        // Remove the item from the collection
        self.items.remove(at:index)

    <?php if ($entityRepresentation->isDistantPersistencyOfCollectionAllowed()) {
        echo('
        if commit==true{
            Delete'.$entityRepresentation->name.'.commit(item.UID,fromRegistryWithUID:self.registryUID) 
        }'.cr());
    }else{
        echo('
        // Commit is ignored because
        // Distant persistency is not allowed for '.$entityRepresentation->name.'
        ');
    }
    ?>
    }


    open func removeObjects(_ items: [Collectible],commit:Bool){
        for item in self.items{
            self.removeObject(item,commit:commit)
        }
    }

    open func removeObject(_ item: Collectible, commit:Bool){
        if let instance=item as? <?php echo(ucfirst($entityRepresentation->name))?>{
            if let idx=self._getIndexOf(instance){
                self.removeObjectFromItemsAtIndex(idx, commit:commit)
            }
        }
    }

    open func removeObjectWithIDS(_ ids: [String],commit:Bool){
        for uid in ids{
            self.removeObjectWithID(uid,commit:commit)
        }
    }

    open func removeObjectWithID(_ id:String, commit:Bool){
        if let idx=self.index(where:{ return $0.UID==id } ){
            self.removeObjectFromItemsAtIndex(idx, commit:commit)
        }
    }

}#BMS#->{"filename":"filePrototypeTemplate.php","checksum":2506251213,"relativePath":"BartlebyFlexions\/src\/modules\/Bartleby\/templates\/filePrototypeTemplate.php","size":319}<-#BME#
<?php

/*
 * This template can be used to copy prototype files.
 */

require_once FLEXIONS_MODULES_DIR . 'Bartleby/templates/Requires.php';


if (isset($f,$filemame,$package,$prototypePath)){
    $f->fileName = $filemame;
    $f->package = $package;
    echo file_get_contents($prototypePath);
}else{
    return NULL;
}#BMS#->{"filename":"commons.configuration.php.template.php","checksum":1889562688,"relativePath":"BartlebyFlexions\/src\/modules\/Bartleby\/templates\/project\/commons.configuration.php.template.php","size":15272}<-#BME#
<?php

require_once FLEXIONS_MODULES_DIR . '/Bartleby/templates/Requires.php';

/* @var $f Flexed */
/* @var $d ProjectRepresentation */


if (isset ( $f )) {
    $f->fileName = 'BartlebyCommonsConfiguration.php';
    $f->package = 'php/_generated/';
}
/* TEMPLATES STARTS HERE -> */?>
<?php echo '<?php'?>
<?php echo GenerativeHelperForPhp::defaultHeader($f,$d); ?>

// SHARED CONFIGURATION BETWEEN THE API & MAIN PAGES

namespace Bartleby;

require_once BARTLEBY_ROOT_FOLDER . 'Mongo/MongoConfiguration.php';
require_once BARTLEBY_ROOT_FOLDER . 'Core/RoutesAliases.php';
require_once BARTLEBY_ROOT_FOLDER . 'Commons/Filters/FilterEntityPasswordRemover.php';
require_once BARTLEBY_ROOT_FOLDER . 'Commons/Filters/FilterCollectionOfEntityPasswordsRemover.php';
require_once BARTLEBY_ROOT_FOLDER . 'Commons/Filters/FilterHookByClosure.php';
require_once BARTLEBY_ROOT_FOLDER . 'Core/KeyPath.php';
require_once BARTLEBY_ROOT_FOLDER . 'Core/Stages.php';
require_once BARTLEBY_ROOT_FOLDER . 'Core/Mode.php';


use Bartleby\Core\Mode;
use Bartleby\Core\RoutesAliases;
use Bartleby\Core\Stages;
use Bartleby\Mongo\MongoConfiguration;
use Bartleby\Core\KeyPath;
use Bartleby\Filters\FilterCollectionOfEntityPasswordsRemover;
use Bartleby\Filters\FilterEntityPasswordRemover;
use Bartleby\Filters\FilterHookByClosure;

use \MongoClient;
use \MongoCursorException;
use \MongoDB;


class BartlebyCommonsConfiguration extends MongoConfiguration {


    /**
    * The constructor
    * @param string $executionDirectory
    * @param string $bartlebyRootDirectory
    * @param $runMode
    */
    public function __construct($executionDirectory,$bartlebyRootDirectory,$runMode = Mode::API){
        parent::__construct($executionDirectory,$bartlebyRootDirectory,$runMode);
        $this->_configureFilters();
        $this->_configurePermissions();
        $this->_configuresFixedPaths();
    }

    private function  _configuresFixedPaths(){
        // We force the resolution
        // So You can Overload the standard path and define a fixed One
        // To to so you can call `definePath`:
        // $this->definePath("ClassName", $this->_bartlebyRootDirectory . 'Commons/Overloads/EndPoints/ClassName.php');`

        // (!) IMPORTANT
        // If you put files in the Overloads folder that extends an existing class.
        // The nameSpace of the Overload must be post fixed with \Overloads
        // Check UpdateUser for a sample.

        // Update user(s) overload for security purposes.
        $this->definePath("UpdateUser", $this->_bartlebyRootDirectory . 'Commons/Overloads/EndPoints/UpdateUser.php');
        $this->definePath("UpdateUsers", $this->_bartlebyRootDirectory . 'Commons/Overloads/EndPoints/UpdateUsers.php');
    }

    private function _configureFilters(){

        //NEVER DISCLOSE THE PASSWORDS!

        $filterReadUser=new FilterEntityPasswordRemover();
        $filterReadUser->passwordKeyPath='password';
        $this->addFilterOut('ReadUserById->call',$filterReadUser);

        $filterReadUsers=new FilterCollectionOfEntityPasswordsRemover();
        $filterReadUsers->passwordKeyPath='password';// Each entity has directly a "password" key
        $filterReadUsers->iterableCollectionKeyPath=NULL;// the response is a collection.
        $this->addFilterOut('ReadUsersByIds->call',$filterReadUsers);


        // Salt the passwords on Create and Update

        $data=NULL;// Dummy data for the IDE

        $filterCreateUser=new FilterHookByClosure();
        $filterCreateUser->closure=function($data) {
            $password=KeyPath::valueForKeyPath($data,"user.password");
            // let's salt the password
            KeyPath::setValueByReferenceForKeyPath($data,"user.password",$this->salt($password));
            return $data;
        };
        $this->addFilterIn('CreateUser->call',$filterCreateUser);

        $filterCreateUsers=new FilterHookByClosure();
        $filterCreateUsers->closure=function($data) {
            $password=KeyPath::valueForKeyPath($data,"user.password");
            // let's salt the password
            KeyPath::setValueByReferenceForKeyPath($data,"user.password",$this->salt($password));
            return $data;
        };
        $this->addFilterIn('CreateUsers->call',$filterCreateUsers);

        $filterUpdateUser=new FilterHookByClosure();
        $filterUpdateUser->closure=function($data) {
            // let's salt the password
            $password=KeyPath::valueForKeyPath($data,"user.password");
            KeyPath::setValueByReferenceForKeyPath($data,"user.password",$this->salt($password));
            return $data;
        };
        $this->addFilterIn('UpdateUser->call',$filterUpdateUser);

        $filterUpdateUsers=new FilterHookByClosure();
        $filterUpdateUsers->closure=function($data) {
            $password=KeyPath::valueForKeyPath($data,"user.password");
            // let's salt the password
            KeyPath::setValueByReferenceForKeyPath($data,"user.password",$this->salt($password));
            return $data;
        };
        $this->addFilterIn('UpdateUsers->call',$filterUpdateUsers);
    }
    /**
    * Configure the permissions
    * By default we provide a good level of security
    */
    private function _configurePermissions(){

        $this->_permissionsRules = array(


            'NotFound->GET'=> array('level'=> PERMISSION_NO_RESTRICTION),
            'Reachable->GET'=> array('level'=> PERMISSION_NO_RESTRICTION),
            'Reachable->verify'=> array('level'=> PERMISSION_BY_IDENTIFICATION),
            'Auth->POST' => array('level' => PERMISSION_BY_TOKEN,TOKEN_CONTEXT=>'LoginUser#spaceUID'),// (!) do not change
            'Auth->DELETE' => array('level'  => PERMISSION_NO_RESTRICTION), // (!)
            //SSE Time
            'SSETime->GET'=> array('level'=> PERMISSION_NO_RESTRICTION),
            //SSE Trigggers
            'SSETriggers->GET' => array('level' => PERMISSION_NO_RESTRICTION),
            // ProtectedRun
            'ProtectedRun->GET'=>array('level' => PERMISSION_BY_IDENTIFICATION),
            // The configuration infos endpoint
            'Infos->GET'=>array('level' => PERMISSION_NO_RESTRICTION),
            'EntityExistsById->call'=>array('level' => PERMISSION_BY_IDENTIFICATION),

            // USERS

            'ReadUserById->call'=>array('level' => PERMISSION_BY_IDENTIFICATION),
            'CreateUser->call'=>array('level' => PERMISSION_BY_TOKEN,TOKEN_CONTEXT=>'CreateUser#spaceUID'),

            'UpdateUser->call'=>array(
				'level' => PERMISSION_RESTRICTED_BY_QUERIES,
					ARRAY_OF_QUERIES =>array(
						"hasBeenCreatedByCurrentUser"=>array(
							SELECT_COLLECTION_NAME=>'users',
							WHERE_VALUE_OF_ENTITY_KEY=>'_id',
							EQUALS_VALUE_OF_PARAMETERS_KEY_PATH=>'user._id',

							COMPARE_WITH_OPERATOR=>'==',
							RESULT_ENTITY_KEY=>'creatorUID',
							AND_CURRENT_USERID=>true
						),
						"isCurrentUser"=>array(
							SELECT_COLLECTION_NAME=>'users',
							WHERE_VALUE_OF_ENTITY_KEY=>'_id',
							EQUALS_VALUE_OF_PARAMETERS_KEY_PATH=>'user._id',

							COMPARE_WITH_OPERATOR=>'==',
							RESULT_ENTITY_KEY=>'_id',
							AND_CURRENT_USERID=>true
					)
                )
            ),

            'DeleteUser->call'=>array(
                'level' => PERMISSION_RESTRICTED_BY_QUERIES,
                    ARRAY_OF_QUERIES =>array(
                        "hasBeenCreatedByCurrentUser"=>array(
							SELECT_COLLECTION_NAME=>'users',
							WHERE_VALUE_OF_ENTITY_KEY=>'_id',
							EQUALS_VALUE_OF_PARAMETERS_KEY_PATH=>'userId',

							COMPARE_WITH_OPERATOR=>'==',
							RESULT_ENTITY_KEY=>'creatorUID',
							AND_CURRENT_USERID=>true
						),
                        "isCurrentUser"=>array(
							SELECT_COLLECTION_NAME=>'users',
							WHERE_VALUE_OF_ENTITY_KEY=>'_id',
							EQUALS_VALUE_OF_PARAMETERS_KEY_PATH=>'userId',

							COMPARE_WITH_OPERATOR=>'==',
							RESULT_ENTITY_KEY=>'_id',
							AND_CURRENT_USERID=>true
						)
                	)
            )
            ,
            'CreateUsers->call'=>array('level' => PERMISSION_IS_GRANTED_TO_SUPER_ADMIN_ONLY),
            'ReadUsersByIds->call'=>array('level' => PERMISSION_BY_IDENTIFICATION),
            'UpdateUsers->call'=>array('level' => PERMISSION_IS_GRANTED_TO_SUPER_ADMIN_ONLY),
            'DeleteUsers->call'=>array('level' => PERMISSION_IS_GRANTED_TO_SUPER_ADMIN_ONLY),
            'ReadUsersByQuery->call'=>array('level' => PERMISSION_IS_GRANTED_TO_SUPER_ADMIN_ONLY),


            // Locker

			/*
				1# A distant locker can be accessed only by Authenticated users.
     			2# A Locker can be "Created Updated Deleted" only by its creator. Locker.creatorUID
     			3# A locker cannot be read distantly but only verifyed
     			4# On successful verification the locker is returned with its cake :)
			*/

			'VerifyLocker->POST' => array('level' => PERMISSION_BY_IDENTIFICATION),
			'CreateLocker->call'=>array('level' => PERMISSION_BY_IDENTIFICATION),
			'UpdateLocker->call'=>array(
				'level' => PERMISSION_RESTRICTED_BY_QUERIES,
				ARRAY_OF_QUERIES =>array(
					"hasBeenCreatedByCurrentUser"=>array(
						SELECT_COLLECTION_NAME=>'lockers',
						WHERE_VALUE_OF_ENTITY_KEY=>'_id',
						EQUALS_VALUE_OF_PARAMETERS_KEY_PATH=>'user._id',

						COMPARE_WITH_OPERATOR=>'==',
						RESULT_ENTITY_KEY=>'creatorUID',
						AND_CURRENT_USERID=>true
					)
				)
			),
			'DeleteLocker->call'=>array(
				'level' => PERMISSION_RESTRICTED_BY_QUERIES,
				ARRAY_OF_QUERIES =>array(
					"hasBeenCreatedByCurrentUser"=>array(
						SELECT_COLLECTION_NAME=>'lockers',
						WHERE_VALUE_OF_ENTITY_KEY=>'_id',
						EQUALS_VALUE_OF_PARAMETERS_KEY_PATH=>'lockerId',

						COMPARE_WITH_OPERATOR=>'==',
						RESULT_ENTITY_KEY=>'creatorUID',
						AND_CURRENT_USERID=>true
					)
				)
			),
			'ReadLockerById->call'=>array('level' => PERMISSION_IS_BLOCKED),
			'ReadLockersByIds->call'=>array('level' => PERMISSION_IS_BLOCKED),
			'UpdateLockers->call'=>array('level' => PERMISSION_IS_BLOCKED),
			'DeleteLockers->call'=>array('level' => PERMISSION_IS_BLOCKED),
			'ReadLockersByQuery->call'=>array('level' => PERMISSION_IS_BLOCKED),

            // Nobody can delete triggers.

            'SSETriggers->GET'=>array('level' => PERMISSION_BY_IDENTIFICATION),
            'TriggerAfterIndex->call'=>array('level' => PERMISSION_BY_IDENTIFICATION),
            'TriggerForIndexes->call'=>array('level' => PERMISSION_BY_IDENTIFICATION),
            'TriggersByIds->call'=>array('level' => PERMISSION_BY_IDENTIFICATION),


            // Import export special Endpoints

            //'Import->GET'=>array('level' => PERMISSION_IS_GRANTED_TO_SUPER_ADMIN_ONLY),
            //'Export->GET'=>array('level' => PERMISSION_IS_GRANTED_TO_SUPER_ADMIN_ONLY)

            'Import->GET'=>array('level' => PERMISSION_BY_IDENTIFICATION),// TEMP THE ACL SHOULD BE REQUALIFIED (!)
            'Export->GET'=>array('level' => PERMISSION_BY_IDENTIFICATION)// TEMP THE ACL SHOULD BE REQUALIFIED (!)


<?php
echoIndentCR("/*",2);
$permissionHistory=array();
/* @var $d ProjectRepresentation */
/* @var $action ActionRepresentation */


while ($d->iterateOnActions() ) {

    $action=$d->getAction();
    $shouldBeExcluded=false;
    foreach ($h->excludePath as $pathToExclude ) {
        if(strpos($action->class.'.php',$pathToExclude)!==false){
            $shouldBeExcluded=true;
        }
    }
    if (isset($excludeActionsWith)) {
        foreach ($excludeActionsWith as $actionTobeExcluded ) {
            if (strpos($action->class, $actionTobeExcluded) !== false) {
                $shouldBeExcluded = true;
            }
        }
    }

    if($shouldBeExcluded==true){
        continue;
    }

    $path=$action->path;
    $path=ltrim($path,'/');
    $classNameWithoutPrefix=ucfirst(substr($action->class,strlen($d->classPrefix)));


    //$string= "'".$classNameWithoutPrefix."->call'=>array('level' => PERMISSION_BY_TOKEN,TOKEN_CONTEXT=>'$classNameWithoutPrefix#rUID')";
    $string= "'".$classNameWithoutPrefix."->call'=>array('level' => PERMISSION_BY_IDENTIFICATION)";

    if(!$d->lastAction()){
        $string.=',';
    }
    if(!in_array($string,$permissionHistory)){
        $permissionHistory[]=$string;
        echoIndentCR($string,3);
    }
}
echoIndentCR("*/",2);
?>      );
    }

    /**
    * Setups a returns the commons Routes aliases
    * @return RoutesAliases
    */
    protected function _getEndPointsRouteAliases () {
        $mapping = array(
            'POST:/user/login' => array('Auth','POST'),
            'POST:/user/logout' => array('Auth','DELETE'), // Will call explicitly DELETE (equivalent to explicit call of DELETE login)
            'GET:/verify/credentials' => array('Reachable','verify'),
            'POST:/locker/verify' => array('VerifyLocker','POST'),
            'GET:/{spaceUID}/triggers/after/{lastIndex}' => array('TriggerAfterIndex','call'),// Multi route test
            'GET:/triggers/after/{lastIndex}' => array('TriggerAfterIndex','call'),
            'GET:/triggers/'=> array('TriggerForIndexes','call'), // Triggers for indexes
            'GET:/export' => array('Export','GET'),
            'GET:/exists/{id}' => array('EntityExistsById','call'),
<?php
$history=array();
/* @var $d ProjectRepresentation */
/* @var $action ActionRepresentation */

while ($d->iterateOnActions() ) {

    $action=$d->getAction();
    $shouldBeExcluded=false;
    foreach ($h->excludePath as $pathToExclude ) {
        if(strpos($action->class.'.php',$pathToExclude)!==false){
            $shouldBeExcluded=true;
        }
    }
    if (isset($excludeActionsWith)) {
        foreach ($excludeActionsWith as $actionTobeExcluded ) {
            if (strpos($action->class, $actionTobeExcluded) !== false) {
                $shouldBeExcluded = true;
            }
        }
    }

    if($shouldBeExcluded==true){
        continue;
    }
    
    $path=$action->path;
    $path=ltrim($path,'/');
    $classNameWithoutPrefix=ucfirst(substr($action->class,strlen($d->classPrefix)));
    $string= '\''.$action->httpMethod.':/'.lcfirst($path).'\'=>array(\''.$classNameWithoutPrefix.'\',\'call\')';
    if(!$d->lastAction()){
        $string.=',';
    }
    if(!in_array($string,$history)){
        $history[]=$string;
        echoIndentCR($string,3);
    }
}
?>
        );
        return new RoutesAliases($mapping);
    }


    /**
    * Returns the collection name list
    * @return array
    */
    public function getCollectionsNameList(){
        $list=parent::getCollectionsNameList();
        $list [] = "triggers";
<?php while ($d->iterateOnEntities() ) {
    $entity=$d->getEntity();
    $name=$entity->name;
    if(isset($prefix)){
        $name=str_replace($prefix,'',$name);
    }
    $shouldBeExcluded=false;
    if (isset($excludeActionsWith)) {
        foreach ($excludeActionsWith as $actionTobeExcluded ) {
            if (strpos(strtolower($name), strtolower($actionTobeExcluded)) !== false) {
                $shouldBeExcluded = true;
            }
        }
    }
    if (!isset($name) || $name=="" ||$shouldBeExcluded==true){
        continue;
    }else{
        echoIndentCR('$list [] = "'.strtolower(Pluralization::pluralize($name)).'";',2);
    }
}
?>
        return $list;
    }

}
<?php echo '?>'?><?php /*<- END OF TEMPLATE */?>#BMS#->{"filename":"configuration.php.template.php","checksum":1773438290,"relativePath":"BartlebyFlexions\/src\/modules\/Bartleby\/templates\/project\/configuration.php.template.php","size":5199}<-#BME#
<?php

require_once FLEXIONS_MODULES_DIR . '/Bartleby/templates/Requires.php';

/* @var $f Flexed */
/* @var $d ProjectRepresentation */


if (isset ( $f )) {
    $f->fileName = 'GeneratedConfiguration.php';
    $f->package =  'php/api/'.$h->majorVersionPathSegmentString().'_generated/';
}
/* TEMPLATES STARTS HERE -> */?>
<?php echo '<?php'?>
<?php echo GenerativeHelperForPhp::defaultHeader($f,$d); ?>

// SHARED CONFIGURATION BETWEEN THE API & MAIN PAGES

namespace Bartleby;

require_once BARTLEBY_ROOT_FOLDER . 'Commons/_generated/BartlebyCommonsConfiguration.php';
require_once BARTLEBY_ROOT_FOLDER . 'Core/RoutesAliases.php';

use Bartleby\Core\RoutesAliases;
use Bartleby\Core\Stages;
use Bartleby\Mongo\MongoConfiguration;

class GeneratedConfiguration extends BartlebyCommonsConfiguration {


    protected function _configurePermissions(){

        $permissionsRules = array(
<?php
$permissionHistory=array();
/* @var $d ProjectRepresentation */
/* @var $action ActionRepresentation */
while ($d->iterateOnActions() ) {

    $action=$d->getAction();
    $shouldBeExcluded=false;
    foreach ($h->excludePath as $pathToExclude ) {
        if(strpos($action->class.'.php',$pathToExclude)!==false){
            $shouldBeExcluded=true;
        }
    }
    if (isset($excludeActionsWith)) {
        foreach ($excludeActionsWith as $actionTobeExcluded ) {
            if (strpos($action->class, $actionTobeExcluded) !== false) {
                $shouldBeExcluded = true;
            }
        }
    }


    if($shouldBeExcluded==true){
        continue;
    }

    $path=$action->path;
    $path=ltrim($path,'/');
    $classNameWithoutPrefix=ucfirst(substr($action->class,strlen($d->classPrefix)));


    //$string= "'".$classNameWithoutPrefix."->call'=>array('level' => PERMISSION_BY_TOKEN,TOKEN_CONTEXT=>'$classNameWithoutPrefix#rUID')";
    $string= "'".$classNameWithoutPrefix."->call'=>array('level' => PERMISSION_BY_IDENTIFICATION)";

    if(!$d->lastAction()){
        $string.=',';
    }
    if(!in_array($string,$permissionHistory)){
        $permissionHistory[]=$string;
        echoIndentCR($string,2);
    }
}
?>      );
        $this->addPermissions($permissionsRules);
    }

/*
    In your Configuration you can override the aliases.

    protected function _getPagesRouteAliases () {
        $routes=parent::_getEndPointsRouteAliases();
        $mapping = array(
        ''=>'Start',
        'time'=>'Time',
        '*' => 'NotFound'
        );
        $routes->addAliasesToMapping($mapping);
    return $routes;
    }

    protected function _getEndPointsRouteAliases () {
        $routes=parent::_getEndPointsRouteAliases();
        $mapping = array(
        'POST:/user/{userId}/comments'=>array('CommentsByUser','POST_method_for_demo'),
        'DELETE:/user/{userId}/comments'=>array('CommentsByUser','DELETE'),
        'time'=>'SSETime' // A server sent event sample
        );
        $routes->addAliasesToMapping($mapping);
        return $routes;
    }


*/

    protected function _getEndPointsRouteAliases () {
        $routes=parent::_getEndPointsRouteAliases();
        $mapping = array(
<?php
$history=array();
/* @var $d ProjectRepresentation */
/* @var $action ActionRepresentation */

while ($d->iterateOnActions() ) {

    $action=$d->getAction();
    $shouldBeExcluded=false;
    foreach ($h->excludePath as $pathToExclude ) {
        if(strpos($action->class.'.php',$pathToExclude)!==false){
            $shouldBeExcluded=true;
        }
    }
    if (isset($excludeActionsWith)) {
        foreach ($excludeActionsWith as $actionTobeExcluded ) {
            if (strpos($action->class, $actionTobeExcluded) !== false) {
                $shouldBeExcluded = true;
            }
        }
    }

    if($shouldBeExcluded==true){
        continue;
    }

    $path=$action->path;
    $path=ltrim($path,'/');
    $classNameWithoutPrefix=ucfirst(substr($action->class,strlen($d->classPrefix)));
    $string= '\''.$action->httpMethod.':/'.lcfirst($path).'\'=>array(\''.$classNameWithoutPrefix.'\',\'call\')';
    if(!$d->lastAction()){
        $string.=',';
    }
    if(!in_array($string,$history)){
        $history[]=$string;
        echoIndentCR($string,3);
    }

}
?>
        );
        $routes->addAliasesToMapping($mapping);
        return $routes;
    }


    /**
    * Returns the collection name list
    * @return array
    */
    public function getCollectionsNameList(){
        $list=parent::getCollectionsNameList();
<?php while ($d->iterateOnEntities() ) {
    $entity=$d->getEntity();
    $name=$entity->name;
    if(isset($prefix)){
        $name=str_replace($prefix,'',$name);
    }
    $shouldBeExcluded=false;
    if (isset($excludeActionsWith)) {
        foreach ($excludeActionsWith as $actionTobeExcluded ) {
            if (strpos(strtolower($name), strtolower($actionTobeExcluded)) !== false) {
                $shouldBeExcluded = true;
            }
        }
    }
    if (!isset($name) || $name=="" ||$shouldBeExcluded==true){
        continue;
    }else{
        echoIndentCR(' $list [] = "'.strtolower(Pluralization::pluralize($name)).'";',2);
    }
}
?>
        return $list;
    }
}
<?php echo '?>'?><?php /*<- END OF TEMPLATE */?>#BMS#->{"filename":"destructiveInstaller.template.php","checksum":2588859827,"relativePath":"BartlebyFlexions\/src\/modules\/Bartleby\/templates\/project\/destructiveInstaller.template.php","size":3696}<-#BME#
<?php

require_once FLEXIONS_MODULES_DIR . '/Bartleby/templates/Requires.php';

/* @var $f Flexed */


if (isset ( $f )) {
    $f->fileName = 'generated_destructiveInstaller.php';
    $f->package = "php/Protected/";
}
/* TEMPLATES STARTS HERE -> */?>
<?php echo '<?php'?>

/**
*
* This script should be destroyed and not deployed.
* A destructive installer script for YouDub
*
**/
require_once dirname(__DIR__).'/Configuration.php';

use \MongoClient;
use Bartleby\Core\Stages;
use Bartleby\Configuration;

error_reporting(E_ALL);
ini_set('display_errors', 1);

$configuration=new Configuration(dirname(__DIR__),BARTLEBY_ROOT_FOLDER);

function logMessage($message=""){
    echo ($message."<br>\n");
}

function createCollection($collectionName,$db){
    logMessage('Creating the \''.$collectionName.'\' collection');
    $collection=$db->createCollection($collectionName);
    logMessage('Creating the indexes for \''.$collectionName.'\' (ephemeral, OBSERVATION_UID_KEY,SPACE_UID_KEY) ');
    $collection->createIndex(array("ephemeral" => 1));
    $collection->createIndex(array(SPACE_UID_KEY => 1));
    $collection->createIndex(array(OBSERVATION_UID_KEY => 1));
}


$today = date("Ymd-H:m:s");
logMessage ("Running installer on ".$today);
try {
    logMessage("Connecting to MONGO");
    $m = new MongoClient();
} catch (Exception $e) {
    logMessage("Mongo client must be installed ". $e->getMessage());
}
logMessage("Selecting the database  ".$configuration->MONGO_DB_NAME());
$db = $m->selectDB($configuration->MONGO_DB_NAME());// Selecting  base

$collectionList=$db->listCollections();

if ($configuration->STAGE()==Stages::PRODUCTION){
    logMessage("Destructive installer is blocked on Production stage");
    return;
}

if ( $configuration->ALLOW_DESTRUCTIVE_INSTALLER()===false && count($collectionList)>0 ){
    logMessage("ALLOW_DESTRUCTIVE_INSTALLER is set to FALSE! ");
    logMessage("Turn it to true once if you are sure you want to totally reset the DB.");
    return;
}

logMessage("Erasing all the collections if necessary");
// Erase all the collections

logMessage("Number of collection ".count($collectionList));
foreach ($collectionList as $collection) {
logMessage("Droping ".$collection->getName());
$collection->drop();
}
logMessage("Recreating the collections");

// Collection creation

// Bartleby's commons

createCollection("users",$db);
createCollection("locker",$db);
createCollection("triggers",$db);

<?php 
/* @var $d ProjectRepresentation */
/* @var $entity EntityRepresentation */
foreach ($d->entities as $entity ) {
    $name=$entity->name;
    if(isset($prefix)){
        $name=str_replace($prefix,'',$name);
    }
    $shouldBeExcluded=false;
    if (isset($excludeActionsWith)) {
        foreach ($excludeActionsWith as $actionTobeExcluded ) {
            if (strpos(strtolower($name), strtolower($actionTobeExcluded)) !== false) {
                $shouldBeExcluded = true;
            }
        }
    }

    if ($shouldBeExcluded==true){
        continue;
    }

    $pluralized=lcfirst(Pluralization::pluralize($name));
    echoIndentCR('createCollection("'.$pluralized.'",$db);',0);
}
?>

logMessage("");
logMessage('deleting cookies ('.count($_COOKIE).')');
    foreach ($_COOKIE as $k=>$v) {
    setcookie($k,'',time()-60,'/', null, false, false);
}


logMessage("");
logMessage("**********************************************************************");
logMessage("Please set  Configuration::ALLOW_DESTRUCTIVE_INSTALLER const to FALSE!");



require_once BARTLEBY_PUBLIC_FOLDER.'Protected/PostInstaller.php';
use Bartleby\PostInstaller;
$postInstaller=new PostInstaller();
$postInstaller->run($configuration);

<?php /*<- END OF TEMPLATE */?>
#BMS#->{"filename":"document.swift.template.php","checksum":535457406,"relativePath":"BartlebyFlexions\/src\/modules\/Bartleby\/templates\/project\/document.swift.template.php","size":21197}<-#BME#
<?php

require_once FLEXIONS_MODULES_DIR . '/Bartleby/templates/Requires.php';
require_once FLEXIONS_MODULES_DIR . 'Languages/FlexionsSwiftLang.php';
require_once FLEXIONS_MODULES_DIR . 'Bartleby/templates/project/SwiftDocumentConfigurator.php';

/*
 * This template is an advanced template that must be configured
 * to be used multiple time within the same project
 * You must declare $configurator a SwitfDocumentConfigurator instance its before invocation.
 */

/* @var $f Flexed */
/* @var $d ProjectRepresentation */
/* @var $project ProjectRepresentation */
/* @var $action ActionRepresentation*/
/* @var $entity EntityRepresentation */
/* @var $configurator SwiftDocumentConfigurator */

if (isset ( $f ) && isset($configurator)) {
    // We determine the file name.
    $f->fileName = $configurator->filename;
    // And its package.
    $f->package = 'xOS/';
}else{
    return 'THIS TEMPLATES REQUIRES A SwitfDocumentConfigurator IN $configurator';
}


$project=$d;// It is a project template

//Collection controllers are related to actions.


/* TEMPLATES STARTS HERE -> */?>
//
//  <?php echo($configurator->filename.cr()) ?>
//
//  The is the central piece of the Document oriented architecture.
//  We provide a universal implementation with conditionnal compilation
//
//  The document stores references to Bartleby's style CollectionControllers.
//  This allow to use intensively bindings and distributed data automation.
//  With the mediation of standard Bindings approach with NSArrayControler
//
//  We prefer to centralize the complexity of data handling in the document.
//  Thats why for example we implement projectBindingsArrayController.didSet with an CGD dispatching
//  We could have set the binding programmatically in the WindowController
//  But we consider for clarity that the Storyboarded Bindings Settings should be as exhaustive as possible.
//  And the potential complexity masked.
//
//  Generated by flexions
//

import Foundation

#if os(OSX)
import AppKit
#else
import UIKit
#endif

#if !USE_EMBEDDED_MODULES
import ObjectMapper
#endif

<?php
if ($isIncludeInBartlebysCommons==false) {
    echoIndentCR('#if !USE_EMBEDDED_MODULES', 0);
    echoIndentCR('import BartlebyKit', 0);
    echoIndentCR('#endif', 0);
}
?>


@objc(<?php echo($configurator->getClassName())?>) open class <?php echo($configurator->getClassName())?> : <?php
    if (isset($isIncludeInBartlebysCommons) && $isIncludeInBartlebysCommons==true){
        echo('Registry');
    }else{
        echo('BartlebyDocument');
    }
?> {

    #if os(OSX)

    required public init() {
        super.init()
        <?php echo($configurator->getClassName())?>.declareTypes()
    }

    #else

    private var _fileURL: URL

    override public init(fileURL url: URL) {
        self._fileURL = url
        super.init(fileURL: url)
        <?php echo($configurator->getClassName())?>.declareTypes()
    }
    #endif


    // MARK  Universal Type Support

    override open class func declareTypes() {
        super.declareTypes()
<?php
// ENTITIES

/*@ Hypotypose */
$hypotypose=$h;
$list=$hypotypose->getFlatFlexedList();

// FLEXED
$declareAllCollectibileType=false;
if ($declareAllCollectibileType==true) {
    foreach ($list as $flexed) {
        /*@var Flexed */
        $flexedElement = $flexed;
        $fileName = $flexedElement->fileName;
        if ((strpos($fileName, '.swift') !== false) && (strpos($fileName, "Abstract") === false && strpos($fileName, "Document") === false)) {
            $fileName = str_replace('.swift', '', $fileName);
            echoIndentCR('Registry.declareCollectibleType(' . $fileName . ')', 2);
            echoIndentCR('Registry.declareCollectibleType(Alias<' . $fileName . '>)', 2);
        }
    }
}

?>
    }


    // MARK: - Collection Controllers

    fileprivate var _KVOContext: Int = 0

    // The initial instances are proxies
    // On document deserialization the collection are populated.

<?php
foreach ($project->entities as $entity) {
    if ($configurator->collectionControllerShouldBeSupportedForEntity($project,$entity)){
        $pluralizedEntity=Pluralization::pluralize($entity->name);
        $collectionControllerClassName=ucfirst($pluralizedEntity).'CollectionController';
        $collectionControllerVariableName=lcfirst($pluralizedEntity).'CollectionController';
        echoIndentCR('open dynamic var '.lcfirst($pluralizedEntity).'='.$collectionControllerClassName.'(){',1);
        echoIndentCR('willSet{',2);
        echoIndentCR(lcfirst($pluralizedEntity).'.document=self',3);
        echoIndentCR('}',2);
        echoIndentCR('}',1);
        echoIndentCR('',1);
    }
}
?>

    // MARK: - Array Controllers and automation (OSX)
 #if os(OSX) && !USE_EMBEDDED_MODULES


    // KVO
    // Those array controllers are Owned by their respective ViewControllers
    // Those view Controller are observed here to insure a consistent persitency


<?php
foreach ($project->entities as $entity) {
    if ($configurator->collectionControllerShouldBeSupportedForEntity($project,$entity)){
        $pluralizedEntity=Pluralization::pluralize($entity->name);
        $arrayControllerClassName=ucfirst($pluralizedEntity).'ArrayController';
        $arrayControllerVariableName=lcfirst($pluralizedEntity).'ArrayController';
        echoIndentCR('

    open var '.$arrayControllerVariableName.': NSArrayController?{

        willSet{
            // Remove observer on previous array Controller
            '.lcfirst($arrayControllerVariableName).'?.removeObserver(self, forKeyPath: "selectionIndexes", context: &self._KVOContext)
        }
        didSet{
            // Setup the Array Controller in the CollectionController
            self.'.lcfirst($pluralizedEntity).'.arrayController='.lcfirst($arrayControllerVariableName).'
            // Add observer
            '.lcfirst($arrayControllerVariableName).'?.addObserver(self, forKeyPath: "selectionIndexes", options: .new, context: &self._KVOContext)
            if let indexes=self.registryMetadata.stateDictionary['.$configurator->getClassName().'.kSelected'.ucfirst($pluralizedEntity).'IndexesKey] as? [Int]{
                let indexesSet = NSMutableIndexSet()
                indexes.forEach{ indexesSet.add($0) }
                self.'.lcfirst($arrayControllerVariableName).'?.setSelectionIndexes(indexesSet as IndexSet)
             }
        }
    }
        ',0);
    }
}
?>


#endif

    // indexes persistency

<?php
foreach ($project->entities as $entity) {
    if ($configurator->collectionControllerShouldBeSupportedForEntity($project,$entity)){
        $pluralizedEntity=Pluralization::pluralize($entity->name);
        $arrayControllerClassName=ucfirst($pluralizedEntity).'ArrayController';
        $arrayControllerVariableName=lcfirst($pluralizedEntity).'ArrayController';
        echoIndentCR('
    
    static open let kSelected'.ucfirst($pluralizedEntity).'IndexesKey="selected'.ucfirst($pluralizedEntity).'IndexesKey"
    static open let '.strtoupper($pluralizedEntity).'_SELECTED_INDEXES_CHANGED_NOTIFICATION="'.strtoupper($pluralizedEntity).'_SELECTED_INDEXES_CHANGED_NOTIFICATION"
    dynamic open var selected'.ucfirst($pluralizedEntity).':['.ucfirst($entity->name).']?{
        didSet{
            if let '.lcfirst($pluralizedEntity).' = selected'.ucfirst($pluralizedEntity).' {
                 let indexes:[Int]='.lcfirst($pluralizedEntity).'.map({ ('.lcfirst($entity->name).') -> Int in
                    return self.'.lcfirst($pluralizedEntity).'.index(where:{ return $0.UID == '.lcfirst($entity->name).'.UID })!
                })
                self.registryMetadata.stateDictionary['.$configurator->getClassName().'.kSelected'.ucfirst($pluralizedEntity).'IndexesKey]=indexes
                NotificationCenter.default.post(name:NSNotification.Name(rawValue:'.$configurator->getClassName().'.'.strtoupper($pluralizedEntity).'_SELECTED_INDEXES_CHANGED_NOTIFICATION), object: nil)
            }
        }
    }
    var firstSelected'.ucfirst($entity->name).':'.ucfirst($entity->name).'? { return self.selected'.ucfirst($pluralizedEntity).'?.first }
        
        ',0);
    }
}
?>



    // MARK: - Schemas

    /**

    In this func you should :

    #1  Define the Schema
    #2  Register the collections

    */
    override open func configureSchema(){

        // #1  Defines the Schema
        super.configureSchema()

<?php
foreach ($project->entities as $entity) {
    if ($configurator->collectionControllerShouldBeSupportedForEntity($project,$entity)){
        $pluralizedEntity=Pluralization::pluralize($entity->name);
        $arrayControllerClassName=ucfirst($pluralizedEntity).'ArrayController';
        $arrayControllerVariableName=lcfirst($pluralizedEntity).'ArrayController';
        $entityDefinition=lcfirst($entity->name).'Definition';
        echoIndentCR('

        let '.$entityDefinition.' = CollectionMetadatum()
        '.$entityDefinition.'.proxy = self.'.lcfirst($pluralizedEntity).'
        // By default we group the observation via the rootObjectUID
        '.$entityDefinition.'.collectionName = '.$entity->name.'.collectionName
        '.$entityDefinition.'.storage = CollectionMetadatum.Storage.monolithicFileStorage
        '.$entityDefinition.'.allowDistantPersistency = '. (($entity->isDistantPersistencyOfCollectionAllowed())? 'true':'false').'
        '.$entityDefinition.'.inMemory = '. (($entity->shouldPersistsLocallyOnlyInMemory())? 'true':'false').'
        ',0);
    }
}
?>

        // Proceed to configuration
        do{

<?php
foreach ($project->entities as $entity) {
    if ($configurator->collectionControllerShouldBeSupportedForEntity($project,$entity)){
        $pluralizedEntity=Pluralization::pluralize($entity->name);
        $arrayControllerClassName=ucfirst($pluralizedEntity).'ArrayController';
        $arrayControllerVariableName=lcfirst($pluralizedEntity).'ArrayController';
        $entityDefinition=lcfirst($entity->name).'Definition';
        echoIndentCR('try self.registryMetadata.configureSchema('.$entityDefinition.')',3);
    }
}
?>

        }catch RegistryError.duplicatedCollectionName(let collectionName){
            bprint("Multiple Attempt to add the Collection named \(collectionName)",file:#file,function:#function,line:#line)
        }catch {
            bprint("\(error)",file:#file,function:#function,line:#line)
        }

        // #2 Registers the collections
        do{
            try self.registerCollections()
        }catch{
        }
    }

    // MARK: - OSX specific

 #if os(OSX) && !USE_EMBEDDED_MODULES

    // MARK: KVO


    override open func observeValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?) {
        guard context == &_KVOContext else {
            // If the context does not match, this message
            // must be intended for our superclass.
            super.observeValue(forKeyPath: keyPath, of: object, change: change, context: context)
            return
        }
        // We prefer to centralize the KVO for selection indexes at the top level
        if let keyPath = keyPath, let object = object {

        <?php
        foreach ($project->entities as $entity) {
            if ($configurator->collectionControllerShouldBeSupportedForEntity($project,$entity)){
                $pluralizedEntity=Pluralization::pluralize($entity->name);
                $collectionControllerClassName=ucfirst($pluralizedEntity).'CollectionController';
                $arrayControllerVariableName=lcfirst($pluralizedEntity).'ArrayController';
                echoIndentCR('
            
            if keyPath=="selectionIndexes" && self.'.$arrayControllerVariableName.' == object as? NSArrayController {
                if let '.lcfirst($pluralizedEntity).' = self.'.$arrayControllerVariableName.'?.selectedObjects as? ['.ucfirst($entity->name).'] {
                     if let selected'.ucfirst($entity->name).' = self.selected'.ucfirst($pluralizedEntity).'{
                        if selected'.ucfirst($entity->name).' == '.lcfirst($pluralizedEntity).'{
                            return // No changes
                        }
                     }
                    self.selected'.ucfirst($pluralizedEntity).'='.lcfirst($pluralizedEntity).'
                }
                return
            }
            ',0);
            }
        }
        ?>
        }

    }

    // MARK:  Delete currently selected items
    <?php
    echoIndentCR('',0);
    foreach ($project->entities as $entity) {
        if ($configurator->collectionControllerShouldBeSupportedForEntity($project,$entity)){
            $entityName=ucfirst($entity->name);
            $pluralizedEntity=lcfirst(Pluralization::pluralize($entity->name));
            echoIndentCR('
    open func deleteSelected'.ucfirst($pluralizedEntity).'() {
        // you should override this method if you want to cascade the deletion(s)
        if let selected=self.selected'.ucfirst($pluralizedEntity).'{
            for item in selected{
                 self.'.$pluralizedEntity.'.removeObject(item, commit:true)
            }
        }
    }
        ',0);
        }
    }
    ?>

    #else


    #endif

    <?php
    if ($isIncludeInBartlebysCommons){
        echo('
   
    // MARK : new User facility 
    
    /**
    * Creates a new user
    * 
    * you should override this method to customize default (name, email, ...)
    * and call before returning :
    *   if(user.creatorUID != user.UID){
    *       // We don\'t want to add the current user to user list
    *       self.users.add(user, commit:true)
    *   }
    */
    open func newUser() -> User {
        let user=User()
        user.silentGroupedChanges {
            if let creator=self.registryMetadata.currentUser {
                user.creatorUID = creator.UID
            }else{
                // Autopoiesis.
                user.creatorUID = user.UID
            }
            user.spaceUID = self.registryMetadata.spaceUID
            user.document = self // Very important for the  document registry metadata current User
        }
        return user
    }
     
    // MARK: - Synchronization

    // SSE server sent event source
    internal var _sse:EventSource?

    // The EventSource URL for Server Sent Events
    open dynamic lazy var sseURL:URL=URL(string: self.baseURL.absoluteString+"/SSETriggers?spaceUID=\(self.spaceUID)&observationUID=\(self.UID)&lastIndex=\(self.registryMetadata.lastIntegratedTriggerIndex)&runUID=\(Bartleby.runUID)&showDetails=false")!
    
    open var synchronizationHandlers:Handlers=Handlers.withoutCompletion()

    internal var _timer:Timer?

    // MARK: - Local Persistency

    #if os(OSX)


    // MARK:  NSDocument

    // MARK: Serialization
     override open func fileWrapper(ofType typeName: String) throws -> FileWrapper {

        self.registryWillSave()
        let fileWrapper=FileWrapper(directoryWithFileWrappers:[:])
        if var fileWrappers=fileWrapper.fileWrappers {

            // ##############
            // #1 Metadata
            // ##############

            // Try to store a preferred filename
            self.registryMetadata.preferredFileName=self.fileURL?.lastPathComponent
            var metadataData=self.registryMetadata.serialize()

            metadataData = try Bartleby.cryptoDelegate.encryptData(metadataData)

            // Remove the previous metadata
            if let wrapper=fileWrappers[self._metadataFileName] {
                fileWrapper.removeFileWrapper(wrapper)
            }
            let metadataFileWrapper=FileWrapper(regularFileWithContents: metadataData)
            metadataFileWrapper.preferredFilename=self._metadataFileName
            fileWrapper.addFileWrapper(metadataFileWrapper)

            // ##############
            // #2 Collections
            // ##############

            for metadatum: CollectionMetadatum in self.registryMetadata.collectionsMetadata {

                if !metadatum.inMemory {
                    let collectionfileName=self._collectionFileNames(metadatum).crypted
                    // MONOLITHIC STORAGE
                    if metadatum.storage == CollectionMetadatum.Storage.monolithicFileStorage {

                        if let collection = self.collectionByName(metadatum.collectionName) as? CollectibleCollection {

                            // We use multiple files

                            var collectionData = collection.serialize()
                            collectionData = try Bartleby.cryptoDelegate.encryptData(collectionData)

                            // Remove the previous data
                            if let wrapper=fileWrappers[collectionfileName] {
                                fileWrapper.removeFileWrapper(wrapper)
                            }

                            let collectionFileWrapper=FileWrapper(regularFileWithContents: collectionData)
                            collectionFileWrapper.preferredFilename=collectionfileName
                            fileWrapper.addFileWrapper(collectionFileWrapper)
                        } else {
                            // NO COLLECTION
                        }
                    } else {
                        // SQLITE
                    }

                }
            }
        }
        return fileWrapper
    }

    // MARK: Deserialization


    /**
     Standard Bundles loading

     - parameter fileWrapper: the file wrapper
     - parameter typeName:    the type name

     - throws: misc exceptions
     */
    override open func read(from fileWrapper: FileWrapper, ofType typeName: String) throws {
        if let fileWrappers=fileWrapper.fileWrappers {

            // ##############
            // #1 Metadata
            // ##############

            if let wrapper=fileWrappers[_metadataFileName] {
                if var metadataData=wrapper.regularFileContents {
                    metadataData = try Bartleby.cryptoDelegate.decryptData(metadataData)
                    let r = try Bartleby.defaultSerializer.deserialize(metadataData)
                    if let registryMetadata=r as? RegistryMetadata {
                        self.registryMetadata=registryMetadata
                    } else {
                        // There is an error
                        bprint("ERROR \(r)", file: #file, function: #function, line: #line)
                        return
                    }
                    let registryUID=self.registryMetadata.rootObjectUID
                    Bartleby.sharedInstance.replaceRegistryUID(Default.NO_UID, by: registryUID)
                    self.registryMetadata.currentUser?.document=self
                }
            } else {
                // ERROR
            }


            // ##############
            // #2 Collections
            // ##############

            for metadatum in self.registryMetadata.collectionsMetadata {
                // MONOLITHIC STORAGE
                if metadatum.storage == CollectionMetadatum.Storage.monolithicFileStorage {
                    let names=self._collectionFileNames(metadatum)
                    if let wrapper=fileWrappers[names.crypted] ?? fileWrappers[names.notCrypted] {
                        let filename=wrapper.filename
                        if var collectionData=wrapper.regularFileContents {
                            if let proxy=self.collectionByName(metadatum.collectionName) {
                                if let path=filename {
                                    if let ext=path.components(separatedBy: ".").last {
                                        let pathExtension="."+ext
                                        if  pathExtension == Registry.DATA_EXTENSION {
                                            collectionData = try Bartleby.cryptoDelegate.decryptData(collectionData)
                                        }
                                    }
                                  let _ = try proxy.updateData(collectionData,provisionChanges: false)
                                }
                            } else {
                                throw RegistryError.attemptToLoadAnNonSupportedCollection(collectionName:metadatum.d_collectionName)
                            }
                        }
                    } else {
                        // ERROR
                    }
                } else {
                    // SQLite
                }
            }
            do {
                try self._refreshProxies()
            } catch {
                bprint("Proxies refreshing failure \(error)", file: #file, function: #function, line: #line)
            }
           
            DispatchQueue.main.async(execute: {
                self.registryDidLoad()
            })
        }
    }
    
    #else
    
    // MARK: iOS UIDocument serialization / deserialization
    
    // TODO: @bpds(#IOS) UIDocument support
    
    // SAVE content
    override open func contents(forType typeName: String) throws -> Any {
        return ""
    }

    // READ content
    open override func load(fromContents contents: Any, ofType typeName: String?) throws {

    }
    
    #endif  
 
');
}
?>
}
#BMS#->{"filename":"SwiftDocumentConfigurator.php","checksum":508710326,"relativePath":"BartlebyFlexions\/src\/modules\/Bartleby\/templates\/project\/SwiftDocumentConfigurator.php","size":1214}<-#BME#
<?php
class SwiftDocumentConfigurator{

    /**
     * @var string The file name to be used
     */
    public $filename;// E.g = WorkspaceDocument.swift

    /**
     * @var array the array of the actions to be used.
     */
    public $includeCollectionControllerForEntityContainingString=array();

    /**
     * @var arrays the array of action name to explicitly exclude
     */
    public $excludeCollectionControllerForEntityContainingString=Array();

    function getClassName(){
        return str_replace('.swift','',$this->filename);
    }

    function collectionControllerShouldBeSupportedForEntity(ProjectRepresentation $project, EntityRepresentation $entity){
        $inclusionName = strtolower(str_replace($project->classPrefix, '', $entity->name));
        foreach ($this->excludeCollectionControllerForEntityContainingString as $exclusion){
            if ($entity->name===$exclusion){
                return false;
            }
        }
        foreach ($this->includeCollectionControllerForEntityContainingString as $inclusion) {
            if (!(strpos($inclusionName, strtolower($inclusion)) === false)){
                return true;
            }
        }
        return false;
    }

}
#BMS#->{"filename":"Requires.php","checksum":2416621261,"relativePath":"BartlebyFlexions\/src\/modules\/Bartleby\/templates\/Requires.php","size":295}<-#BME#
<?php
require_once FLEXIONS_ROOT_DIR.  'flexions/representations/flexions/FlexionsRepresentationsIncludes.php';
require_once FLEXIONS_MODULES_DIR . 'GenHelpers/classes/GenerativeHelperForPhp.class.php';
require_once FLEXIONS_MODULES_DIR . 'GenHelpers/classes/GenerativeHelperForSwift.class.php';#BMS#->{"filename":"FtpClient.php","checksum":2184814579,"relativePath":"BartlebyFlexions\/src\/modules\/Deploy\/dependencies\/FTP\/FtpClient.php","size":13087}<-#BME#
<?php namespace Melihucar\FtpClient;

use \Exception;

/**
 * FTP Client for PHP
 * 
 * @package FTPClient
 * @version 1.0
 * 
 * @copyright Melih Ucar
 * @author Melih Ucar
 * @license http://opensource.org/Licenses/MIT (The MIT License)
 * 
 * Copyright (c) 2013, Melih Ucar (http://www.melihucar.net/)
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
 * PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
 * OR OTHER DEALINGS IN THE SOFTWARE.
 */
class FtpClient {

    // Const variables
    const ASCII = FTP_ASCII;
    const BINARY = FTP_BINARY;

    const TIMEOUT_SEC = FTP_TIMEOUT_SEC;
    const AUTOSEEK = FTP_AUTOSEEK;

    /**
     * FTP connection
     * @var Resource
     */
    private $connection = null;

    /**
     * passive mode active / to be activated
     *
     * @var bool
     */
    protected $passive = false;

    /**
     * verbose mode
     *
     * @todo allow verbose mode to call ftp functions without "@"
     * @var bool
     */
    protected $verbose = false;

    /**
     *
     * @var bool
     */
    protected $binary = false;

    /**
     * Constructor
     * 
     * Checks if ftp extension is loaded.
     */
    public function __construct()
    {
        if ( !extension_loaded('ftp') ) {
            throw new Exception('FTP extension is not loaded!');            
        }
    }

    /**
     * Opens a FTP connection
     * 
     * @param string $host
     * @param bool $ssl
     * @param int $port
     * @param int $timeout
     * 
     * @return FTPClient
     */
    public function connect($host, $ssl = false, $port = 21, $timeout = 90)
    {
        if ($ssl) {
            $this->connection = @ftp_ssl_connect($host, $port, $timeout);
        } else {
            $this->connection = @ftp_connect($host, $port, $timeout);
        }

        if ($this->connection == null) {
            throw new Exception('Unable to connect');            
        } else {
            return $this;
        }
    }

    /**
     * Logins to FTP Server
     * 
     * @param string $username
     * @param string $password
     * 
     * @return FTPClient
     */
    public function login($username = 'anonymous', $password = '')
    {
        $result = @ftp_login($this->connection, $username, $password);

        if ($result === false) {
            throw new Exception('Login incorrect');
        } else {
            // set passive mode
            if (!is_null($this->passive)) {
                $this->passive($this->passive);
            }

            return $this;
        }
    }

    /**
     * Closes FTP connection
     * 
     * @return void
     */
    public function close()
    {
        $result = @ftp_close($this->connection);

        if ($result === false) {
            throw new Exception('Unable to close connection');
        }
    }

    /**
     * Changes passive mode,,,
     * 
     * @param bool $passive
     * 
     * @return FTPClient,
     */
    public function passive($passive = true)
    {
        $this->passive = $passive;

        if ($this->connection) {
            $result = ftp_pasv($this->connection, $passive);
            if ($result === false) {
                throw new Exception('Unable to change passive mode');
            }
        }

        return $this;
    }

    public function binary($binary)
    {
        $this->binary = $binary;

        return $this;
    }

    /**
     * @return int
     */
    public function getMode()
    {
        return $this->binary ? FTPClient::BINARY : FTPClient::ASCII;
    }

    /**
     * Changes the current directory to the specified one
     * 
     * @return FTPClient
     */
    public function changeDirectory($directory)
    {
        $result = @ftp_chdir($this->connection, $directory);
        
        if ($result === false) {
            throw new Exception('Unable to change directory');
        }

        return $this;
    }

    /**
     * Changes to the parent directory
     * 
     * @return FTPClient
     */
    public function parentDirectory()
    {
        $result = @ftp_cdup($this->connection);
        
        if ($result === false) {
            throw new Exception('Unable to get parent folder');
        }

        return $this;
    }

    /**
     * Returns the current directory name
     *
     * @return string
     */
    public function getDirectory()
    {
        $result = @ftp_pwd($this->connection);
        
        if ($result === false) {
            throw new Exception('Unable to get directory name');
        }

        return $result;
    }

    /**
     * Creates a directory
     *
     * @param string $directory
     *
     * @return FTPClient
     */
    public function createDirectory($directory)
    {
        $result = @ftp_mkdir($this->connection, $directory);
        
        if ($result === false) {
            throw new Exception('Unable to create directory');
        }

        return $this;
    }

    /**
     * Removes a directory
     *
     * @param string $directory
     * 
     * @return FTPClient
     */
    public function removeDirectory($directory)
    {
        $result = @ftp_rmdir($this->connection, $directory);
        
        if ($result === false) {
            throw new Exception('Unable to remove directory');
        }

        return $this;
    }

    /**
     * Returns a list of files in the given directory
     *
     * @param string $directory
     *
     * @return array
     */
    public function listDirectory($directory)
    {
        $result = @ftp_nlist($this->connection, $directory);
        
        if ($result === false) {
            throw new Exception('Unable to list directory');
        }
        
        asort($result);

        return $result;
    }

    /**
     * @param string $parameters
     * @param bool $recursive
     *
     * @return array
     *
     * @throws \Exception
     */
    public function rawlistDirectory($parameters, $recursive = false)
    {
        $result = @ftp_rawlist($this->connection, $parameters, $recursive);

        if ($result === false) {
            throw new Exception('Unable to list directory');
        }

        return $result;
    }

    /**
     * Deletes a file on the FTP server
     *
     * @param string $path
     * 
     * @return FTPClient
     */
    public function delete($path)
    {
        $result = @ftp_delete($this->connection, $path);
        
        if ($result === false) {
            throw new Exception('Unable to get parent folder');
        }

        return $this;
    }

    /**
     * Returns the size of the given file.
     * Return -1 on error
     *
     * @param string $remoteFile
     *
     * @return int
     * 
     */
    public function size($remoteFile)
    {
        $size = @ftp_size($this->connection, $remoteFile);

        if ($size === -1) {
            throw new Exception('Unable to get file size');
        }

        return $size;
    }

    /**
     * Returns the last modified time of the given file.
     * Return -1 on error
     *
     * @param string $remoteFile
     *
     * @return int
     * 
     */
    public function modifiedTime($remoteFile, $format = null)
    {
        $time = ftp_mdtm($this->connection, $remoteFile);

        if ( $time !== -1 && $format !== null ) {
            return date($format, $time);
        } else {
            return $time;
        }
    }

    /**
     * Renames a file or a directory on the FTP server
     *
     * @param string $currentName
     * @param string $newName
     *
     * @return bool
     */
    public function rename($currentName, $newName)
    {
        $result = @ftp_rename($this->connection, $currentName, $newName);

        return $result;
    }

    /**
     * Downloads a file from the FTP server
     *
     * @param string $localFile
     * @param string $remoteFile
     * @param int $mode
     * @param int $resumepos
     * 
     * @return FTPClient
     */
    public function get($localFile, $remoteFile, $resumePosision = 0)
    {
        $mode = $this->getMode();
        $result = @ftp_get($this->connection, $localFile, $remoteFile, $mode, $resumePosision);

        if ($result === false)
        {
            throw new Exception(sprintf('Unable to get or save file "%s" from %s', $localFile, $remoteFile));
        }

        return $this;
    }

    /**
     * Uploads from an open file to the FTP server
     *
     * @param string $remoteFile
     * @param string $localFile
     * @param int $mode
     * @param int $startPosision
     * 
     * @return FTPClient
     */
    public function put($remoteFile, $localFile, $startPosision = 0)
    {
        $mode = $this->getMode();
        $result = @ftp_put($this->connection, $remoteFile, $localFile, $mode, $startPosision);
        
        if ($result === false) {
            throw new Exception('Unable to put file');
        }

        return $this;
    }

    /**
     * Downloads a file from the FTP server and saves to an open file
     *
     * @param resource $handle
     * @param string $remoteFile
     * @param int $mode
     * @param int $resumepos
     * 
     * @return FTPClient
     */
    public function fget($handle, $remoteFile, $resumePosision = 0)
    {
        $mode = $this->getMode();
        $result = @ftp_fget($this->connection, $handle, $remoteFile, $mode, $resumePosision);
        
        if ($result === false) {
            throw new Exception('Unable to get file');
        }

        return $this;
    }

    /**
     * Uploads from an open file to the FTP server
     *
     * @param string $remoteFile
     * @param resource $handle
     * @param int $mode
     * @param int $startPosision
     * 
     * @return FTPClient
     */
    public function fput($remoteFile, $handle, $startPosision = 0)
    {
        $mode = $this->getMode();
        $result = @ftp_fput($this->connection, $remoteFile, $handle, $mode, $startPosision);
        
        if ($result === false) {
            throw new Exception('Unable to put file');
        }

        return $this;
    }

    /**
     * Retrieves various runtime behaviours of the current FTP stream
     * TIMEOUT_SEC | AUTOSEEK
     *
     * @param mixed $option
     *
     * @return mixed
     */
    public function getOption($option)
    {
        switch ($option) {
            case FTPClient::TIMEOUT_SEC:
            case FTPClient::AUTOSEEK:
                $result = @ftp_get_option($this->connection, $option);

                return $result;
                break;
            
            default:
                throw new Exception('Unsupported option');
                break;
        }
    }

    /**
     * Set miscellaneous runtime FTP options
     * TIMEOUT_SEC | AUTOSEEK
     *
     * @param mixed $option
     * @param mixed $value
     *
     * @return mixed
     */
    public function setOption($option, $value)
    {
        switch ($option) {
            case FTPClient::TIMEOUT_SEC:
                if ($value <= 0) {
                    throw new Exception('Timeout value must be greater than zero');
                }
                break;

            case FTPClient::AUTOSEEK:
                if (!is_bool($value)) {
                    throw new Exception('Autoseek value must be boolean');
                }
                break;
            
            default:
                throw new Exception('Unsupported option');
                break;
        }

        return @ftp_set_option($this->connection, $option, $value);
    }

    /**
     * Allocates space for a file to be uploaded
     * 
     * @param int $filesize
     * 
     * @return FTPClient
     */
    public function allocate($filesize)
    {
        $result = @ftp_alloc($this->connection, $filesize);
        
        if ($result === false) {
            throw new Exception('Unable to allocate');
        }

        return $this;
    }

    /**
     * Set permissions on a file via FTP
     *
     * @param int $mode
     * @param string $filename
     * 
     * @return FTPClient
     */
    public function chmod($mode, $filename)
    {
        $result = @ftp_chmod($this->connection, $mode, $filename);
        
        if ($result === false) {
            throw new Exception('Unable to change permissions');
        }

        return $this;
    }

    /**
     * Requests execution of a command on the FTP server
     *
     * @param string $command
     * 
     * @return FTPClient
     */
    public function exec($command)
    {
        $result = @ftp_exec($this->connection, $command);
        
        if ($result === false) {
            throw new Exception('Unable to exec command');
        }

        return $this;
    }

    /**
     * Destructor
     */
    public function __destruct()
    {
        $this->close();
    }
}
#BMS#->{"filename":"Deploy.php","checksum":3635263315,"relativePath":"BartlebyFlexions\/src\/modules\/Deploy\/Deploy.php","size":4606}<-#BME#
<?php
/**
 * Created by PhpStorm.
 * User: bpds
 * Date: 13/07/15
 * Time: 17:11
 */



require_once FLEXIONS_ROOT_DIR . 'flexions/Core/Hypotypose.php';
require_once FLEXIONS_ROOT_DIR . 'flexions/Core/Flexed.php';

interface IDeploy{
    function rmPathImplementation($path);
    function copyFilesImplementation($filePath,$destination);
}

class Deploy {

    /*@var $_hypotypose Hypotypose */
    protected $_hypotypose;


    /**
     * @var string this absolute destination should exists
     */
    protected $_absoluteBaseDestination='';

    function __construct(\Hypotypose $hypotypose){
        $this->_hypotypose=$hypotypose;
    }

    /**
     * Deletes the root folder.
     *
     * @param $package
     * @param $absoluteDestination
     * @param bool $removelastpackagecomponent
     */
    function rmPath($path) {
        $this->rmPathImplementation($path);
    }
    
    /**
     * Copies the files.
     *
     * @param $package
     * @param $absoluteDestination
     * @param bool|true $removelastpackagecomponent most of the time you want to remove for example the /php/ folder
     * @throws \Exception
     */
    function copyFiles($package,$absoluteDestination,$removelastpackagecomponent=true){

        if(substr($absoluteDestination,-1) != DIRECTORY_SEPARATOR){
            $absoluteDestination=$absoluteDestination.DIRECTORY_SEPARATOR;
        }
        $this->_absoluteBaseDestination=$absoluteDestination;


        if (isset($this->_hypotypose)) {
            $list = $this->_hypotypose->getFlatFlexedList();
            /* @var $flexed Flexed */
            foreach ( $list as $flexed ) {
                $filePath=$flexed->packagePath.$flexed->fileName;
                $packPosition=stripos($flexed->packagePath.$flexed->fileName,$package);
                //fLog('  '.$flexed->packagePath.$flexed->fileName.' '.$package.'->'.$packPosition.cr(),true);
                // This file should be copied
                if ($removelastpackagecomponent==true){
                    $packagecomponents=explode('/',$flexed->package);
                    array_shift($packagecomponents); // remove the last component
                    $joinedpackage=join('/',$packagecomponents);
                    $destination=$absoluteDestination.$joinedpackage.$flexed->fileName;
                }else{
                    $destination=$absoluteDestination.$flexed->package.$flexed->fileName;
                }
                if($packPosition!=false){
                    if($this instanceof IDeploy){
                        $this->copyFilesImplementation($filePath,$destination);
                    }else{
                        throw new \Exception('Deploy classes must implement IDeploy');
                    }
                }else{
                }
            }
        }else{
            throw new \Exception('LocalDeploy requires a valid hypotypose');
        }
    }

    /**
     * Equivalent to copy but we keep only the terminal folder.
     * @param $package
     * @param $absoluteDestination
     * @throws \Exception
     */
    function flatCopyFiles($package,$absoluteDestination){

        if(substr($absoluteDestination,-1) != DIRECTORY_SEPARATOR){
            $absoluteDestination=$absoluteDestination.DIRECTORY_SEPARATOR;
        }

        $this->_absoluteBaseDestination=$absoluteDestination;
        if (isset($this->_hypotypose)) {
            $list = $this->_hypotypose->getFlatFlexedList();
            /* @var $flexed Flexed */
            foreach ( $list as $flexed ) {
                $filePath=$flexed->packagePath.$flexed->fileName;
                $packPosition=stripos($flexed->packagePath.$flexed->fileName,$package);
                /* @var $packagecomponents array */
                $packagecomponents=explode('/',$flexed->package);
                if (count($packagecomponents)>0){
                    $packageSegment=$packagecomponents[count($packagecomponents)-1];
                    $destination=$absoluteDestination.$packageSegment.$flexed->fileName;
                }else{
                    $destination=$absoluteDestination.$flexed->fileName;
                }
                if($packPosition!=false){
                    if($this instanceof IDeploy){
                        $this->copyFilesImplementation($filePath,$destination);
                    }else{
                        throw new \Exception('Deploy classes must implement IDeploy');
                    }
                }else{
                }
            }
        }else{
            throw new \Exception('LocalDeploy requires a valid hypotypose');
        }
    }

}#BMS#->{"filename":"FTPDeploy.php","checksum":3840862648,"relativePath":"BartlebyFlexions\/src\/modules\/Deploy\/FTPDeploy.php","size":4772}<-#BME#
<?php
/**
 * Created by PhpStorm.
 * User: bpds
 * Date: 13/07/15
 * Time: 16:23
 */

// Dependency

require_once FLEXIONS_MODULES_DIR.'Deploy/dependencies/FTP/FtpClient.php';
require_once FLEXIONS_MODULES_DIR."Deploy/Deploy.php";


class FTPDeploy extends Deploy implements IDeploy{

    /* @var $ftpClient \Melihucar\FtpClient\FtpClient*/
    var $ftpClient;

    var $loggedIn=false;

    var $createdFolders=array();


    var $currentDirectory;

    function __construct(\Hypotypose $hypotypose){
        $this->_hypotypose=$hypotypose;
        fLog(cr().'FTP deploy is running'.cr().cr(),true);
    }

    function setUp($host, $port = 21){
        $this->ftpClient=new \Melihucar\FtpClient\FtpClient();
        $this->ftpClient->connect($host,false,21,90);
    }

    function login($user,$password){
        if (isset($this->ftpClient)){
            $this->ftpClient->login($user,$password);
            $this->loggedIn=true;
        }
        return  $this->loggedIn;
    }

    function rmPathImplementation($path) {
        if($this->loggedIn==true){
            // TODO implement the delete logic
        }else{
            throw new \Exception('Ftp client is not logged in login()');
        }
    }

    function copyFilesImplementation($filePath,$destination){
        if($this->loggedIn==true){
            $folder=dirname($destination);
            $this->currentDirectory=$this->ftpClient->getDirectory();
            if($folder!=$this->currentDirectory){
                // Create the directory
                $this->createDirectoriesForPath($destination);
                // GO TO THE DIRECTORY
                $cd=$this->ftpClient->changeDirectory(dirname($destination));
            }
            // UPLOAD
            $path_parts=pathinfo($destination);
            $destinationFileName=$path_parts['basename'];
            $upload=$this->ftpClient->put($destinationFileName,$filePath);
            fLog('FTP COPIED FROM : '.$filePath.cr().'TO'.$destination.cr(),true);
        }else{
            throw new \Exception('Ftp client is not logged in login()');
        }

    }


    function createDirectoriesForPath($path){
        $directory=dirname($path);
        if(in_array($directory,$this->createdFolders)==false){
            // We need to create the folder.
            $baseFolder=$this->_absoluteBaseDestination;
            $this->cdToFolderPath($baseFolder);
            $relativeBaseDirectory=dirname(str_replace($this->_absoluteBaseDestination,'',$path ));
            $relativeComponent=explode(DIRECTORY_SEPARATOR,$relativeBaseDirectory);
            foreach ($relativeComponent as $pathSegment){
                $baseFolder.=$pathSegment.DIRECTORY_SEPARATOR;
                if(in_array($directory,$this->createdFolders)==false){
                    $l=$this->ftpClient->listDirectory('');
                    if(is_array($l) && (!in_array($pathSegment,$l))) {
                        // Create the directory if necessary
                        $this->ftpClient->createDirectory($pathSegment);
                        $this->createdFolders[] = rtrim($baseFolder, '/');
                        fLog('FTP Created /' . $pathSegment . cr(), true);
                    }
                }
                $this->cdToFolderPath($baseFolder);
            }
        }
    }

    function cdToFolderPath($destination){
        if(! isset($this->currentDirectory)){
            $this->currentDirectory=$this->ftpClient->getDirectory();
        }
        $destinationDir=rtrim($destination,DIRECTORY_SEPARATOR);
        if($this->currentDirectory!=$destinationDir) {
            $relativePath = str_replace($this->currentDirectory, '', $destination);
            $relativePath = rtrim($relativePath,DIRECTORY_SEPARATOR);
            $relativePath = ltrim($relativePath,DIRECTORY_SEPARATOR);
            $symRelativePath = str_replace($destination, '', $this->currentDirectory);
            if ($symRelativePath == $this->currentDirectory) {
                // We are down in the hierarchy
                $delta=explode('/',$relativePath);
                foreach ($delta as $deltaSegment ) {
                    if ($deltaSegment!=''){
                        $this->ftpClient->changeDirectory($deltaSegment);
                        $this->currentDirectory.=DIRECTORY_SEPARATOR.$deltaSegment;
                    }
                }
            } else {
                // We are up in the hierarchy
                while( $this->currentDirectory!=$destinationDir){
                    $result=$this->ftpClient->parentDirectory();
                    $this->currentDirectory=dirname($this->currentDirectory);
                }
            }
        }
        fLog('FTP Changed directory to '. $this->currentDirectory.cr(),true);

    }


}#BMS#->{"filename":"LocalDeploy.php","checksum":238426920,"relativePath":"BartlebyFlexions\/src\/modules\/Deploy\/LocalDeploy.php","size":1938}<-#BME#
<?php
/**
 * Created by PhpStorm.
 * User: bpds
 * Date: 13/07/15
 * Time: 16:23
 */


require_once "Deploy.php";

class LocalDeploy extends Deploy implements IDeploy{

    function __construct(\Hypotypose $hypotypose){
        $this->_hypotypose=$hypotypose;
        fLog(cr().'LOCAL deploy is running'.cr().cr(),true);
    }

    function  rmPathImplementation($path) {
        $this->_delete($path);
    }

    /**
     * Deletes a file or recursively a folder
     * Returns true if the file or the folder does not exists.
     * @see IOManagerPersistency::delete()
     * @param $filename
     * @return bool
     */
    private function _delete($filename){
        if(!file_exists($filename)){
            return true;
        }
        if(is_dir($filename)){
            // we delete folders with a recursive deletion method
            return $this->_rmdir($filename,true);
        }else{
            return unlink($filename);
        }
    }

    /**
     * @param $dir
     * @param $result
     * @return bool
     */
    private function _rmdir($dir,$result) {
        if (is_dir($dir)) {
            $objects = scandir($dir);
            foreach ($objects as $object) {
                if ($object != "." && $object != "..") {
                    if (filetype($dir.DIRECTORY_SEPARATOR.$object) == "dir")
                        $result=$result&&$this->_rmdir($dir.DIRECTORY_SEPARATOR.$object,$result);
                    else
                        $result=$result&&unlink($dir.DIRECTORY_SEPARATOR.$object);
                }
            }
            $result=$result&&rmdir($dir);
        }
        return $result;
    }


    function copyFilesImplementation($filePath,$destination){
        if(!file_exists( dirname ($destination))) {
            mkdir(dirname($destination), 0777, true);
        }
        fLog('COPYING FROM : '.$filePath.cr().'TO'.$destination.cr(),true);
        copy($filePath,$destination);
    }
}#BMS#->{"filename":"GenerativeHelper.php","checksum":1970899302,"relativePath":"BartlebyFlexions\/src\/modules\/GenHelpers\/classes\/GenerativeHelper.php","size":332}<-#BME#
<?php

require_once FLEXIONS_ROOT_DIR . 'flexions/Core/Hypotypose.php';

class GenerativeHelper{
    
    static function defaultHeader(Flexed $f, $d){
        return '// DEFAULT HEADER';
    }

    static function variablesFromPath($path){
        preg_match_all('/{(.*?)}/', $path, $matches);
        return $matches[1];
    }

}
#BMS#->{"filename":"GenerativeHelperForPhp.class.php","checksum":2759211453,"relativePath":"BartlebyFlexions\/src\/modules\/GenHelpers\/classes\/GenerativeHelperForPhp.class.php","size":522}<-#BME#
<?php
/**
 * Created by PhpStorm.
 * User: bpds
 * Date: 13/07/15
 * Time: 10:37
 */
require_once 'GenerativeHelper.php';

class GenerativeHelperForPhp extends GenerativeHelper {

    static function defaultHeader(Flexed $f, $d) {
        $header = "
/**
* Generated by BARTLEBY'S Flexions for $f->author on ?
* https://github.com/Bartlebys
*
* DO NOT MODIFY THIS FILE YOUR MODIFICATIONS WOULD BE ERASED ON NEXT GENERATION!
*
* Copyright (c) 2016  $f->company  All rights reserved.
*/
";
        return $header;

    }


}#BMS#->{"filename":"GenerativeHelperForSwift.class.php","checksum":857788954,"relativePath":"BartlebyFlexions\/src\/modules\/GenHelpers\/classes\/GenerativeHelperForSwift.class.php","size":16849}<-#BME#
<?php

require_once 'GenerativeHelper.php';
require_once FLEXIONS_MODULES_DIR . 'Languages/FlexionsSwiftLang.php';


class GenerativeHelperForSwift extends GenerativeHelper {


    static function getCurrentClassNameWithPrefix($d, $classesPrefix = "") {
        if (!$d) return '$d should be set in getCurrentClassFragment( )';
        if (property_exists($d, 'name')) {
            return $classesPrefix . $d->name;
        } else {
            return 'UNDEFINDED-CLASS-FRAGMENT';
        }
    }

    static function defaultHeader(Flexed $f, $d) {
        $swiftHeader = "//
//  $f->fileName
//  $f->projectName
//
// THIS FILE AS BEEN GENERATED BY BARTLEBYFLEXIONS for $f->author
// DO NOT MODIFY THIS FILE YOUR MODIFICATIONS WOULD BE ERASED ON NEXT GENERATION!
//
// Copyright (c) 2016  $f->company  All rights reserved.
//";
        return $swiftHeader;

    }


    static function getBaseClass($f, $d) {
        /* @var $d EntityRepresentation */
        /* @var $f Flexed */

        if (isset($d) && isset($d->instanceOf)) {
            return $d->instanceOf;
        } else {
            // Default base  for bartleby
            return GenerativeHelperForSwift::defaultBaseClass($d);
        }
    }

    static function defaultBaseClass($d){
        /* @var $d EntityRepresentation */
        return 'JObject';
    }


    static function isAGeneratedSubClass($d){
        /* @var $d EntityRepresentation */
        return (isset($d) && isset($d->instanceOf));
    }

    //  NSCODING support

    /**
     * @param $d ActionRepresentation || EntityRepresentation
     * @param $increment integer
     */
    static function echoBodyOfInitWithCoder($d, $increment) {

        // NSCoding support for entities and parameters classes.
        // $d may be ActionRepresentation or EntityRepresentation
        $isEntity=($d instanceof EntityRepresentation);

        while ($isEntity?$d->iterateOnProperties():$d->iterateOnParameters() === true) {
            $property = $isEntity?$d->getProperty():$d->getParameter();
            if ($isEntity==true && $property->isSerializable==false){
                continue;
            }
            if (!isset($property->customSerializationMapping)){
                GenerativeHelperForSwift::_echoPropertyForInitWithCoder($property,$increment);
            }else {
                // RECURSIVE CALL FOR CUSTOMSERIALIZATION
                foreach ($property->customSerializationMapping as $property) {
                    GenerativeHelperForSwift::_echoPropertyForInitWithCoder($property, $increment);
                }
            }
        }
    }

    /**
     * @param $property PropertyRepresentation
     * @param $increment integer
     */
    static private function _echoPropertyForInitWithCoder($property, $increment) {
        $name = $property->name;
        $flexionsType = $property->type;
        $asString=(($property->required || $property->default != NULL )? 'as!' : 'as?');
        $nativeType = FlexionsSwiftLang::nativeTypeFor($flexionsType);
        if ($property->isSerializable==false){
            return;
        }
        switch ($flexionsType) {
            case FlexionsTypes::STRING:
                echoIndentCR('self.'.$name . '='.GenerativeHelperForSwift::_decodingFunctionFor($property,$name,$flexionsType) , $increment);
                break;
            case FlexionsTypes::INTEGER:
                echoIndentCR('self.'.$name . '='.GenerativeHelperForSwift::_decodingFunctionFor($property,$name,$flexionsType) , $increment);
                break;
            case FlexionsTypes::BOOLEAN:
                echoIndentCR('self.'.$name . '='.GenerativeHelperForSwift::_decodingFunctionFor($property,$name,$flexionsType) , $increment);
                break;
            case FlexionsTypes::OBJECT:
                echoIndentCR('self.'.$name . '='.GenerativeHelperForSwift::_decodingFunctionFor($property,$name,$flexionsType), $increment);
                break;
            case FlexionsTypes::COLLECTION:
                $instanceOf=FlexionsSwiftLang::nativeTypeFor($property->instanceOf);
                if ($instanceOf==FlexionsTypes::NOT_SUPPORTED){
                    $instanceOf=$property->instanceOf;
                }
                echoIndentCR('self.'.$name . '='.GenerativeHelperForSwift::_decodingFunctionFor($property,$name,$flexionsType) .$asString.' [' . ucfirst($instanceOf) . ']' , $increment);
                break;
            case FlexionsTypes::ENUM:
                echoIndentCR('self.'.$name . '='.GenerativeHelperForSwift::_decodingFunctionFor($property,$name,$flexionsType), $increment);
                break;
            case FlexionsTypes::FILE:
                echoIndentCR('self.'.$name . '='.GenerativeHelperForSwift::_decodingFunctionFor($property,$name,$flexionsType).$asString.' ' .$nativeType . '' , $increment);
                break;
            case FlexionsTypes::DICTIONARY:
                echoIndentCR('self.'.$name . '='.GenerativeHelperForSwift::_decodingFunctionFor($property,$name,$flexionsType).$asString.' ' .$nativeType . '' , $increment);
                break;
            case FlexionsTypes::FLOAT:
                echoIndentCR('self.'.$name . '='.GenerativeHelperForSwift::_decodingFunctionFor($property,$name,$flexionsType) , $increment);
                break;
            case FlexionsTypes::DOUBLE:
                echoIndentCR('self.'.$name . '='.GenerativeHelperForSwift::_decodingFunctionFor($property,$name,$flexionsType) , $increment);
                break;
            case FlexionsTypes::BYTE:
                echoIndentCR('var ref' . ucfirst($name) . '=1;' , $increment);
                // ??
                echoIndentCR('self.'.$name . '='.GenerativeHelperForSwift::_decodingFunctionFor($property,$name,$flexionsType).'("' . $name . '",&ref' . ucfirst($name) . ')' , $increment);
                break;
            case FlexionsTypes::DATETIME:
                echoIndentCR('self.'.$name . '='.GenerativeHelperForSwift::_decodingFunctionFor($property,$name,$flexionsType) , $increment);
                break;
            case FlexionsTypes::URL:
                echoIndentCR('self.'.$name . '='.GenerativeHelperForSwift::_decodingFunctionFor($property,$name,$flexionsType), $increment);
                break;
            case FlexionsTypes::DATA:
                echoIndentCR('self.'.$name . '='.GenerativeHelperForSwift::_decodingFunctionFor($property,$name,$flexionsType), $increment);
                break;
            case FlexionsTypes::NOT_SUPPORTED:
                echoIndentCR('//' . 'self.'.$name . 'is not supported' , $increment);
                break;
            default :
                echoIndentCR('//TODO:' . $name . ' HAS NOT BEEN GENERATED (GENERATIVE TEMPLATE NEEDS TO BE AMENDED)' , $increment);
                break;

        }
    }

    /**
     * @param $property PropertyRepresentation
     * @param $keyName string
     * @param $flexionsType string
     * @return string
     */
    private static function _decodingFunctionFor($property,$keyName,$flexionsType){
        $isNotOptionnal = ($property->required || $property->default != NULL );
        switch ($flexionsType) {
            case FlexionsTypes::STRING:
                if ($isNotOptionnal){
                    return 'String(describing: decoder.decodeObject(of: NSString.self, forKey: "'.$keyName.'")! as NSString)';
                }else{
                    return 'String(describing: decoder.decodeObject(of: NSString.self, forKey:"'.$keyName.'") as NSString?)';
                }
            case FlexionsTypes::INTEGER:
                return 'decoder.decodeInteger(forKey:"'.$keyName.'") ';
            case FlexionsTypes::BOOLEAN:
                return 'decoder.decodeBool(forKey:"'.$keyName.'") ';
            case FlexionsTypes::OBJECT:
                //return 'decodeObjectForKey("'.$keyName.'") ';
                $instanceOf=$property->instanceOf;
                /*
                  if (strpos($instanceOf,'Alias')!==false){
                      $instanceOf="Alias";
                  }
                */
                return  'decoder.decodeObject(of:'.$instanceOf.'.self, forKey: "'.$keyName.'")'.($isNotOptionnal ?'! ':' ');
            case FlexionsTypes::COLLECTION:
                if ($property->instanceOf == FlexionsTypes::STRING ){
                    return  'decoder.decodeObject(of: [NSArray.classForCoder(),NSString.self], forKey: "'.$keyName.'")'.($isNotOptionnal ?'! ':' ');
                }else if($property->instanceOf == FlexionsTypes::INTEGER || $property->instanceOf == FlexionsTypes::DOUBLE || $property->instanceOf == FlexionsTypes::FLOAT){
                    return  'decoder.decodeObject(of: [NSArray.classForCoder(),NSNumber.self], forKey: "'.$keyName.'")'.($isNotOptionnal ?'! ':' ');
                } else if ($property->instanceOf == FlexionsTypes::DICTIONARY) {
                    return 'decoder.decodeObject(of: [NSArray.classForCoder(),NSDictionary.classForCoder()], forKey: "' . $keyName . '")' . ($isNotOptionnal ? '! ' : ' ');
                }else{
                    return  'decoder.decodeObject(of: [NSArray.classForCoder(),'.$property->instanceOf.'.classForCoder()], forKey: "'.$keyName.'")'.($isNotOptionnal ?'! ':' ');
                }

            case FlexionsTypes::ENUM:
                // .$asString.' '. ucfirst($property->emumPreciseType)
                // User.Status(rawValue:String(describing: decoder.decodeObject(NSString.self, forKey: "status")! as NSString))!
                return $property->emumPreciseType.'(rawValue:'.GenerativeHelperForSwift::_decodingFunctionFor($property,$keyName,$property->instanceOf).')'.($isNotOptionnal ?'! ':' ');
            case FlexionsTypes::DICTIONARY;
                return  'decoder.decodeObject(of: [NSDictionary.classForCoder(),NSString.classForCoder(),NSNumber.classForCoder(),NSObject.classForCoder(),NSSet.classForCoder()], forKey: "'.$keyName.'")';
            case FlexionsTypes::FLOAT:
                return 'decoder.decodeFloat(forKey:"'.$keyName.'") ';
            case FlexionsTypes::DOUBLE:
                return 'decoder.decodeDouble(forKey:"'.$keyName.'") ';
            case FlexionsTypes::BYTE:
                return 'decoder.decodeBytes-(forKey:"'.$keyName.'") ';

            // NOTE NSDate, NSURL, NSData requires to use <OBJC_TYPE>.self
            // This may change soon

            case FlexionsTypes::DATETIME:
                if ($isNotOptionnal){
                    return 'decoder.decodeObject(of: NSDate.self , forKey: "'.$keyName.'")! as Date';
                }else{
                    return 'decoder.decodeObject(of: NSDate.self , forKey:"'.$keyName.'") as Date?';
                }
            case FlexionsTypes::URL :
                if ($isNotOptionnal){
                    return 'decoder.decodeObject(of: NSURL.self, forKey: "'.$keyName.'")! as URL';
                }else{
                    return 'decoder.decodeObject(of: NSURL.self, forKey:"'.$keyName.'") as URL?';
                }
            case FlexionsTypes::FILE :
                if ($isNotOptionnal){
                    return 'decoder.decodeObject(of: NSURL.self, forKey: "'.$keyName.'")! as URL';
                }else{
                    return 'decoder.decodeObject(of: NSURL.self, forKey:"'.$keyName.'") as URL?';
                }
            case FlexionsTypes::DATA:
                if ($isNotOptionnal){
                    //return '//NOT IMPLEMETED - decodeObject DATA';
                    return 'decoder.decodeObject(of: NSData.self, forKey: "'.$keyName.'")! as Data';
                }else{
                    return 'decoder.decodeObject(of: NSData.self, forKey:"'.$keyName.'") as Data?';
                }
            case FlexionsTypes::NOT_SUPPORTED:
                return FlexionsTypes::NOT_SUPPORTED;
                break;
            default :
                return FlexionsTypes::VOID;
                break;
        }
    }



    /**
     * @param $d ActionRepresentation || EntityRepresentation
     * @param $increment integer
     */
    static  function echoBodyOfEncodeWithCoder($d,$increment){

        // NSCoding support for entities and parameters classes.
        // $d may be ActionRepresentation or EntityRepresentation
        $isEntity=($d instanceof EntityRepresentation);

        while ($isEntity?$d->iterateOnProperties():$d->iterateOnParameters() === true) {

            /* @var $property PropertyRepresentation */
            $property = $isEntity?$d->getProperty():$d->getParameter();
            if ($isEntity==true && $property->isSerializable==false){
                continue;
            }
            if (!isset($property->customSerializationMapping)){
                GenerativeHelperForSwift::_echoPropertyForEncodeWithCoder($property,$increment);
            }else {
                // RECURSIVE CALL FOR CUSTOMSERIALIZATION
                foreach ($property->customSerializationMapping as $property) {
                    GenerativeHelperForSwift::_echoPropertyForEncodeWithCoder($property, $increment);
                }
            }

        }
    }

    /**
     * @param $property PropertyRepresentation
     * @param $increment integer
     */
    static private function _echoPropertyForEncodeWithCoder($property, $increment) {
        $name = $property->name;
        $incrementPlusOne=$increment+1;
        $securizedName=$name;

        $shouldUseIfString=($property->required===false);
        if (isset($property->default) && $property->default!='' && $property->default!=' ' && $property->required==false ){
            $shouldUseIfString=false;
        }

        // We may enclose the encoding within a it let ... { ... } expression
        // to unwrap optionnals.

        if ($shouldUseIfString){
            $securizedName=str_replace(".","_",$name);
            $currentIncrement=$incrementPlusOne;
            echoIndentCR('if let '.$securizedName.' = self.'.$name.' {', $increment);
        }else{
            $currentIncrement=$increment;
        }
        $encodingFunction=NULL;
        if (!isset($property->type)){
            echoIndentCR('//' . $name . ' HAS NOT BEEN GENERATED (GENERATIVE TEMPLATE NEEDS TO BE AMENDED)' , $increment);
            return;
        }
        if ($property->type===FlexionsTypes::NOT_SUPPORTED){
            echoIndentCR('//'.$name .'is not supported' , $increment);
            return;
        }

        $keyToEncode=$securizedName;
        if ($property->type===FlexionsTypes::ENUM && ($property->instanceOf===FlexionsTypes::STRING || $property->instanceOf===FlexionsTypes::INTEGER)){
            //Casting is required
            $keyToEncode=$securizedName.'.rawValue ';
        }

        if (!$shouldUseIfString){
            $keyToEncode='self.'.$keyToEncode;
        }

        echoIndentCR('coder.'.GenerativeHelperForSwift::_encodingFunctionFor($property->type,$property->instanceOf).'('.$keyToEncode.',forKey:"'. $name .'")' , $currentIncrement);
        if ($shouldUseIfString){
            echoIndentCR('}', $increment);
        }
    }


    /**
     * @param $flexionsType
     * @param string $instanceOf
     * @return string
     */
    private static function _encodingFunctionFor($flexionsType,$instanceOf='UNDEFINED'){
        switch ($flexionsType) {
            case FlexionsTypes::STRING:
                return 'encode';
            case FlexionsTypes::INTEGER:
                return 'encode';
            case FlexionsTypes::BOOLEAN:
                return 'encode';
            case FlexionsTypes::OBJECT:
                return 'encode';
            case FlexionsTypes::COLLECTION:
                return 'encode';
            case FlexionsTypes::ENUM;
                // We have 3 levels :
                // When the type is an ENUM, you can specify its precise type
                // Swift enum can be typed. We want to be able to cast the enums.
                // E.g : property status type=enum, instanceOf=string , enumPreciseType=User.status
                return GenerativeHelperForSwift::_encodingFunctionFor($instanceOf);
            case FlexionsTypes::FILE:
                return 'encode';
            case FlexionsTypes::DICTIONARY:
                return 'encode';
            case FlexionsTypes::FLOAT:
                return 'encode';
            case FlexionsTypes::DOUBLE:
                return 'encode';
            case FlexionsTypes::BYTE:
                return 'encode';
            case FlexionsTypes::DATETIME:
                return 'encode';
            case FlexionsTypes::URL:
                return 'encode';
            case FlexionsTypes::DATA:
                return 'encode';
            case FlexionsTypes::NOT_SUPPORTED:
                return FlexionsTypes::NOT_SUPPORTED;
            default :
                return FlexionsTypes::VOID;
        }
    }

}

?>#BMS#->{"filename":"FlexionsSwiftLang.php","checksum":3264193327,"relativePath":"BartlebyFlexions\/src\/modules\/Languages\/FlexionsSwiftLang.php","size":1640}<-#BME#
<?php

require_once FLEXIONS_ROOT_DIR . 'flexions/representations/flexions/IFlexionsLanguageMapping.php';
require_once FLEXIONS_ROOT_DIR . 'flexions/representations/flexions/FlexionsTypes.php';

class FlexionsSwiftLang implements IFlexionsLanguageMapping {


    /**
     * @param  $flexionsType
     * @return String the native type
     */
    static function nativeTypeFor($flexionsType) {
        switch ($flexionsType) {
            case FlexionsTypes::STRING:
                return 'String';
            case FlexionsTypes::INTEGER:
                return 'Int';
            case FlexionsTypes::BOOLEAN:
                return 'Bool';
            case FlexionsTypes::OBJECT:
                return 'Object';//Pseudo type (the instanceOf type will apply)
            case FlexionsTypes::COLLECTION:
                return 'Collection';//Pseudo type (the instanceOf type will apply)
            case FlexionsTypes::ENUM:
                return 'Emum';//Pseudo type (the instanceOf type will apply)
            case FlexionsTypes::FILE:
                return 'URL';
            case FlexionsTypes::FLOAT:
                return 'Float';
            case FlexionsTypes::DOUBLE:
                return 'Double';
            case FlexionsTypes::BYTE:
                return 'UInt8';
            case FlexionsTypes::DATETIME:
                return 'Date';
            case FlexionsTypes::URL:
                return 'URL';
            case FlexionsTypes::DICTIONARY:
                return '[String:Any]';
            case FlexionsTypes::DATA:
                return 'Data';
        }
        return FlexionsTypes::NOT_SUPPORTED;
    }

}#BMS#->{"filename":"LGPL.template.php","checksum":1627426981,"relativePath":"BartlebyFlexions\/src\/modules\/Licenses\/LGPL.template.php","size":824}<-#BME#
<?php /* @var $f Flexed */ ?>
// This file is part of "<?php echo $f->projectName."\"\n";?>
// 
// "<?php echo $f->projectName;?>" is free software: you can redistribute it and/or modify
// it under the terms of the GNU LESSER GENERAL PUBLIC LICENSE as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// "<?php echo $f->projectName;?>" is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU LESSER GENERAL PUBLIC LICENSE for more details.
// 
// You should have received a copy of the GNU LESSER GENERAL PUBLIC LICENSE
// along with "<?php echo $f->projectName;?>"  If not, see <http://www.gnu.org/licenses/>
// 
#BMS#->{"filename":"ISwaggerDelegate.php","checksum":790965171,"relativePath":"BartlebyFlexions\/src\/modules\/SwaggerToFlexions\/ISwaggerDelegate.php","size":235}<-#BME#
<?php
/**
* Created by PhpStorm.
* User: bpds
* Date: 11/07/15
* Time: 10:36
*/

interface ISwaggerDelegate{
/**
* @param $prefix
* @param $baseClassName
* @return string
*/
function getCollectionClassName($prefix,$baseClassName);
}
?>#BMS#->{"filename":"README.md","checksum":855804692,"relativePath":"BartlebyFlexions\/src\/modules\/SwaggerToFlexions\/README.md","size":3733}<-#BME#
# Swagger to Flexions 
 
**TODO CHECK the IMPLEMENTATION AND VALIDATE THIS DOCUMENT**
 
Our modeling approach was inspired by SWAGGER 2.0. **But it is not strictly compliant!**
We have added optional extensions : Bartleby Metadata. 
That's enough for modeling APIS and Entities with Flexions.


NOT SUPPORTED ANYMORE? 
IMPORTANT to support login and logout generation you must include the signature in the path
And add a security key that maps to the security definitions.

SWAGGER complete specs are available accessible [on github] (https://github.com/swagger-api/swagger-spec/blob/master/versions/2.0.md)

## Not supported ##

- "object" + "additionalProperties" Swagger usage of additionalProperties is not compliant with [JSON Schema](http://json-schema.org/example2.html)
- "consumes" and "produces" (as we generate both client and servers the generation template can decide to use JSON or XML or anything else)
- Resolution of $ref we extract the entity from the reference
- We prefer to use a fully typed approach so you should define (in definitions) and $ref an entity as much as possible.

# Actions extensions

# Entities extensions

## Entities Metadata 

The metadata model is extensible.

```Javascript
     		
			 "metadata": {
                "urdMode": false,
                "persistsLocallyOnlyInMemory": false,
                "allowDistantPersistency": false,
                "undoable":false,
                "groupable":true
            }
```
            

### Currently used keys :

+ urdMode (to specify to the generator if it should generate  a URD or CRUD stack. It can be used in templates by calling ```$entityRepresentation->usesUrdMode()```
+ persistsLocallyOnlyInMemory ( is saved locally?)
+ allowDistantPersistency (create a CRUD stack)
+ undoable  ( undo manager support )
+ groupable (groupable on auto commit)


## Entities explicitType 

You can add an explicitType for an entity (that as not been generated)

```javascript
     "A": {
            "explicitType": "NSObject",
            "description": "A is ...",
            "allOf": []
            }
```


# Properties extensions


## dynamic 
mark as dynamic 

## serializable

In this case we don't want the property proxy to serialized

```
  "proxy": {
                            "explicitType": "JObject",
                            "description": "",
                            "dynamic": false,
                            "serializable":false
                        },
```


## supervisable

If a property is marked as supervisable any change will mark its parent as changed.

```
  "fruit": {
                            ...
                            "supervisable":false
                        },
```

## cryptable

If a property is marked as cryptable on serialization it should be crypted.

```
  "password": {
                            ...
                            "cryptable":true
                        },
```




## Properties explicitType 

You can specify an explicit type (that is not necessarly generated) by specifying the type "object".

```javascript
 "dmgCard": {
	"description": "The associated dmg Card",
    "type": "object",
    "explicitType":"BsyncDMGCard"
},
```

## Properties dictionaries

You can use the **dictionary** type, for parameters & properties

```javascript
"parameters":[
	{
		"in": "body",
		"name": "sort",
		"description": "the sort (MONGO DB)",
		"required": true,
		"type": "dictionary"
	}
]
```


# Tip and Tricks 

You can add **default native functions** if your generated targets can afford it!


### native functions

```javascript
      "startDate": {
         "type": "date",
       	"definition": "the starting date",
          "default": "NSDate()"
	}             
```#BMS#->{"filename":"SwaggerDelegate.php","checksum":2303217113,"relativePath":"BartlebyFlexions\/src\/modules\/SwaggerToFlexions\/SwaggerDelegate.php","size":511}<-#BME#
<?php

require_once 'ISwaggerDelegate.php';

// If necessary we define COLLECTION_OF
if (!defined('COLLECTION_OF')) {
    define("COLLECTION_OF", "CollectionOf");
}

/**
 * Class XcdataModelDelegate
 * Default implementation
 */
class SWaggerDelegate implements ISwaggerDelegate {

    /**
     * @param $prefix
     * @param $baseClassName
     * @return string
     */
    function getCollectionClassName($prefix, $baseClassName) {
        return ucfirst($prefix) . COLLECTION_OF . $baseClassName;
    }
}

?>#BMS#->{"filename":"SwaggerToFlexionsRepresentations.php","checksum":995319174,"relativePath":"BartlebyFlexions\/src\/modules\/SwaggerToFlexions\/SwaggerToFlexionsRepresentations.php","size":25562}<-#BME#
<?php

require_once FLEXIONS_ROOT_DIR . 'flexions/representations/flexions/FlexionsRepresentationsIncludes.php';
require_once FLEXIONS_MODULES_DIR . 'SwaggerToFlexions/ISwaggerDelegate.php';

if (!defined('SWAGGER_VERSION')) {

    define('SWAGGER_VERSION', 'swagger');
    define('SWAGGER_INFO', 'info');
    define('SWAGGER_TITLE', 'title');
    define('SWAGGER_HOST', 'host');
    define('SWAGGER_BASE_PATH', 'basePath');
    define('SWAGGER_TAGS', 'tags');
    define('SWAGGER_SCHEMES', 'schemes');
    define('SWAGGER_PATHS', 'paths');
    define('SWAGGER_SECURITY_DEFINITIONS', 'securityDefinitions');
    define('SWAGGER_DEFINITIONS', 'definitions');
    define('SWAGGER_EXTERNAL_DOCS', 'externalDocs');
    define('SWAGGER_TYPE', 'type');
    define('SWAGGER_ENUM', 'enum');
    define('SWAGGER_OBJECT', 'object');
    define('SWAGGER_PROPERTIES', 'properties');
    define('SWAGGER_DESCRIPTION', 'description');
    define('SWAGGER_FORMAT', 'format');
    define('SWAGGER_ITEMS', 'items');
    define('SWAGGER_REF', '$ref');
    define('SWAGGER_DEFAULT','default');
    define('SWAGGER_ALL_OF','allOf');// Inheritance and composition
    define('SWAGGER_OPERATION_ID', 'operationId');
    define('SWAGGER_PARAMETERS', 'parameters');
    define('SWAGGER_NAME', 'name');
    define('SWAGGER_SCHEMA', 'schema');
    define('SWAGGER_REQUIRED', 'required');
    define('SWAGGER_RESPONSES', 'responses');
    define('SWAGGER_OAUTH_AUTHORIZATION_URL','authorizationUrl');
    define('SWAGGER_OAUTH_SCOPES','scopes');
    define('SWAGGER_IN','in');
    define('SWAGGER_SECURITY','security');

    define ('SWAGGER_HEADERS','headers');

    define('EXTENDED_INSTANCE_OF','instanceOf');
    define('EXTENDED_IS_DYNAMIC','dynamic');
    define('EXTENDED_SERIALIZABLE','serializable');
    define('EXTENDED_SUPERVISABLE','supervisable');
    define('EXTENDED_CRYPTABLE','cryptable');// Crypted on serialization
    define('EXTENDED_ENUM_PRECISE_TYPE','emumPreciseType');
    define('EXTENDED_EXPLICIT_TYPE','explicitType'); // used to pass an explicit type that has not been generated

    define('EXTENDED_METADATA','metadata');
    define('USE_COMPOSITION_MODE',true); // If set to true entities are composed else they use inheritance
}



/**
* Check README.md
 * Class SwaggerToFlexionsRepresentations
 */
class SwaggerToFlexionsRepresentations {


    /**
     * @param $descriptorFilePath
     * @param string $nativePrefix
     * @param ISwaggerDelegate|null $delegate
     * @param array $signInSignature
     * @param array $signOutSignature
     * @return ProjectRepresentation|void
     * @throws Exception
     */
    function projectRepresentationFromSwaggerJson($descriptorFilePath, $nativePrefix = "", ISwaggerDelegate $delegate=null,array $signInSignature=array(),array $signOutSignature=array(),$useCompositionMode=USE_COMPOSITION_MODE) {

        if (!isset($delegate)) {
            fLog("projectRepresentationFromSwaggerJson.projectRepresentationFromSwaggerJson() module requires an ISwaggerDelegate", true);
            return;
        }

        fLog("Invoking projectRepresentationFromSwaggerJson.projectRepresentationFromSwaggerJson() on " . $descriptorFilePath . cr() . cr(), true);

        // #1 Create the ProjectRepresentation

        $r = new ProjectRepresentation ();
        $r->classPrefix = $nativePrefix;
        $r->name = 'NO_NAME';
        $s = file_get_contents($descriptorFilePath);
        $json = json_decode($s, true);
        $r->metadata = $json;// We store the raw descriptor as a metadata

        if (array_key_exists(SWAGGER_INFO, $json)) {
            if (array_key_exists(SWAGGER_INFO, $json)) {
                $nameOfProject = $json[SWAGGER_INFO][SWAGGER_TITLE];
                $nameOfProject = str_replace(' ', '_', $nameOfProject);
                $r->name = $nameOfProject;
            }
        }

        if ($json[SWAGGER_VERSION] = '2.0') {

            $r->baseUrl = $json[SWAGGER_SCHEMES][0] . '://' . $json[SWAGGER_HOST] . $json[SWAGGER_BASE_PATH];
            $r->apiVersion = rtrim($json[SWAGGER_BASE_PATH], '/');

            // Store a reference of PermissionRepresentation to be cloned in each action.
            if (array_key_exists(SWAGGER_SECURITY_DEFINITIONS, $json)) {
                $securityDefinitions = $json[SWAGGER_SECURITY_DEFINITIONS];
                foreach ($securityDefinitions as $name => $descriptor) {
                   if(array_key_exists(SWAGGER_TYPE, $descriptor)){
                       $type=strtolower($descriptor[SWAGGER_TYPE]);
                       /*@var $p PermissionRepresentation */
                       $p = null;
                       if($type=="oauth2"){
                           $p=new PermissionRepresentationOauth();
                           $p->setPermissionName($name);
                           if(array_key_exists(SWAGGER_OAUTH_AUTHORIZATION_URL, $descriptor)){
                             $p->authorizationUrl=$descriptor[SWAGGER_OAUTH_AUTHORIZATION_URL];
                           }
                           if(array_key_exists(SWAGGER_OAUTH_SCOPES, $descriptor)){
                               $scopes=$descriptor[SWAGGER_OAUTH_SCOPES];
                               foreach ($scopes as $scopeName=>$description) {
                                   if(isset($scopeName) && isset($description)){
                                       $p->addScope(array($scopeName=>$description));
                                   }else{
                                       throw new Exception('Invalid scope' . json_encode($scopes),90);
                                   }
                                }
                           }
                       }
                       if($type=="apikey"){
                           $p=new PermissionRepresentationWithAccessRights();
                           $p->setPermissionName($name);
                           if(array_key_exists(SWAGGER_IN, $descriptor)){
                               $in=strtolower($descriptor[SWAGGER_IN]);
                               if($in=='header'){
                                   $p->setLocation(PermissionLocation::IN_HEADERS);
                               }else{
                                   $p->setLocation(PermissionLocation::IN_PARAMETERS);
                               }
                           }

                       }
                       if(isset ($p)){
                           $this->_permissionsByName[$name] = $p;
                       }else{
                           throw new Exception('Unsupported PermissionRepresentation type :' . $type,100);
                       }

                    }else{
                       throw new Exception('Malformed security definition name:' . $name.' descriptor as a json:'.json_encode($descriptor),101);
                   }
                }
            }


            // #2 Extract the entities EntityRepresentation
            //from definitions :
            if (array_key_exists(SWAGGER_DEFINITIONS, $json)) {
                $definitions = $json[SWAGGER_DEFINITIONS];
                foreach ($definitions as $entityName => $descriptor) {
                    $e = new EntityRepresentation();

                    if(array_key_exists(SWAGGER_DESCRIPTION,$descriptor)){
                        $e->description=$descriptor[SWAGGER_DESCRIPTION];
                    }

                    $e->name = $nativePrefix . ucfirst($entityName);

                    $properties=array();


                    $explicitTypeIsDefined=array_key_exists(EXTENDED_EXPLICIT_TYPE, $descriptor);
                    if ( array_key_exists(SWAGGER_TYPE, $descriptor) ||  $explicitTypeIsDefined ){

                        // It is root Object not AllOf
                        if ($explicitTypeIsDefined){
                            $explicitType = $descriptor[EXTENDED_EXPLICIT_TYPE];
                            $e->instanceOf=$explicitType;
                        }

                        if ($descriptor[SWAGGER_TYPE] === SWAGGER_OBJECT || $explicitTypeIsDefined ) {
                            if (array_key_exists(SWAGGER_PROPERTIES, $descriptor)) {
                                $properties = $descriptor[SWAGGER_PROPERTIES];
                            }
                        }
                    } else {
                        // Entity is not a base object
                        if(array_key_exists(SWAGGER_ALL_OF,$descriptor)){
                            $allOF=$descriptor[SWAGGER_ALL_OF];
                            $refs=array();
                            $parentRef=NULL;
                            foreach ($allOF as $currentItem) {
                                if (is_array($currentItem)){
                                    if(array_key_exists(SWAGGER_REF, $currentItem)){

                                        if ($useCompositionMode == true) {
                                            // COMPOSITION
                                            $keyForRef=$currentItem[SWAGGER_REF];
                                            $keyForRef=str_replace("#/definitions/","",$keyForRef);
                                            $subDefinition=$definitions[$keyForRef];
                                            if(array_key_exists(SWAGGER_PROPERTIES, $subDefinition)){
                                                $properties=$subDefinition[SWAGGER_PROPERTIES];
                                            }
                                        }else{
                                            // INHERITANCE :
                                            $parentRef=$currentItem[SWAGGER_REF];
                                            $refs[]=$parentRef;
                                        }

                                    }
                                    if(array_key_exists(SWAGGER_PROPERTIES, $currentItem)){
                                        $currentItemProperties=$currentItem[SWAGGER_PROPERTIES];
                                        $properties=array_merge($properties,$currentItemProperties);
                                    }
                                }
                            }

                            if(count($refs)==1){
                                // Inheritance support
                                $e->instanceOf=$this->typeFromRef($parentRef,$nativePrefix);
                            }else if( count($refs)>1){
                                // ??? WE DONNOT SUPPORT MULTIPLE INHERITANCE
                            }
                            if(array_key_exists(SWAGGER_PROPERTIES,$allOF)){
                                $properties=$allOF[SWAGGER_PROPERTIES];
                            }
                        }
                    }
                    // Parse the properties
                    foreach ($properties as $propertyName => $propertyValue) {
                        $e->properties[] = $this->_extractPropertyFrom($propertyName, $propertyValue, $nativePrefix);
                    }

                    // Entity metadata
                    if (array_key_exists(EXTENDED_METADATA, $descriptor)) {
                        $e->metadata = $descriptor[EXTENDED_METADATA];
                    }
                    $r->entities[] = $e;
                }

            }

            //#3 Extract the actions ActionRepresentation
            if (array_key_exists(SWAGGER_PATHS, $json)) {
                $paths = $json[SWAGGER_PATHS];
                foreach ($paths as $path => $pathDescriptor) {

                    foreach ($pathDescriptor as $method => $methodPathDescriptor) {
                        $className = '';

                        if (array_key_exists(SWAGGER_OPERATION_ID, $methodPathDescriptor)) {
                            $className = $nativePrefix . ucfirst($methodPathDescriptor[SWAGGER_OPERATION_ID]);
                        } else {
                            $className = $nativePrefix . $this->_classNameForPath($path);
                        }
                        $action = new ActionRepresentation();
                        $action->class = $className;
                        $action->path = $path;
                        $action->httpMethod = strtoupper($method);

                        if(array_key_exists(SWAGGER_TAGS,$methodPathDescriptor)){
                            $tags=$methodPathDescriptor[SWAGGER_TAGS];
                            if(is_array($tags)&&count($tags)>0){
                                $action->collectionName=$tags[0];
                            }
                        }

                        if (array_key_exists(SWAGGER_PARAMETERS, $methodPathDescriptor)) {
                            $parameters = $methodPathDescriptor[SWAGGER_PARAMETERS];
                            foreach ($parameters as $parameter) {
                                if (array_key_exists(SWAGGER_NAME, $parameter)) {
                                    $property = $this->_extractPropertyFrom($parameter[SWAGGER_NAME], $parameter, $nativePrefix);
                                    $action->parameters[] = $property;
                                }
                            }
                        }

                        if (array_key_exists(SWAGGER_RESPONSES, $methodPathDescriptor)) {
                            $responses = $methodPathDescriptor[SWAGGER_RESPONSES];
                            foreach ($responses as $name => $response) {
                                if ($name=="default"){
                                    $name="200";// We consider default as a succes.
                                }
                                $property = $this->_extractPropertyFrom("$name", $response, $nativePrefix);
                                $action->responses[] = $property;
                            }
                        }

                        // security

                        if (array_key_exists(SWAGGER_SECURITY, $methodPathDescriptor)) {
                            $security = $methodPathDescriptor[SWAGGER_SECURITY];
                            foreach ($security as $collection) {
                                foreach ($collection as $securityItemName=>$securityItem) {
                                    // The security context is extracted using the action name semantics.


                                    $actionPath=strtolower($action->class);
                                    $actionPath=str_replace('_','',$actionPath);
                                    $actionPath=str_replace('-','',$actionPath);

                                    $containsSignInSignature=false;
                                    foreach ($signInSignature as $signature ) {
                                        if((strpos($actionPath,$signature)!==false)){
                                            $containsSignInSignature=true;
                                        }
                                    }

                                    $containsSignOutSignature=false;
                                    foreach ($signOutSignature as $signature ) {
                                        if((strpos($actionPath,$signature)!==false)){
                                            $containsSignOutSignature=true;
                                        }
                                    }
                                    if($containsSignInSignature==true){
                                        $action->security=$this->getContextPermissionByName($securityItemName,RelationToPermission::PROVIDES);
                                    }else if($containsSignOutSignature==true){
                                        $action->security=$this->getContextPermissionByName($securityItemName,RelationToPermission::DISCARDS);
                                    }else{
                                        // By default we consider that the security is required.
                                        $action->security=$this->getContextPermissionByName($securityItemName,RelationToPermission::REQUIRES);
                                    }
                                }
                            }
                        }

                        // Action metadata
                        if (array_key_exists(EXTENDED_METADATA, $methodPathDescriptor)) {
                            $action->metadata = $methodPathDescriptor[EXTENDED_METADATA];
                        }
                        $r->actions[] = $action;
                    }
                }
            }
        } else {
            throw new Exception('Unsupported swagger version' . $json[SWAGGER_VERSION],0);
        }
        return $r;
    }



    private $_permissionsByName=array();


    /**
     * Returns the context for a given permission name
     * @param $name
     * @param string $relationToPermission
     * @throws exception
     * @return SecurityContextRepresentation
     */
    private function getContextPermissionByName($name,$relationToPermission=RelationToPermission::REQUIRES){

        $rtp=new RelationToPermission();
        if(!$rtp->isValid($relationToPermission)){
            throw new exception("invalid RelationToPermission the relation is not present in the enumeration : ".$relationToPermission,10);
        }

        if (array_key_exists($name,$this->_permissionsByName)) {
            $permission=$this->_permissionsByName[$name];
            $cloned=clone $permission;// We clone the permission
            $context=new SecurityContextRepresentation();
            $context->setPermission($cloned);
            $context->setRelation($relationToPermission);
            return $context;
        }else{
            throw new Exception('Permission with name : '.$name.' does not exists :',11);
        }
    }



    /**
     * @param string $propertyName
     * @param $propertyValue
     * @param string $nativePrefix
     * @return PropertyRepresentation
     */
    private function _extractPropertyFrom($propertyName, $propertyValue, $nativePrefix) {
        // type, format, description
        $propertyR = new PropertyRepresentation();
        $propertyR->name = $propertyName;
        if (is_array($propertyValue)) {
            $context=$propertyValue;
            if (array_key_exists(SWAGGER_SCHEMA, $propertyValue)) {
                // Seen in parameters.
                $context=$propertyValue[SWAGGER_SCHEMA];
            }
            // Most common
            $this->_parsePropertyType($propertyR, $context, $nativePrefix);
        }
        return $propertyR;
    }


    /**
     * Sub parsing method used to factorize parsing (as swagger is not fully regular)
     *
     * @param PropertyRepresentation $propertyR
     * @param $dictionary
     * @param $nativePrefix
     */
    private function _parsePropertyType(PropertyRepresentation $propertyR, $dictionary, $nativePrefix) {
        if (array_key_exists(SWAGGER_ITEMS, $dictionary)) {
            $subDictionary = $dictionary[SWAGGER_ITEMS];
            $propertyR->type = FlexionsTypes::COLLECTION;
            $this->_propertyFromDictionary($propertyR,$subDictionary,$nativePrefix);
        }else{
            $this->_propertyFromDictionary($propertyR,$dictionary,$nativePrefix);
        }
    }

    /**
     * @param $propertyR PropertyRepresentation
     * @param $dictionary
     */
    private function _propertyFromDictionary($propertyR,$dictionary,$nativePrefix){

        if (array_key_exists(SWAGGER_ENUM, $dictionary)) {
            $propertyR->type = FlexionsTypes::ENUM;
            $enums = $dictionary[SWAGGER_ENUM];
            foreach ($enums as $enumerableElement) {
                $propertyR->enumerations[] = $enumerableElement;
            }
            if (array_key_exists(SWAGGER_ENUM, $dictionary)){
                $propertyR->emumPreciseType=$dictionary[EXTENDED_ENUM_PRECISE_TYPE];
            }else {
                $propertyR->emumPreciseType = "Enum extended type is not defined for property " . $propertyR->name ;
            }
        }

        $swaggerType = null;
        if (array_key_exists(SWAGGER_TYPE, $dictionary)) {
            $swaggerType = $dictionary[SWAGGER_TYPE];
            $propertyR->metadata['SWAGGER_TYPE'] = $swaggerType;
        }

        if (array_key_exists(EXTENDED_INSTANCE_OF, $dictionary)) {
            $propertyR->instanceOf= $dictionary[EXTENDED_INSTANCE_OF];;
        }

        if (array_key_exists(EXTENDED_IS_DYNAMIC, $dictionary)) {
            $propertyR->isDynamic=$dictionary[EXTENDED_IS_DYNAMIC];
        }


        if ($propertyR->type == FlexionsTypes::ENUM){
            $propertyR->isDynamic=false;
        }

        $swaggerFormat = null;
        if (array_key_exists(SWAGGER_FORMAT, $dictionary)) {
            $swaggerFormat = $dictionary[SWAGGER_FORMAT];
            $propertyR->metadata['SWAGGER_FORMAT'] = $swaggerFormat;
        }

      if (array_key_exists(SWAGGER_REF, $dictionary)) {
            $ref = $dictionary[SWAGGER_REF];
            // Its it a single reference.
            if (!isset($propertyR->type)) {
                $propertyR->type = FlexionsTypes::OBJECT;
            }
             if (!isset($propertyR->instanceOf)) {
              $propertyR->instanceOf = $this->typeFromRef($ref, $nativePrefix);
            }
            $propertyR->isGeneratedType = true;
        } else {

            if (($propertyR->type == FlexionsTypes::COLLECTION) || $propertyR->type == FlexionsTypes::ENUM ) {
                if (!isset($propertyR->instanceOf)){
                    $propertyR->instanceOf = $this->_swaggerTypeToFlexions($swaggerType, $swaggerFormat);
                }
            } else if (($propertyR->type == FlexionsTypes::OBJECT)&&(isset($propertyR->instanceOf))){
                $propertyR->type=$propertyR->instanceOf;
            }else{
                $propertyR->type = $this->_swaggerTypeToFlexions($swaggerType, $swaggerFormat);
            }
        }


        if (array_key_exists(SWAGGER_DESCRIPTION, $dictionary)) {
            $propertyR->description = $dictionary[SWAGGER_DESCRIPTION];
        }

        // EXPLICIT TYPE EXTENSION
        if (array_key_exists(EXTENDED_EXPLICIT_TYPE, $dictionary)) {
            $explicitType = $dictionary[EXTENDED_EXPLICIT_TYPE];
            $propertyR->instanceOf=$explicitType;
            if ($propertyR->type===FlexionsTypes::NOT_SUPPORTED){
                $propertyR->type=FlexionsTypes::OBJECT;
            }
            $propertyR->isGeneratedType=true;// Even if its false
        }
        
        // DISCREET SERIALIZATION SUPPORT
        if (array_key_exists(EXTENDED_SERIALIZABLE, $dictionary)) {
            $propertyR->isSerializable = $dictionary[EXTENDED_SERIALIZABLE];
        }

        // DISCREET OBSERVABLE SUPPORT
        if (array_key_exists(EXTENDED_SUPERVISABLE, $dictionary)) {
            $propertyR->isSupervisable = $dictionary[EXTENDED_SUPERVISABLE];
        }

        // DISCREET CRYPTABLE SUPPORT
        if (array_key_exists(EXTENDED_CRYPTABLE, $dictionary)) {
            $propertyR->isCryptable = $dictionary[EXTENDED_CRYPTABLE];
        }

        if (array_key_exists(SWAGGER_REQUIRED, $dictionary)) {
            $propertyR->required = $dictionary[SWAGGER_REQUIRED];
        }
        if (array_key_exists(SWAGGER_DEFAULT, $dictionary)) {
            $propertyR->default = $dictionary[SWAGGER_DEFAULT];
        }
    }


    private  function typeFromRef($ref,$nativePrefix){
        // @todo resolve refs really  ?
        $components = explode('/', $ref);
        $instanceOf = end($components);
        $type=$nativePrefix . ucfirst($instanceOf); // We add the prefix
        return $type;
    }


    /**
     * @param $type
     * @param $format
     * @return string
     */
    private function _swaggerTypeToFlexions($type, $format) {
        $type = strtolower($type);
        if ($type == 'string') {
            return FlexionsTypes::STRING;
        }
        if ($type == 'integer') {
            return FlexionsTypes::INTEGER;
        }
        if ($type == 'long') {
            return FlexionsTypes::INTEGER;
        }
        if ($type == 'float') {
            return FlexionsTypes::FLOAT;
        }
        if ($type == 'double') {
            return FlexionsTypes::DOUBLE;
        }
        if ($type == 'byte') {
            return FlexionsTypes::BYTE;
        }
        if ($type == 'boolean') {
            return FlexionsTypes::BOOLEAN;
        }
        if ($type == 'file') {
            return FlexionsTypes::FILE;
        }
        // Non standard Swagger
        if ($type == 'url') {
            return FlexionsTypes::URL;
        }

        if ($type == 'date' || $type == 'dateTime') {
            return FlexionsTypes::DATETIME;
        }
        // EXTENSION TO SWAGGER

        if ($type == 'dictionary') {
           return FlexionsTypes::DICTIONARY;
        }

        if ($type == 'data') {
            return FlexionsTypes::DATA;
        }

        return FlexionsTypes::NOT_SUPPORTED;
    }

    /**
     * @param String $path
     * @return string
     */
    protected function _classNameForPath($path) {
        $components = explode('/', $path);
        $className = '';
        foreach ($components as $component) {
            preg_match('#\{(.*?)\}#', $component, $match);

            if (is_null($match) || count($match) == 0) {
                $className .= ucfirst($component);
            } else {
                $cp = $match[1];
                $className .= 'With' . ucfirst($cp);
            }
        }
        return $className;
    }
}

?>
}#BMS#->{"filename":"Pluralization.php","checksum":1371876850,"relativePath":"BartlebyFlexions\/src\/modules\/Utils\/Pluralization.php","size":4276}<-#BME#
<?php

// Extracted from https://github.com/whiteoctober/RestBundle/blob/master/Pluralization/Pluralization.php

class Pluralization{


    static function pluralize($word){
        $plurals = array(
            '/(quiz)$/i' => '\1zes',
            '/^(ox)$/i' => '\1en',
            '/([m|l])ouse$/i' => '\1ice',
            '/(matr|vert|ind)ix|ex$/i' => '\1ices',
            '/(x|ch|ss|sh)$/i' => '\1es',
            '/([^aeiouy]|qu)ies$/i' => '\1y',
            '/([^aeiouy]|qu)y$/i' => '\1ies',
            '/(hive)$/i' => '\1s',
            '/(?:([^f])fe|([lr])f)$/i' => '\1\2ves',
            '/sis$/i' => 'ses',
            '/([ti])um$/i' => '\1a',
            '/(buffal|tomat)o$/i' => '\1oes',
            '/(bu)s$/i' => '\1ses',
            '/(alias|status)/i' => '\1es',
            '/(octop|vir)us$/i' => '\1i',
            '/(ax|test)is$/i' => '\1es',
            '/s$/i' => 's',
            '/$/' => 's'
        );
        $uncountables = array(
            'equipment', 'information', 'rice', 'money', 'species', 'series', 'fish', 'sheep'
        );
        $irregulars = array(
            'person' => 'people',
            'man' => 'men',
            'child' => 'children',
            'sex' => 'sexes',
            'move' => 'moves'
        );
        $lowerCasedWord = strtolower($word);
        foreach ($uncountables as $uncountable) {
            if (substr($lowerCasedWord, (-1 * strlen($uncountable))) == $uncountable) {
                return $word;
            }
        }
        foreach ($irregulars as $plural => $singular) {
            if (preg_match('/(' . $plural . ')$/i', $word, $arr)) {
                return preg_replace(
                    '/(' . $plural . ')$/i',
                    substr($arr[0], 0, 1) . substr($singular, 1),
                    $word
                );
            }
        }
        foreach ($plurals as $rule => $replacement) {
            if (preg_match($rule, $word)) {
                return preg_replace($rule, $replacement, $word);
            }
        }
        return 'NOT_PLURALIZED';
    }

    static function singularize($word){
        $singulars = array(
            '/(quiz)zes$/i' => '\1',
            '/(matr)ices$/i' => '\1ix',
            '/(vert|ind)ices$/i' => '\1ex',
            '/^(ox)en/i' => '\1',
            '/(alias|status)es$/i' => '\1',
            '/([octop|vir])i$/i' => '\1us',
            '/(cris|ax|test)es$/i' => '\1is',
            '/(shoe)s$/i' => '\1',
            '/(o)es$/i' => '\1',
            '/(bus)es$/i' => '\1',
            '/([m|l])ice$/i' => '\1ouse',
            '/(x|ch|ss|sh)es$/i' => '\1',
            '/(m)ovies$/i' => '\1ovie',
            '/(s)eries$/i' => '\1eries',
            '/([^aeiouy]|qu)ies$/i' => '\1y',
            '/([lr])ves$/i' => '\1f',
            '/(tive)s$/i' => '\1',
            '/(hive)s$/i' => '\1',
            '/([^f])ves$/i' => '\1fe',
            '/(^analy)ses$/i' => '\1sis',
            '/((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)ses$/i' => '\1\2sis',
            '/([ti])a$/i' => '\1um',
            '/(n)ews$/i' => '\1ews',
            '/s$/i' => '',
        );
        $uncountables = array(
            'equipment', 'information', 'rice', 'money', 'species', 'series', 'fish', 'sheep'
        );
        $irregulars = array(
            'person' => 'people',
            'man' => 'men',
            'child' => 'children',
            'sex' => 'sexes',
            'move' => 'moves'
        );
        $lowerCasedWord = strtolower($word);
        foreach ($uncountables as $uncountable) {
            if (substr($lowerCasedWord, (-1 * strlen($uncountable))) == $uncountable) {
                return $word;
            }
        }
        foreach ($irregulars as $plural => $singular) {
            if (preg_match('/(' . $singular . ')$/i', $word, $arr)) {
                return preg_replace(
                    '/(' . $singular . ')$/i',
                    substr($arr[0], 0, 1) . substr($plural, 1),
                    $word
                );
            }
        }
        foreach ($singulars as $rule => $replacement) {
            if (preg_match($rule, $word)) {
                return preg_replace($rule, $replacement, $word);
            }
        }
        return 'NOT_SINGULARIZED';
    }
}#BMS#->{"filename":"NotesXcdata.txt","checksum":3249140636,"relativePath":"BartlebyFlexions\/src\/modules\/XcDataModelXMLImporter\/NotesXcdata.txt","size":1868}<-#BME#
Modeling tool constraint :
--------------------------------

"1-N relationship" will generate intermediary collection entity.
"1-1 relationship" will reference to an entity

You can reference an external relationship directly by using #2

NOT SUPPORTED :  automation of relationship reciprocity 
You need to manage manually reciprocity (future extension may generate setters to deal with reciprocity)


Modeling tool extensions
--------------------------------------


// Entities

#4 If an entity has in its userInfos  a key == "generate" and a value =="collection"
It will generate an independent collection class for this object.
(Normally collection are generated using to 1-n relationships);

#5 If an entity has in its userInfos  a key == "parent" and a value =="MyParent"
1- the entity prefix will not apply !!
2- this directive overrides the "parentEntity"

// Attributes or Properties 

#1 If a property has in its userInfos dictionary a key=="type" : 
"type:array" this directive will cast to the native type NSArray
"type:rect" this directive will cast to the native type CGrect 
Any of the ObjectiveCHelper->getSupportedNativeTypes() types should work.

#2 You can generate a relationship attribute adding to the property key == "relationship" value="ClassName"
This is used in WTMShelf to reference Watt classes (users=WattCollectionOfUser,...)

#3  If a property has in its userInfos dictionary a key=="extractible" : 
"extractible:NO" when the subgraph is copyied (extracted) the related entity is not copyed (it is null) 

// Attributes for relationship 
#6 "extractible:no" when the subgraph is copyied (extracted) the related entity is not copyed (it is null) 

NOTE  : 
For entities, properties (and relationship that are converted to properties)
We store any metadata (key values stored in userInfo) in an associative array for specific extension.
#BMS#->{"filename":"XcdataModelDelegate.Interface.php","checksum":3118474071,"relativePath":"BartlebyFlexions\/src\/modules\/XcDataModelXMLImporter\/XcdataModelDelegate.Interface.php","size":201}<-#BME#
<?php

interface XcdataModelDelegateInterface{
    /**
     * @param $prefix
     * @param $baseClassName
     * @return string
     */
    function getCollectionClassName($prefix,$baseClassName);
}
?>#BMS#->{"filename":"XcdataModelDelegate.php","checksum":2601788009,"relativePath":"BartlebyFlexions\/src\/modules\/XcDataModelXMLImporter\/XcdataModelDelegate.php","size":533}<-#BME#
<?php

require_once 'XcdataModelDelegate.Interface.php';

// If necessary we define COLLECTION_OF
if (!defined('COLLECTION_OF')){
    define ( "COLLECTION_OF","CollectionOf");
}

/**
 * Class XcdataModelDelegate
 * Default implementation
 */
class XcdataModelDelegate implements XcdataModelDelegateInterface{

    /**
     * @param $prefix
     * @param $baseClassName
     * @return string
     */
    function getCollectionClassName($prefix,$baseClassName){
        return ucfirst($prefix).COLLECTION_OF.$baseClassName;
    }
}

?>#BMS#->{"filename":"XcdatamodelXMLToFlexionsRepresentation.php","checksum":2870685613,"relativePath":"BartlebyFlexions\/src\/modules\/XcDataModelXMLImporter\/XcdatamodelXMLToFlexionsRepresentation.php","size":11931}<-#BME#
<?php

/*
Created by Benoit Pereira da Silva on 20/04/2013.
Copyright (c) 2013  http://www.chaosmos.fr

This file is part of Flexions

Flexions is free software: you can redistribute it and/or modify
it under the terms of the GNU LESSER GENERAL PUBLIC LICENSE as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Flexions is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU LESSER GENERAL PUBLIC LICENSE for more details.

You should have received a copy of the GNU LESSER GENERAL PUBLIC LICENSE
along with Flexions  If not, see <http://www.gnu.org/Licenses/>
*/


require_once FLEXIONS_ROOT_DIR . 'flexions/representations/flexions/FlexionsRepresentationsIncludes.php';

require_once 'XcdataModelDelegate.Interface.php';


/**
 * Class XCDDataXMLToFlexionsRepresentation
 */
class XCDDataXMLToFlexionsRepresentation {

	function projectRepresentationFromXcodeModel($descriptorFilePath, $nativePrefix = "", XcdataModelDelegateInterface $delegate) {

		if(!isset($delegate)){
			fLog ( "XCDDataXMLToFlexionsRepresentation.projectRepresentationFromXcodeModel() module requires a XcdataModelDelegate" , true );
			return;
		}

		fLog ( "Invoking XCDDataXMLToFlexionsRepresentation.projectRepresentationFromXcodeModel()" . cr () . cr (), true );
		
		$r = new ProjectRepresentation ();
		$r->classPrefix = $nativePrefix;
		$r->entities = array ();
		
		$dom = new DomDocument ();
		$pth = realpath ( $descriptorFilePath );
		$dom->load ( $pth );
		$entities = $dom->getElementsByTagName ( 'entity' );
		
		// /////////////////////////
		// ENTITIES
		// /////////////////////////
		
		fLog ( 	 "********************".cr(),true );
		fLog ( 	 "Parsing Entities".cr(),true );
		fLog ( 	 "********************".cr().cr(),true );
		
		foreach ( $entities as $entity ) {
			
			/* @var DOMNode $entity */
			$entityR = new EntityRepresentation ();
			$entityR->metadata=array();
			
			// ////////////////////////////////////////////////////////////////
			//
			// -> ENTITY
			// Stored in <model ><entity>...
			//
			// sample :
			// <entity name="Activity" representedClassName="Activity" syncable="YES">
			// ...
			//
			// ////////////////////////////////////////////////////////////////
			
			// We parse the attribute of the <entity> element
			
			if ($entity->hasAttribute ( "representedClassName" )) {
				$entityR->name = $entity->getAttribute ( "representedClassName" );
				fLog ( cr ().'Parsing : ' . $entityR->name . cr (), true );
				fLog ( '------------------------'. cr (), true );
			}
			if ($entity->hasAttribute ( "name" ) && strlen ( $entityR->name ) <= 1) {
				$entityR->name = $entity->getAttribute ( "name" );
			}
			if (strlen ( $entityR->name ) <= 1) {
				throw new Exception ( 'entity with no representedClassName and no name' );
			}
			
			$entityR->type = "object"; // Entities are objects
			if ($entity->hasAttribute ( "parentEntity" )) {
				$entityR->instanceOf = $nativePrefix . $entity->getAttribute ( "parentEntity" );
			} else {
				// We donnot qualifiy the instance
				// a requalification can be done according to the situation in
				// the template
			}
			
			// ////////////////////////////////////////////////////////////////
			//
			// -> ENTITY->metadata
			// Stored in <userInfo><entry> elements
			//
			// Sample :
			// <entity name="Activity" representedClassName="Activity" syncable="YES">
			// ...
			// <userInfo>
			// <entry key="parent" value="WattModel"/>
			// </userInfo>
			// </entity>
			//
			// ////////////////////////////////////////////////////////////////
			
			$entityUserInfos = $entity->getElementsByTagName ( "userInfo" );
			foreach ( $entityUserInfos as $entityUserInfo ) {
				$userInfoEntries = $entityUserInfo->getElementsByTagName ( "entry" );
				foreach ( $userInfoEntries as $userInfoEntry ) {
					fLog ( 	 $entityR->name .'.metadata : '.$this->elementToString($userInfoEntry).cr(),true );
					
					if ($userInfoEntry->hasAttribute ( "key" ) && $userInfoEntry->hasAttribute ( "value" )){
						$entityR->metadata[ rtrim ( $userInfoEntry->getAttribute ( "key" ))]=rtrim( $userInfoEntry->getAttribute ( "value" ));
					}
					
					if ($userInfoEntry->hasAttribute ( "key" ) && rtrim ( $userInfoEntry->getAttribute ( "key" ) ) == "generate" && ($userInfoEntry->hasAttribute ( "value" ) && strtolower ( rtrim ( $userInfoEntry->getAttribute ( "value" ) ) ) == "collection")) {
						$entityR->generateCollectionClass = true;
					}
					if ($userInfoEntry->hasAttribute ( "key" ) && rtrim ( $userInfoEntry->getAttribute ( "key" ) ) == "parent" && $userInfoEntry->hasAttribute ( "value" )) {
						$entityR->instanceOf = $userInfoEntry->getAttribute ( "value" );
					}
				}
			}
			
			// ////////////////////////////////////////////////////////////////
			//
			// -> ENTITY->properties
			// Stored in <attribute> elements
			//
			// Sample :
			//
			// <entity name="Activity" representedClassName="Activity" syncable="YES">
			// <attribute name="level" optional="YES" attributeType="Integer 16"
			// defaultValueString="0" syncable="YES"/>
			// <attribute name="rating" optional="YES" attributeType="Integer 16"
			// defaultValueString="0" syncable="YES"/>
			// ...
			//
			// ////////////////////////////////////////////////////////////////
			
			$attributes = $entity->getElementsByTagName ( 'attribute' );
			foreach ( $attributes as $attribute ) {
				
				// For each attribute : here attribute == property
				$property = new PropertyRepresentation ();
				
				// We parse the attribute of the <attribute> element
				if ($attribute->hasAttribute ( "name" )) {
					$property->name = $attribute->getAttribute ( "name" );
				} else {
					throw new Exception ( 'property with no name' );
				}
				
				fLog ( $entityR->name.'.'.$property->name.' '.cr(),true );
				
				if ($attribute->hasAttribute ( "attributeType" )) {
					$property->type = $attribute->getAttribute ( "attributeType" );
				} else {
					$property->type = ObjectiveCHelper::UNDEFINED_TYPE;
				}
				
				if ($attribute->hasAttribute ( "defaultValueString" )) {
					$property->default = $attribute->getAttribute ( "defaultValueString" );
				}
				
				// We parse the property metadata

				$propertyUserInfos = $attribute->getElementsByTagName ( "userInfo" );
				foreach ( $propertyUserInfos as $propertyUserInfo ) {
					$userInfos = $propertyUserInfo->getElementsByTagName ( "entry" );
					// We parse the entries
					
					$property->metadata=array();
					
					foreach ( $userInfos as $propertyInfoEntry ) {
			
						fLog ( 	 $entityR->name.'.'.$property->name .'.metadata : '.$this->elementToString($propertyInfoEntry).cr(),true );
						
						if ($propertyInfoEntry->hasAttribute ( "key" ) && $propertyInfoEntry->hasAttribute ( "value" )){
							$property->metadata[ rtrim ( $propertyInfoEntry->getAttribute ( "key" ))]=rtrim( $propertyInfoEntry->getAttribute ( "value" ));
						}
						
						if ($propertyInfoEntry->hasAttribute ( "key" ) && rtrim ( $propertyInfoEntry->getAttribute ( "key" ) ) == "type" && rtrim ( $propertyInfoEntry->hasAttribute ( "value" ) )) {
							$propertyType = $propertyInfoEntry->getAttribute ( "value" );
							$property->type = $propertyType;
						}
						if ($propertyInfoEntry->hasAttribute ( "key" ) && rtrim ( $propertyInfoEntry->getAttribute ( "key" ) ) == "relationship" && rtrim ( $propertyInfoEntry->hasAttribute ( "value" ) )) {
							/* Support of external relationship */
							$propertyType = $propertyInfoEntry->getAttribute ( "value" );
							$property->type = "object";
							$property->instanceOf = $propertyType;
							$property->isGeneratedType = true;
							$property->isExternal = true; // Used to prevent from generation
						}
						if ($propertyInfoEntry->hasAttribute ( "key" ) && rtrim ( $propertyInfoEntry->getAttribute ( "key" ) ) == "extractible" && rtrim ( $propertyInfoEntry->hasAttribute ( "value" ) )) {
							/* Support of extractibility */
							$property->isExtractible = (strtolower ( $propertyInfoEntry->getAttribute ( "value" ) ) != "no");
							var_dump ( $property->extractible );
						}
					}
				}
				$entityR->properties [$property->name] = $property;
				
				
			}
			
			
			// ////////////////////////////////////////////////////////////////
			//
			// -> ENTITY->relationships
			// Stored in <relationship> elements
			//
			// Sample :
			//
			// <entity name="Cell" syncable="YES">
			// ...
			// <relationship name="column" optional="YES" minCount="1" maxCount="1"
			// deletionRule="Nullify" destinationEntity="Column" inverseName="cells"
			// inverseEntity="Column" syncable="YES"/>
			// <relationship name="element" optional="YES" minCount="1" maxCount="1"
			// deletionRule="Nullify" destinationEntity="Element" inverseName="cells"
			// inverseEntity="Element" syncable="YES"/>
			//
			// ////////////////////////////////////////////////////////////////
			
			$relationships = $entity->getElementsByTagName ( 'relationship' );
			foreach ( $relationships as $relationship ) {
				
				// We create a property to hold the relationship
				$property = new PropertyRepresentation ();
				$property->metadata=array();
				
				if ($relationship->hasAttribute ( "name" )) {
					$property->name = $relationship->getAttribute ( "name" );
				} else {
					throw new Exception ( 'property with no name' );
				}
				fLog ( $entityR->name.'.'.$property->name.' '.cr(),true );
				$tooMany = false;
				if ($relationship->hasAttribute ( "toMany" )) {
					$tooMany = ($relationship->getAttribute ( "toMany" ) == "YES");
				}
				if ($relationship->hasAttribute ( "destinationEntity" )) {
					$destinationEntity = $relationship->getAttribute ( "destinationEntity" );
					if ($tooMany == true) {
						$property->type = "object";
						$property->instanceOf = $delegate->getCollectionClassName( $nativePrefix, $destinationEntity );
						$property->isGeneratedType = true;
					} else {
						$property->type = "object";
						$property->instanceOf = $nativePrefix . ucfirst ( $destinationEntity );
						$property->isGeneratedType = true;
					}
				} else {
					$property->type = ObjectiveCHelper::UNDEFINED_TYPE;
				}
				
				// Relationship metadata user infos
				
				$relationshipUserInfos = $relationship->getElementsByTagName ( 'userInfo' );
				foreach ( $relationshipUserInfos as $relationshipUserInfo ) {
					$userInfoEntries = $relationshipUserInfo->getElementsByTagName ( "entry" );
					foreach ( $userInfoEntries as $propertyInfoEntry ) {
						
						fLog ( 	 $entityR->name.'.'.$property->name .'.metadata : '.$this->elementToString($propertyInfoEntry).cr(),true );
						
						if ($propertyInfoEntry->hasAttribute ( "key" ) && $propertyInfoEntry->hasAttribute ( "value" )){
							$property->metadata[ rtrim ( $propertyInfoEntry->getAttribute ( "key" ))]=rtrim( $propertyInfoEntry->getAttribute ( "value" ));
						}
						
						if ($propertyInfoEntry->hasAttribute ( "key" ) && rtrim ( $propertyInfoEntry->getAttribute ( "key" ) ) == "extractible" && rtrim ( $propertyInfoEntry->hasAttribute ( "value" ) )) {
							/* Support of extractibility */
							$property->isExtractible = (strtolower ( $propertyInfoEntry->getAttribute ( "value" ) ) != "no");
						}
					}
				}
				
				// Add the property to the entity
				$entityR->properties [$property->name] = $property;
			}
			
			// We add the entity representations to the entities.
			$r->entities [$entityR->name] = $entityR;
		}
		
		fLog ( "" . cr (), true );
		
		fLog ( 	 "********************".cr(),true );
		fLog ( 	 "End of  Entities".cr(),true );
		fLog ( 	 "********************".cr().cr(),true );
		
		
		return $r;
	}
	
	public function elementToString($domElement){
		return $domElement->ownerDocument->saveXML($domElement);
	}
}

?>#BMS#->{"filename":"BartlebySyncConfiguration.php","checksum":3802132973,"relativePath":"BartlebySync\/BartlebySyncConfiguration.php","size":2146}<-#BME#
<?php

if (!defined('BARTLEBY_SYNC_ROOT_PATH')) {

    define('BARTLEBY_SYNC_ROOT_PATH', dirname(__FILE__).'/');

    ///////////////////////
    // KEYS
    ///////////////////////

    
    define('BARTLEBY_SYNC_SECRET_KEY', 'AP_BS_SSK'); // Used create the data system folder

    ///////////////////////
    // REPOSITORY
    ///////////////////////


    // At this point $configuration is set
    $stage=$configuration->STAGE();

    if ($stage==Stages::DEVELOPMENT){
        define('BARTLEBY_SYNC_SECRET_KEY', 'AP_BS_SSK_LOCAL'); // Used create the data system folder
        define('REPOSITORY_BASE_URL','AP_BS_RH_DEVELOPMENT');
        define('REPOSITORY_WRITING_PATH', dirname(__DIR__) .DIRECTORY_SEPARATOR.'files'.DIRECTORY_SEPARATOR);
    }elseif($stage==Stages::PRODUCTION){
        define('BARTLEBY_SYNC_SECRET_KEY', 'AP_BS_SSK_PRODUCTION'); // Used create the data system folder
        define('REPOSITORY_BASE_URL','AP_BS_RH_PRODUCTION');
        define('REPOSITORY_WRITING_PATH', dirname(__DIR__) .DIRECTORY_SEPARATOR.'files'.DIRECTORY_SEPARATOR);
    }elseif($stage==Stages::ALTERNATIVE){
        define('BARTLEBY_SYNC_SECRET_KEY', 'AP_BS_SSK_ALTERNATIVE'); // Used create the data system folder
        define('REPOSITORY_BASE_URL','AP_BS_RH_ALTERNATIVE');
        define('REPOSITORY_WRITING_PATH', dirname(__DIR__) .DIRECTORY_SEPARATOR.'files'.DIRECTORY_SEPARATOR);
    }else{
        // It is local Stages::LOCAL
        define('BARTLEBY_SYNC_SECRET_KEY', 'AP_BS_SSK_LOCAL'); // Used create the data system folder
        define('REPOSITORY_BASE_URL','AP_BS_RH_LOCAL');
        define('REPOSITORY_WRITING_PATH', dirname(__DIR__) .DIRECTORY_SEPARATOR.'files'.DIRECTORY_SEPARATOR);
    }


    ///////////////////////
    // PERSITENCY
    ///////////////////////

    $a=BARTLEBY_SYNC_ROOT_PATH . 'Core/IOManagerFS.php';
    require_once BARTLEBY_SYNC_ROOT_PATH . 'Core/IOManagerFS.php';  // Default adapter
    define('PERSISTENCY_CLASSNAME', 'BartlebySync\Core\IOManagerFS');

    //////////////////////
    // MISC
    //////////////////////

    define('MIN_TREE_ID_LENGTH', 1);

    define('CLEAN_UP_ON_ERROR',false);


}#BMS#->{"filename":"BartlebySyncConst.php","checksum":1803188375,"relativePath":"BartlebySync\/Core\/BartlebySyncConst.php","size":939}<-#BME#
<?php


if (!defined('BARTLEBY_SYNC_VERSION')) {

    define('BARTLEBY_SYNC_VERSION', '1.0.beta1');


// Responses key consts

    define('INFORMATIONS_KEY', 'informations');
    define('METHOD_KEY', 'method');

    define('HASHMAP_FILENAME', 'hashmap');
    define('TREE_INFOS_FILENAME', 'treeInfos');
    define('SYSTEM_DATA_PREFIX', '.');
    define('METADATA_FOLDER', '.bsync');


    define('DEBUG_MODE_WITH_REAL_TREE_ID', true);

///////////////////////////////
// BartlebySyncCommands
///////////////////////////////

    define('BCreate', 0);        // W source - un prefix the asset
    define('BUpdate', 1);        // W source - un prefix the asset
    define('BMove', 2);          // R source W destination
    define('BCopy', 3);          // R source W destination
    define('BDelete', 4);        // W source

// BartlebySyncCMDParamsRank

    define('BCommand', 0);
    define('BDestination', 1);
    define('BSource', 2);

}#BMS#->{"filename":"CommandInterpreter.php","checksum":142928795,"relativePath":"BartlebySync\/Core\/CommandInterpreter.php","size":8561}<-#BME#
<?php

namespace BartlebySync\Core;

require_once 'BartlebySyncConst.php';

class CommandInterpreter {
	
	/**
	 * The $ioManager
	 *
	 * @var IOManager
	 */
	protected $ioManager = NULL;
	
	/**
	 * References the current list of files to be used for finalization.
	 *
	 * @var array
	 */
	private $listOfFiles = array ();
	
	/**
	 *
	 * @param IOManager $ioManager        	
	 */
	public function setIOManager($ioManager) {
		$this->ioManager = $ioManager;
	}
	
	/**
	 * Interprets the command bunch
     * We try be resilient to potential client side errors (doubles, sequences, orders, ...)
	 * That's why we proceed use a double pass approach and so on...
     *
	 * @param string $treeId        	
	 * @param string $syncIdentifier        	
	 * @param array $bunchOfCommand        	
	 * @param string $finalHashMap
	 * @return null on success and a string with the error in case of any error
	 */
	function interpretBunchOfCommand($treeId, $syncIdentifier, array $bunchOfCommand, $finalHashMap) {

		$failures = array ();
		$hasProceededToUnPrefixing = FALSE;

		// Order matters.
		// Sort the command to execute delete commands at the end (after create, copy and move)
		usort ( $bunchOfCommand, array (
				$this,
				'_compareCommand' 
		) );

        //////////////////////////////////
        // Let's remove possible double
        //////////////////////////////////

        $filteredBunchOfCommand=array();
        foreach ($bunchOfCommand as $command){
            $alreadyExists=false;
            foreach($filteredBunchOfCommand as $filteredCommand){
                if(count ($filteredCommand)===count($command)){
                    $nbOfArguments=count($filteredCommand);
                    $match=true;
                    for($i=0;$i<$nbOfArguments;$i++){
                        $match=(($filteredBunchOfCommand[$i]==$command[$i])&& $match);
                    }
                    if($match==true){
                        $alreadyExists=true;
                    }
                }
            }
            if($alreadyExists===false){
                $filteredBunchOfCommand[]=$command;
            }
        }

        $secondAttempt=array();

        //////////////////
        // First pass
        //////////////////

		foreach ( $filteredBunchOfCommand as $command ) {
			if (is_array ( $command )) {
				if ($hasProceededToUnPrefixing === FALSE && $command [BCommand] > BUpdate) {
					// Un prefix after running all  commands.
					$unPrefixingFailures = $this->_unPrefix ( $treeId, $syncIdentifier );
					if (count ( $unPrefixingFailures ) > 0) {
						return $unPrefixingFailures;
					}
					$hasProceededToUnPrefixing = TRUE;
				}
				$result = $this->_decodeAndRunCommand ( $command, $treeId );
				if ($result != NULL) {
                    // We store for a next pass
                    $secondAttempt[]=$command;
				}
			} else {
				$failures [] = $command . ' is not an array';
			}
			if (isset ( $result )) {
				$failures [] = $result;
			}
			$result = NULL;
		}

        //////////////////
        // Second pass
        //////////////////

        // If we encounter a problem of dependency
        // (order of operation e.g a move before a dependant copy)
        foreach ( $secondAttempt as $command ) {
            if (is_array ( $command )) {
                $result = $this->_decodeAndRunCommand( $command, $treeId);
                if ($result != NULL) {
                    $failures [] = $result;
                }
            }
            $result = NULL;
        }

        //////////////////
        // Second pass
        //////////////////

		if (count ( $failures ) > 0) {

            return $failures;

		} else {

            // Remove the prefix from the synchronized files
			if($hasProceededToUnPrefixing==FALSE){
                // Un prefix the files.
				$unPrefixingFailures = $this->_unPrefix ( $treeId, $syncIdentifier );
				if (count ( $unPrefixingFailures ) > 0) {
					return $unPrefixingFailures;
				}
			}

            // Save the hashMap.

			$this->ioManager->mkdir ( $this->ioManager->absoluteUrl ( $treeId, METADATA_FOLDER.'/' ) );
			if ($this->ioManager->saveHashMap ( $treeId, $finalHashMap )) {
				return NULL;
			} else {
				$failures [] = 'Error when saving the hashmap';
				return $failures;
			}
		}
	}



	private function _compareCommand($a, $b) {

/*
        'BCreate' -> 0
        'BUpdate' -> 1
        'BMove' -> 2
        'BCopy' -> 3
        'BDelete' -> 4


        $aOrder=$a[BCommand];
        $bOrder=$b[BCommand];

*/
		return ($a [BCommand] > $b [BCommand]);
	}

    /**
     * Finalizes the bunch of command
     *
     * @param $treeId
     * @param string $syncIdentifier
     * @internal param string $finalHashMapFilePath
     * @return array
     */
	private function _unPrefix($treeId, $syncIdentifier) {
		$failures = array ();
		foreach ( $this->listOfFiles as $file ) {
			if (substr ( $file, - 1 ) != "/") {
				$relativePath = dirname ( $file ) . DIRECTORY_SEPARATOR . $syncIdentifier . basename ( $file );
				$protectedPath = $this->ioManager->absoluteUrl ( $treeId, $relativePath );
				if ($this->ioManager->exists ( $protectedPath )) {
					$this->ioManager->rename ( $protectedPath, $this->ioManager->absoluteUrl ( $treeId, $file ) );
				} else {
					$failures [] = 'Unexisting path : ' . $protectedPath . ' -> ' . $treeId . ' (' . $relativePath . ') ';
				}
			} else {
				// It is a folder with do not prefix currently the folders
			}
		}
        return $failures;
	}
	
	/**
	 * Decodes and runs the command
	 *
	 * @param array $cmd        	
	 * @param string $treeId        	
	 * @return string on error, or null on success
	 */
	private function _decodeAndRunCommand( array $cmd, $treeId) {

		if (count ( $cmd )> 1 ) {
			$command = $cmd [0];
			// Absolute paths
			$destination = $this->ioManager->absoluteUrl ( $treeId, $cmd [BDestination] );
			$source = $this->ioManager->absoluteUrl ( $treeId, $cmd [BSource] );
            $sourceExistsString=($this->ioManager->exists($source))?"Yes":"No";
            $destinationExistsString=($this->ioManager->exists($destination))?"Yes":"No";

			switch ($command) {
				case BCreate :
					if (! isset ( $cmd [BDestination] )) {
						return 'BDestination must be non null :' . $cmd;
					}
					// There is no real FS action to perform
					// The file should only be "unPrefixed"
					// We only add the file to listOfFiles to be unPrefixed
					$this->listOfFiles [] = $cmd [BDestination];
					return NULL;
					break;
					case BUpdate :
						if (! isset ( $cmd [BDestination] )) {
							return 'BDestination must be non null :' . $cmd;
						}
						// There is no real FS action to perform
						// The file should only be "unPrefixed"
						// We only add the file to listOfFiles to be unPrefixed
						$this->listOfFiles [] = $cmd [BDestination];
						return NULL;
						break;
				case BCopy :
					if ($this->ioManager->copy ( $source, $destination )) {
						return NULL;
					} else {
                        if(($this->ioManager->exists($destination)==true)
                            && ($this->ioManager->exists($source)==false)){
                            return NULL; // We keep the current destination file (May be inferred by a bad client sequence)
                        }
						return 'BCopy error source:' . $source .'(exists ='.$sourceExistsString.') destination: ' . $destination.' (exists ='.$destinationExistsString.')';
                    }
					break;
				case BMove :
					if ($this->ioManager->rename ( $source, $destination )) {
						return NULL;
					} else {
                        if(($this->ioManager->exists($destination)==true)
                            && ($this->ioManager->exists($source)==false)){
                            return NULL; // We keep the current destination file (May be inferred by a bad client sequence)
                        }
						return 'BMove error source:' . $source .'(exists ='.$sourceExistsString.') destination: ' . $destination.' (exists ='.$destinationExistsString.')';
					}
					break;
				case BDelete :
					if ($this->ioManager->delete ( $destination )) {
						return NULL;
					} else {
                        if($this->ioManager->exists($destination)==false){
                            return NULL;// There was no need to delete an unexisting path
                        }
						return 'BDelete error on ' . $destination.'(exists ='.$destinationExistsString.')';
					}
				default :
					break;
			}
		}
		return 'CMD ' . json_encode ( $cmd ) . ' is not valid';
	}
}
?>#BMS#->{"filename":"IOManager.php","checksum":3641489123,"relativePath":"BartlebySync\/Core\/IOManager.php","size":9799}<-#BME#
<?php

namespace BartlebySync\Core;

require_once BARTLEBY_ROOT_FOLDER.'Core/Configuration.php';
require_once BARTLEBY_ROOT_FOLDER.'Core/Context.php';

require_once 'BartlebySyncConst.php';

use Bartleby\Configuration;
use Bartleby\Core\Context;

/**
 *  Standard IO Functions
 *  Implement those method to create
 *  a new persistency layer
 * @author bpds
 */
interface IOManagerPersistency {

	/**
	 * @return Context
	 */
	public function getContext();

	/**
	 * IOManager constructor should provide a context object.
	 * @param \Bartleby\Core\Context $context
	 */
	public function __construct(Context $context);


	public function exists($filename) ;

	public function put_contents($filename, $data);

	public function get_contents($filename);

	public function mkdir($dir);

	public function rename($oldname, $newname);

    /**
     * @param $source
     * @param $destination
     * @return mixed
     */
    public function copy( $source, $destination );

	public function delete($filename);

	public function move_uploaded($filename, $destination);

	public function listRelativePathsIn ($rootPath,$prefix='');

}

interface  IOManager extends IOManagerPersistency{


	/***
	 * Returns the status
	 * @return int
	 */
	public function getStatus();

	/**
	 * Returns the absolute path of a given resource
	 * @param string $treeId
	 * @param string $relativePath
	 * @return string|NULL
	 */
	public function absoluteUrl($treeId, $relativePath);

	/**
	 *  Returns the current public uri for a given resource
	 * @param string $treeId
	 * @param string $relativePath
	 * @return string|NULL
	 */
	public function uriFor($treeId, $relativePath);


	/**
	 * The tree id is persistent not the currentPublicId
	 * That  may change during the life cycle
	 *  For example in case of ACL invalidation for a group member
	 *   It is the public exposed tree root folder
	 * @param string $treeId
	 * @return array|NULL
	 */
	public function createTree( $treeId);



	/**
	 * Deletes the tree
	 * @param string $treeId
	 * @return array|NULL
	 */
	public function deleteTree( $treeId);



	/**
	 * Changes the public identifier.
	 *
	 * @param String $treeId
	 */
	public function touchTree($treeId);


	/**
	 *  Saves the Hash map
	 * @param string $treeId
	 * @param string $hashMap
	 * @return boolean
	 */
	public function saveHashMap($treeId, $hashMap);


	/**
	 *  Creates the repository
	 *  And could perform any installation related task
	 */
	public function install($path);


    /**
     * A function that scans the repository and removes the Ghosts and inconsistent contexts
     * @return array
     */
    public function removeGhosts();

}


/**
 *  IOmanager abstract class
 * @author bpds
 *
 */
abstract class IOManagerAbstract  {

	/**
	 *  Used to define a status code
	 * @var integer
	 */
	public $status=0;


	/**
	 *  The current tree data
	 * @var array
	 */
	protected   $treeData=NULL;


	public function getStatus(){
		return $this->status;
	}

	public function repositoryAbsolutePath() {
		return REPOSITORY_WRITING_PATH;
	}


	public function absoluteUrl($treeId, $relativePath) {
		$currentId=$this->_currentPublicId($treeId);
		if($currentId!=NULL){
			return $this->repositoryAbsolutePath () . $this->_currentPublicId($currentId). DIRECTORY_SEPARATOR . $relativePath;
		}
		return NULL;
	}


	public function uriFor($treeId, $relativePath) {
		$currentId = $this->_currentPublicId ( $treeId );
		$absoluteUrl = $this->absoluteUrl ( $treeId, $relativePath );
		if ($currentId != NULL) {
			if ($this->exists ( $absoluteUrl )) {
				$uri = REPOSITORY_BASE_URL . $currentId . DIRECTORY_SEPARATOR . $relativePath;
				$uri= str_replace(" ","%20",$uri );
					// @todo 401 if not authorized;
					// $this->status=401
					return $uri;
			}
		}
		$this->status = 404;
		return NULL;
	}

	public function createTree( $treeId){
		$currentPublicId = $this->_createAPublicId($treeId);
		$systemDataFolder = $this->_treeInfosFolderPathFor($treeId);
		$messages=array();
		// Create the system data folder
		if($this->exists($systemDataFolder)){
			return NULL;
		}
		 if (!$this->mkdir ($systemDataFolder)){
			$messages[]= $systemDataFolder.' mkdir error (System data folder)';
			return $messages;
		}

		// Put the current public id, owner, and an array of groups
		$this->treeData=array( $currentPublicId, Configuration::ANONYMOUS,  array(Configuration::ANONYMOUS), 777);

		if($this->put_contents($systemDataFolder.TREE_INFOS_FILENAME, json_encode($this->treeData))==false){
			$messages[]=$treeId.'createTree tree infos file_put_contents error '.$systemDataFolder.TREE_INFOS_FILENAME;
		}
		// Create the public id folder
		$currentPublicIdFolder=$this->repositoryAbsolutePath ().$currentPublicId. DIRECTORY_SEPARATOR ;
		if(!$this->mkdir($currentPublicIdFolder)){
			$messages[]= $currentPublicIdFolder.' mkdir error (public folder)';
		}
		// Create the meatdata folder in the public id folder
		if(!$this->mkdir($currentPublicIdFolder.METADATA_FOLDER.DIRECTORY_SEPARATOR)){
			$messages[]= $currentPublicIdFolder.METADATA_FOLDER.DIRECTORY_SEPARATOR.'   mkdir error  (Metadata folder)';
		}
		if(count($messages)>0){
			return $messages;
		}
		return NULL;
	}


	/**
	 * Deletes the tree
	 * @param string $treeId
	 * @return array|NULL
	 */
	public function deleteTree( $treeId){
		$messages = array ();
		$currentPublicId = $this->_currentPublicId ( $treeId );
		if ($currentPublicId == NULL) {
			$messages [] = 'tree does not exists';
		} else {
			$currentPublicIdFolder = $this->repositoryAbsolutePath () . $currentPublicId . DIRECTORY_SEPARATOR;
			$treeInfoFolder=$this->_treeInfosFolderPathFor ( $treeId );
			if ($this->exists ( $currentPublicIdFolder ) && $this->exists($treeInfoFolder)) {
				if ($this->delete($currentPublicIdFolder)==false || $this->delete($treeInfoFolder)==false) {
					$messages [] =  'Public or tree folder deletion has failed.'.$currentPublicIdFolder.' '.$treeInfoFolder;
				}
			} else {
				$messages [] =  'Public or tree folder data does not exist. '.$currentPublicIdFolder.' '.$treeInfoFolder;
			}
		}
		if (count ( $messages ) > 0) {
			return $messages;
		}
		return NULL;
	}




	public function touchTree($treeId) {
		$messages = array ();
		$currentPublicId = $this->_currentPublicId ( $treeId ); // populates $this->treeData
		if ($currentPublicId == NULL) {
			$messages [] = 'tree does not exists';
		} else {
			$currentPublicIdFolder = $this->repositoryAbsolutePath () . $currentPublicId . DIRECTORY_SEPARATOR;
			if ($this->exists ( $currentPublicIdFolder )) {
				// @TODO to be refactored We do not rename on touch.
				/*
				$oldPublicId = $this->treeData [0];
				$newPublicId = $this->_createAPublicId ($treeId);
				$newPublicIdFolder = $this->repositoryAbsolutePath () . $newPublicId . DIRECTORY_SEPARATOR;
				$this->treeData [0] = $newPublicId;
				if ($this->put_contents ( $this->_treeInfosFolderPathFor ( $treeId ) . TREE_INFOS_FILENAME, json_encode ( $this->treeData ) ) == false) {
					$messages [] = $treeId . ' tree infos file_put_contents error ' . $this->_treeInfosFolderPathFor ( $treeId ) . TREE_INFOS_FILENAME;
				} else {

					if ($this->rename ( $currentPublicIdFolder, $newPublicIdFolder ) == false) {
						$messages [] = $treeId . ' moving folder error ';
						// we need to try to reset the tree infos (fault resilience)
						$this->treeData [0] = $oldPublicId;
						$this->put_contents ( $this->_treeInfosFolderPathFor ( $treeId ) . TREE_INFOS_FILENAME, json_encode ( $this->treeData ) );
					}
				}
				*/
			} else {
				$messages [] = $currentPublicIdFolder . ' does not exist';
			}
		}
		if (count ( $messages ) > 0) {
			return $messages;
		}
		return NULL;
	}


	public function saveHashMap($treeId, $finalHashMap) {
		$destination = $this->absoluteUrl ( $treeId, METADATA_FOLDER .DIRECTORY_SEPARATOR. HASHMAP_FILENAME );
		return $this->put_contents($destination,$finalHashMap);
	}



	// Protected

	/**
	 * Creates a unique public id for a given server.
	 * @return string
	 */
	protected  function _createAPublicId($treeId){
		if (DEBUG_MODE_WITH_REAL_TREE_ID == false) {
			return md5(uniqid());
		}else{
			return $treeId;
		}

	}


	/**
	 * The infos folder for a given tree
	 * @param string $treeId
	 * @return string
	 */
	protected  function _treeInfosFolderPathFor($treeId){
		if (DEBUG_MODE_WITH_REAL_TREE_ID == false) {
			// The metadata folder uses the unique  tree id
			return $this->repositoryAbsolutePath() . SYSTEM_DATA_PREFIX . md5(BARTLEBY_SYNC_SECRET_KEY . $treeId) . DIRECTORY_SEPARATOR;
		} else {
			return $this->repositoryAbsolutePath() . SYSTEM_DATA_PREFIX . $treeId . DIRECTORY_SEPARATOR;
		}

	}

	/**
	 *  Returns the current public id of a given tree
	 * @param string $treeId
	 * @return string
	 */
	protected function _currentPublicId($treeId){
		if($this->treeData==NULL){
			$p=$this->_treeInfosFolderPathFor($treeId).TREE_INFOS_FILENAME;
			if($this->exists($p)){
				$this->treeData= json_decode( $this->get_contents($p));
				return $this->treeData[0];
			}
			return NULL;
		}else{
			return $this->treeData[0];
		}
	}


    public function removeGhosts(){
        // Void implementation
        return array();
    }

	// ABSTRACT METHOD

	public function exists($filename){
		return false;
	}

	public function put_contents($filename, $data){
		return false;
	}

	public function get_contents($filename){
		return NULL;

	}

	public function mkdir($dir){
		return false;
	}
	public function rename($oldname, $newname){
		return false;
	}

	public function copy( $source, $destination ){
		return false;
	}

	public function delete($filename){
		return false;
	}

	public function move_uploaded($filename, $destination){
		return false;
	}
	public function listRelativePathsIn ($rootPath,$prefix=''){
		return NULL;
	}

}
?>
#BMS#->{"filename":"IOManagerFS.php","checksum":4015715554,"relativePath":"BartlebySync\/Core\/IOManagerFS.php","size":7328}<-#BME#
<?php

namespace BartlebySync\Core;

use Bartleby\Core\Context;

require_once BARTLEBY_SYNC_ROOT_PATH.'/Core/IOManager.php';

/**
 * Concrete IOManager using a file system
 * @author bpds
 */
final class IOManagerFS extends IOManagerAbstract implements IOManagerPersistency {


	/* @var Context  */
	protected $_context=null;

	/**
	 * IOManagerAbstract constructor.
	 * @param Context $context
	 */
	public function __construct(Context $context){
		$this->_context=$context;
		$this->status = 200;
	}

	/**
	 * @return Context
	 */
	public function getContext(){
		return $this->_context;
	}


	public function exists($filename) {
		return @file_exists ( $filename );
	}
	
	public function put_contents($filename, $data) {
		return @file_put_contents ( $filename, $data );
	}
	
	public function get_contents($filename){
		return @file_get_contents($filename);
	}
	
	public function mkdir($dir) {
		if (! file_exists ( $dir )) {
			$result=@mkdir ( $dir, 0755, true );
			return $result;
		}else{
			$this->getContext()->consignIssue($dir.' already exists',__FILE__,__LINE__);
		}
		return true;
	}
	
	public function rename($oldname, $newname) {
        $this->delete($newname);
		return @rename ( $oldname, $newname );
	}
	
	public function copy( $source, $destination ){
        $this->delete($destination);
		return @copy($source, $destination);
	}

    /**
     * Deletes a file or recursively a folder
     * Returns true if the file or the folder does not exists.
     * @see IOManagerPersistency::delete()
     * @param $filename
     * @return bool
     */
	public function delete($filename){
		if(!file_exists($filename)){
			return true;
		}
		if(is_dir($filename)){
			// we delete folders with a recursive deletion method
			return $this->_rmdir($filename,true);
		}else{
			return @unlink($filename);
		}
	}

    /**
     * @param $dir
     * @param $result
     * @return bool
     */
    private function _rmdir($dir,$result) {
		if (is_dir($dir)) {
			$objects = @scandir($dir);
			foreach ($objects as $object) {
				if ($object != "." && $object != "..") {
					if (filetype($dir.DIRECTORY_SEPARATOR.$object) == "dir")
						$result=$result&&$this->_rmdir($dir.DIRECTORY_SEPARATOR.$object,$result);
					else 
						$result=$result&&@unlink($dir.DIRECTORY_SEPARATOR.$object);
				}
			}
			$result=$result&&@rmdir($dir);
		}
		return $result;
	}


    /**
     * @param $filename
     * @param $destination
     * @return bool
     */
    public function move_uploaded($filename, $destination) {
        $this->delete($destination);
		$this->mkdir( dirname ( $destination ));
		return @move_uploaded_file ( $filename, $destination );
	}


    /**
     * @param $dirPath
     * @param string $prefix
     * @return array
     */
    public function  listRelativePathsIn ($dirPath,$prefix=''){
		$dir = rtrim($dirPath, '\\/');
		$result = array();
		foreach (@scandir($dir) as $f) {
			if ($f !== '.' and $f !== '..') {
				if (is_dir("$dir/$f")) {
					$result = array_merge($result , $this->listRelativePathsIn("$dir/$f", "$prefix$f/"));
				} else {
					$result[] = $prefix.$f;
				}
			}
		}
		return $result;
	}

    public function removeGhosts(){
        $deletedPath=array();
        $foundPath=array();
        $pathFoundInTreeInfo=array();
        $dir=$this->repositoryAbsolutePath();
        $messages=array();
        foreach (@scandir($dir) as $f) {
            $path="$dir$f";
            if (! is_dir($path)){
                $messages[]="$path is not a folder | ";
                $deletedPath[]=$path;
                $this->delete($path);
                continue;
            }
            if($f!='.' && $f!='..'){
                $foundPath[]=$path;
                $p=$dir.$f.'/'.TREE_INFOS_FILENAME;
                if($this->exists($p)){
                    $this->treeData= json_decode( $this->get_contents($p));
                    $associatedPath=$dir.$this->treeData[0].'/';
                    $pathFoundInTreeInfo[]=$associatedPath;
                    if($this->exists($associatedPath)==false){
                        //IF there is TREE INFO file but no associated folder.
                        //ITS is a GHOST Delete the folder
                        $messages[]="$p is associated with a path that do not exists ($associatedPath) | ";
                        $deletedPath[]=$path;
                        $this->delete($path);
                    }
                }
            }
        }
        foreach ($foundPath as $p) {
            $path_parts = pathinfo($p);
            $fileName=$path_parts['basename'];
            $startByDot=(substr ($fileName,0,1 ) == ".");
            if( !in_array($p.'/',$pathFoundInTreeInfo) && !$startByDot){
                //  IF THERE IS NO ASSOCIATED TREE_INFOS_FILENAME IT IS A GHOST
                $messages[]="$p has no tree info file | ";
                $deletedPath[]=$p;
                $this->delete($p);
            }

        }
        return array(
                        "deletedPath"=> $deletedPath,
                        "messages"=>$messages
        );
    }


	/***
	 * Returns true if the installation has occured
	 * This method proceed to repository folder creation and verify that Php can write files.
	 * @param $path
	 * @return bool
	 */
	public function install($path) {

		clearstatcache();
		$installationIsWorking=true;
		$context=$this->getContext();

		if (!isset($path)){
			$context->consignIssue('Repository path is undefined',__FILE__,__LINE__);
			$path = $this->repositoryAbsolutePath();
		}

		$context->consignIssue('Current system user: '.get_current_user(),__FILE__,__LINE__);
		$writable= ( is_writable($path) ? "yes" : "no");
		$context->consignIssue('Is writable: '.$writable,__FILE__,__LINE__);


		if (!$fp = fopen($path, 'r')) {
			$context->consignIssue('Unable to open '.$path,__FILE__,__LINE__);
		}else{
			$meta = @stream_get_meta_data($fp);
			$context->consignIssue('Meta '.json_encode($meta),__FILE__,__LINE__);
		}

		if (!$this->exists ( $path )){
			$creation=$this->mkdir ( $path );
			if ($creation==false){
				$context->consignIssue('Folder creation as failed: '.$path,__FILE__,__LINE__);
			}
		}else{
			$context->consignIssue('Repository exists',__FILE__,__LINE__);
		}


		// Try to create a file in the created folder
		// This is a must so we set


		$content='ok';
		$filePath=$path.'temp.txt';
		$result=$this->put_contents($filePath,$content);
		if ($result==false){
			$context->consignIssue('Creation of '.$filePath.' has failed',__FILE__,__LINE__);
			$installationIsWorking=false;
		}else{
			// Remove this file
			$result=$this->delete($filePath);
			if ($result==false){
				$context->consignIssue('Deletion of '.$filePath.'temp.txt'.' has failed',__FILE__,__LINE__);
				$installationIsWorking=false;
			}
		}

		// Try to create a file in the parent folder
		// But do not block if it fails
		$content='ok';
		$filePath=dirname($path).'/temp.txt';
		$result=$this->put_contents($filePath,$content);
		if ($result==false){
			$context->consignIssue('Creation of '.$filePath.' has failed',__FILE__,__LINE__);
		}else{
			// Remove this file
			$result=$this->delete($filePath);
			if ($result==false){
				$context->consignIssue('Deletion of '.$filePath.'temp.txt'.' has failed',__FILE__,__LINE__);
			}
		}

		return $installationIsWorking;
	}



}
?>#BMS#->{"filename":"BartlebySyncAbstractEndPoint.php","checksum":2284127813,"relativePath":"BartlebySync\/EndPoints\/BartlebySyncAbstractEndPoint.php","size":2293}<-#BME#
<?php

namespace Bartleby\EndPoints;

include_once dirname(dirname(__FILE__)).'/BartlebySyncConfiguration.php';

require_once BARTLEBY_ROOT_FOLDER . 'Mongo/MongoEndPoint.php';
require_once BARTLEBY_SYNC_ROOT_PATH.'Core/CommandInterpreter.php';
require_once BARTLEBY_SYNC_ROOT_PATH.'Core/IOManager.php';

use Bartleby\Core\CallData;
use Bartleby\Mongo\MongoEndPoint;
use BartlebySync\Core\CommandInterpreter;
use BartlebySync\Core\IOManager;
// We donnot use CallDataRawWrapper but a callData
// We reserve CallDataRawWrapper to generated code
abstract class BartlebySyncAbstractEndPointCallData extends CallData{
    /**
     * The creative key
     * @var string*/
    public $key=NULL;

}

abstract class BartlebySyncAbstractEndPoint extends MongoEndPoint {

    /**
     * The command interpreter
     *
     * @var CommandInterpreter
     */
    protected $interpreter = NULL;
    
    /**
     *
     * @var IOManager
     */
    protected $ioManager = NULL;

    /**
     * A lazy loading command interpreter
     * with its associated file manager
     *
     * @return CommandInterpreter the interpreter
     */
    protected function getInterpreter() {
        if (! $this->interpreter) {
            $this->interpreter = new CommandInterpreter ();
            $this->interpreter->setIOManager ( $this->getIoManager () );
        }
        return $this->interpreter;
    }

    /**
     *
     * @return IOManager the current IO manager
     */
    protected function getIoManager() {
        if (! $this->ioManager) {
            $className = PERSISTENCY_CLASSNAME;
            $this->ioManager = new $className ($this->_context);
        }
        return $this->ioManager;
    }

    /**
     * Casts to boolean
     * @param mixed
     * @return bool
     */
    protected  function _castToBoolean($value){
        if (is_string($value)){
            $lcvalue=strtolower($value);
            if ($lcvalue ==='false'||$lcvalue ==='no'||$lcvalue ==='0'){
                return false;
            }else{
                return true;
            }
        }
        if (is_numeric($value)){
            $nvalue=(int)$value;
            if ($nvalue<=0){
                return false;
            }else{
                return true;
            }
        }
        return true;
    }

}#BMS#->{"filename":"BartlebySyncCreateTree.php","checksum":561688008,"relativePath":"BartlebySync\/EndPoints\/BartlebySyncCreateTree.php","size":1329}<-#BME#
<?php

namespace Bartleby\EndPoints;

require_once __DIR__ . '/BartlebySyncAbstractEndPoint.php';
require_once BARTLEBY_ROOT_FOLDER . 'Core/Configuration.php';

use Bartleby\Core\JsonResponse;
use Bartleby\Configuration;

final class BartlebySyncCreateTreeCallData extends BartlebySyncAbstractEndPointCallData {

    /**
     * The id of the tree to be created
     * @var string
     */
    public $treeId = NULL;

}

final class BartlebySyncCreateTree extends BartlebySyncAbstractEndPoint {

    function call() {

        /* @var BartlebySyncCreateTreeCallData */
        $parameters=$this->getModel();
        
        if (!isset($parameters->treeId) || strlen($parameters->treeId) < MIN_TREE_ID_LENGTH) {
            return new JsonResponse(VOID_RESPONSE, 406);
        }
        $this->ioManager = $this->getIoManager();
        $result = $this->ioManager->createTree($parameters->treeId);
        if ($result == NULL) {
            return new JsonResponse(VOID_RESPONSE, 201);
        } else {
            if ( $this->_configuration->DEVELOPER_DEBUG_MODE() === true ) {
                return new JsonResponse(array("parameters" => $parameters,
                    "IOManager.explanation" => $result), 400);
            } else {
                return new JsonResponse(VOID_RESPONSE, 400);
            }

        }
    }
}#BMS#->{"filename":"BartlebySyncDeleteTree.php","checksum":1259091597,"relativePath":"BartlebySync\/EndPoints\/BartlebySyncDeleteTree.php","size":1316}<-#BME#
<?php

namespace Bartleby\EndPoints;

require_once __DIR__ . '/BartlebySyncAbstractEndPoint.php';
require_once BARTLEBY_ROOT_FOLDER . 'Core/Configuration.php';

use Bartleby\Core\JsonResponse;
use Bartleby\Configuration;

final class BartlebySyncDeleteTreeCallData extends BartlebySyncAbstractEndPointCallData {

    /**
     * The id of the tree to be created
     * @var string
     */
    public $treeId = NULL;

}

final class BartlebySyncDeleteTree extends BartlebySyncAbstractEndPoint {

    function call() {

        /* @var BartlebySyncDeleteTreeCallData */
        $parameters=$this->getModel();
        
        if (!isset($parameters->treeId) || strlen($parameters->treeId) < MIN_TREE_ID_LENGTH) {
            return new JsonResponse(VOID_RESPONSE, 406);
        }
        $this->ioManager = $this->getIoManager();
        $result = $this->ioManager->deleteTree($parameters->treeId);
        if ($result == NULL) {
            return new JsonResponse(VOID_RESPONSE, 200);
        } else {
            if (Configuration::DEVELOPER_DEBUG_MODE == true) {
                return new JsonResponse(array("parameters" => $parameters,
                    "IOManager.explanation" => $result), 400);
            } else {
                return new JsonResponse(VOID_RESPONSE, 400);
            }

        }
    }
}#BMS#->{"filename":"BartlebySyncFinalizeTransactionIn.php","checksum":1843166773,"relativePath":"BartlebySync\/EndPoints\/BartlebySyncFinalizeTransactionIn.php","size":5038}<-#BME#
<?php

namespace Bartleby\EndPoints;

require_once __DIR__ .'/BartlebySyncAbstractEndPoint.php';

use Bartleby\Core\JsonResponse;


final class BartlebySyncFinalizeTransactionInCallData extends BartlebySyncAbstractEndPointCallData{

    /**
     * The id of the tree to be created
     * @var string*/
    public $treeId=NULL;

    public $commands=NULL;

    public $syncIdentifier=NULL;

    // The final HashMap
    public $hashMap=NULL;

}

final class BartlebySyncFinalizeTransactionIn extends BartlebySyncAbstractEndPoint {

    /**
     * Finalizes the synchronization transaction with a bunch, then save the hashMap.
     *
     * @param BartlebySyncFinalizeTransactionInCallData $parameters
     * @return JsonResponse
     */
    function call() {
        
        /* @var BartlebySyncFinalizeTransactionInCallData */
        $parameters=$this->getModel();
        
        if (isset ($parameters->syncIdentifier) && isset ($parameters->commands) && isset($parameters->hashMap)) {
            $commands = $parameters->commands;
            // We accept encoded string
            if (!is_array($commands)) {
                try {
                    $commands = json_decode($parameters->commands);
                } catch (\Exception $e) {
                    return new JsonResponse('Invalid json command array = ' . $parameters->commands, 400);
                }
            }
            if (is_array($commands)) {
                if (!isset ($parameters->treeId)) {
                    return new JsonResponse('Undefined treeId', 404);
                }
                if (strlen($parameters->treeId) < MIN_TREE_ID_LENGTH) {
                    return new JsonResponse(VOID_RESPONSE, 406);
                }
                $errors = $this->getInterpreter()->interpretBunchOfCommand($parameters->treeId, $parameters->syncIdentifier, $commands, $parameters->hashMap);
                if ($errors == NULL) {
                    // We do not want to clean up on success
                    return new JsonResponse(VOID_RESPONSE, 201);

                } else {

                    // We cleanup if we encountered errors during finalization.
                    // We cannot guarantee a consistent state.
                    // This case should not occur !
                    if (CLEAN_UP_ON_ERROR){
                        $this->cleanUp ($parameters);
                    }

                    return new JsonResponse(array(
                            "message"=>"We have encountered a finalization error. It should be reported to the system adminstrator",
                            "errors" => $errors,
                            "commands" => $commands),
                        417);
                }
            } else {
                return new JsonResponse ('commands must be an array = ' . $parameters->commands, 400);
            }
        } else {
            return new JsonResponse('commands :' . $parameters->commands . ', hashMapSourcePath:' . $_FILES ['hashmap'] . ',  syncIdentifier:' . $parameters->syncIdentifier . ' are required', 400);
        }
    }

    /**
     * We cleanup for a given synchronization ID
     * @param BartlebySyncFinalizeTransactionInCallData $parameters
     * @return JsonResponse
     */
    function cleanUp(BartlebySyncFinalizeTransactionInCallData $parameters) {

        if (!isset ($parameters->treeId)) {
            return new JsonResponse('Undefined treeId', 404);
        }
        if (strlen($parameters->treeId) < MIN_TREE_ID_LENGTH) {
            return new JsonResponse(VOID_RESPONSE, 406);
        }


        if (!isset ($parameters->syncIdentifier)) {
            return new JsonResponse('Undefined syncIdentifier', 404);
        }

        if (strlen($parameters->syncIdentifier)< 20 ){
            return new JsonResponse('syncIdentifier should be 20 char min.', 417);
        }

        $this->ioManager = $this->getIoManager();
        $rootPath = $this->ioManager->absoluteUrl($parameters->treeId, '');
        $fileList = $this->ioManager->listRelativePathsIn($rootPath);
        $deletedPath = array();
        $unModifiedPath = array();

        foreach ($fileList as $relativePath) {
            if (substr($relativePath, -1) != "/") {
                // It is not a folder.
                $pathInfos = pathinfo($relativePath);
                $fileName = $pathInfos ['basename'];
                if ($this->_stringStartsWith($fileName,$parameters->syncIdentifier)) {
                    $absoluteUrl = $this->ioManager->absoluteUrl($parameters->treeId, $relativePath);
                    $this->ioManager->delete($absoluteUrl);
                    $deletedPath [] = $relativePath;
                } else {
                    $unModifiedPath[] = $relativePath;
                }
            };
        };
        return new JsonResponse(array("deleted" => $deletedPath, "notModified" => $unModifiedPath), 200);
    }

    private function _stringStartsWith($haystack, $needle) {
        return (strpos($haystack, $needle) !== FALSE);
    }

}#BMS#->{"filename":"BartlebySyncGetFile.php","checksum":2944911003,"relativePath":"BartlebySync\/EndPoints\/BartlebySyncGetFile.php","size":2595}<-#BME#
<?php

namespace Bartleby
\EndPoints;

require_once __DIR__ . '/BartlebySyncAbstractEndPoint.php';

use Bartleby\Core\JsonResponse;
use Bartleby\EndPoints\BartlebySyncAbstractEndPoint;
use Bartleby\EndPoints\BartlebySyncAbstractEndPointCallData;

final class BartlebySyncGetFileCallData extends BartlebySyncAbstractEndPointCallData {

    /**
     * The id of the tree to be created
     * @var string
     */
    public $treeId = NULL;

    /**
     * @var bool redirect to a repository URI
     */
    public $redirect=true;

    /**
     * Returns the value if there is a redirection the redirection applies.
     * @var bool return the value
     */
    public $returnValue=false;

    /**
     * The relative path
     * @var string
     */
    public $path = NULL;


}

final class BartlebySyncGetFile extends BartlebySyncAbstractEndPoint {

    function call() {

        /* @var BartlebySyncGetFileCallData */
        $parameters=$this->getModel();


        $redirect=$this->_castToBoolean($parameters->redirect);
        $returnValue=$this->_castToBoolean($parameters->returnValue);

        if (!isset($parameters->treeId)) {
            return new JsonResponse(VOID_RESPONSE, 406);
        }

        if (strlen($parameters->treeId) < MIN_TREE_ID_LENGTH) {
            return new JsonResponse(VOID_RESPONSE, 406);
        }

        if (!isset($parameters->path)) {
            return new JsonResponse(VOID_RESPONSE, 404);
        }

        $this->ioManager = $this->getIoManager();
        $path = $this->ioManager->absoluteUrl($parameters->treeId, $parameters->path);
        if (!$this->ioManager->exists($path)) {
            return new JsonResponse(VOID_RESPONSE, 404);
        }
        if ($returnValue && !$redirect) {
            //This approach can be very expensive.
            $result = $this->ioManager->get_contents($path);
            return new JsonResponse($result, $this->ioManager->getStatus());
        }
        
        // Using an URI is more flexible.
        // It can facilitate load balancing by distributing to multiple repository.
        $uri = $this->ioManager->uriFor($parameters->treeId, $parameters->path);

        if ($redirect) {
            // This is the best approach
            // Redirect with a 307 code
            header('Location:  ' . $uri . '?antiCache=' . uniqid(), true, 307);
            exit ();
        } else {

            // But if it fails we can use
            // A two step approach.

            $infos = array();
            $infos ["uri"] = $uri;
            return new JsonResponse($infos, 200);
        }

    }
}

#BMS#->{"filename":"BartlebySyncGetHashMap.php","checksum":2287464618,"relativePath":"BartlebySync\/EndPoints\/BartlebySyncGetHashMap.php","size":2120}<-#BME#
<?php

namespace Bartleby\EndPoints;

require_once __DIR__ .'/BartlebySyncAbstractEndPoint.php';

use Bartleby\Core\JsonResponse;
use Bartleby\EndPoints\BartlebySyncAbstractEndPoint;
use Bartleby\EndPoints\BartlebySyncAbstractEndPointCallData;

final class BartlebySyncGetHashMapCallData extends BartlebySyncAbstractEndPointCallData{

    /**
     * The id of the tree to be created
     * @var string*/
    public $treeId=NULL;

    /**
     * @var bool redirect to a repository URI
     */
    public $redirect=true;

    /**
     * Returns the value if there is a redirection the redirection applies.
     * @var bool return the value
     */
    public $returnValue=false;

}

final class BartlebySyncGetHashMap extends BartlebySyncAbstractEndPoint {

    function call(){

        /* @var BartlebySyncGetHashMapCallData */
        $parameters=$this->getModel();
        
        $redirect=$this->_castToBoolean($parameters->redirect);
        $returnValue=$this->_castToBoolean($parameters->returnValue);

        if ( !isset($parameters->treeId) ) {
            return new JsonResponse(VOID_RESPONSE, 406);
        }

        if (strlen($parameters->treeId) < MIN_TREE_ID_LENGTH) {
            return new JsonResponse(VOID_RESPONSE, 406);
        }

        $this->ioManager = $this->getIoManager ();
        $path = $this->ioManager->absoluteUrl ( $parameters->treeId, METADATA_FOLDER . '/'. HASHMAP_FILENAME );
        if (! $this->ioManager->exists ( $path )) {
            return new JsonResponse(VOID_RESPONSE, 404 );
        }
        if ($returnValue && ! $redirect) {
            $result = $this->ioManager->get_contents ( $path );
            return new JsonResponse($result, $this->ioManager->getStatus());
        }

        $uri = $this->ioManager->uriFor ( $parameters->treeId, METADATA_FOLDER .'/'. HASHMAP_FILENAME );
        if ($redirect) {
            header('Location:  ' . $uri . '?antiCache=' . uniqid(), true, 307);
            exit ();
        } else {
            $infos = array ();
            $infos ["uri"] = $uri;
            return new JsonResponse( $infos, 200 );
        }

    }
}

#BMS#->{"filename":"BartlebySyncInstall.php","checksum":998689376,"relativePath":"BartlebySync\/EndPoints\/BartlebySyncInstall.php","size":1054}<-#BME#
<?php

namespace Bartleby\EndPoints;

require_once __DIR__ . '/BartlebySyncAbstractEndPoint.php';

use Bartleby\Core\JsonResponse;

final class BartlebySyncInstallCallData extends BartlebySyncAbstractEndPointCallData {

    
}

final class BartlebySyncInstall extends BartlebySyncAbstractEndPoint {

    function call() {
        /* @var BartlebySyncInstallCallData */
        $parameters=$this->getModel();
        $this->ioManager = $this->getIoManager();
        $result=$this->ioManager->install(REPOSITORY_WRITING_PATH);
        $context=$this->ioManager->getContext();
        if ($result==true){
            //$context->issue
            //'Repository path is undefined'
            if ($context->containsIssueWithText('Repository exists')){
                return new JsonResponse(VOID_RESPONSE, 200);
            }else{
                return new JsonResponse(VOID_RESPONSE, 201);
            }
        }else{
            return new JsonResponse(['message'=> $context->issues,'repositoryPath'=>REPOSITORY_WRITING_PATH], 417);
        }

    }
}
#BMS#->{"filename":"BartlebySyncRemoveGhosts.php","checksum":1867846721,"relativePath":"BartlebySync\/EndPoints\/BartlebySyncRemoveGhosts.php","size":577}<-#BME#
<?php

namespace Bartleby\EndPoints;

require_once __DIR__ . '/BartlebySyncAbstractEndPoint.php';

use Bartleby\Core\JsonResponse;

final class BartlebySyncRemoveGhostsCallData extends BartlebySyncAbstractEndPointCallData {

}

final class BartlebySyncRemoveGhosts extends BartlebySyncAbstractEndPoint {

    function call() {
        /* @var BartlebySyncRemoveGhostsCallData */
        $parameters=$this->getModel();
        $this->ioManager = $this->getIoManager();
        $details = $this->ioManager->removeGhosts();
        return new JsonResponse($details, 201);
    }
}
#BMS#->{"filename":"BartlebySyncSupports.php","checksum":1325681887,"relativePath":"BartlebySync\/EndPoints\/BartlebySyncSupports.php","size":489}<-#BME#
<?php

namespace Bartleby\EndPoints;

require_once __DIR__ .'/BartlebySyncAbstractEndPoint.php';

use Bartleby\Core\JsonResponse;

final class BartlebySyncSupportsCallData extends BartlebySyncAbstractEndPointCallData{
}

final class BartlebySyncSupports extends BartlebySyncAbstractEndPoint {

    function call(){
        /* @var BartlebySyncSupportsCallData */
        $parameters=$this->getModel();
        return new JsonResponse(array('version'=>BARTLEBY_SYNC_VERSION), 200);
    }

}#BMS#->{"filename":"BartlebySyncTouchTree.php","checksum":4011132794,"relativePath":"BartlebySync\/EndPoints\/BartlebySyncTouchTree.php","size":969}<-#BME#
<?php

namespace Bartleby\EndPoints;

require_once __DIR__ . '/BartlebySyncAbstractEndPoint.php';

use Bartleby\Core\JsonResponse;

final class BartlebySyncTouchTreeCallData extends BartlebySyncAbstractEndPointCallData{

    /**
     * The id of the tree to be created
     * @var string
     */
    public $treeId = NULL;

}

final class BartlebySyncTouchTree extends BartlebySyncAbstractEndPoint{

    function call(){
        /* @var BartlebySyncTouchTreeCallData */
        $parameters=$this->getModel();
        if (!isset($parameters->treeId) || strlen($parameters->treeId) < MIN_TREE_ID_LENGTH) {
            return new JsonResponse(VOID_RESPONSE, 406);
        }
        $this->ioManager = $this->getIoManager();
        $result = $this->ioManager->touchTree($parameters->treeId);
        if ($result == NULL) {
            return new JsonResponse(VOID_RESPONSE, 201);
        } else {
            return new JsonResponse(VOID_RESPONSE, 404);
        }

    }
}#BMS#->{"filename":"BartlebySyncUploadFileTo.php","checksum":2963497973,"relativePath":"BartlebySync\/EndPoints\/BartlebySyncUploadFileTo.php","size":4461}<-#BME#
<?php


namespace Bartleby\EndPoints;

require_once __DIR__ . '/BartlebySyncAbstractEndPoint.php';

use Bartleby\Core\JsonResponse;

final class BartlebySyncUploadFileToCallData extends BartlebySyncAbstractEndPointCallData {

    /**
     * The id of the tree to be created
     * @var string
     */
    public $treeId = NULL;

    public $destination = NULL;

    public $syncIdentifier = NULL;

}

final class BartlebySyncUploadFileTo extends BartlebySyncAbstractEndPoint {

    function call() {
        /* @var BartlebySyncUploadFileToCallData */
        $parameters=$this->getModel();
        if (!isset($parameters->treeId)) {
            return new JsonResponse(VOID_RESPONSE, 404);
        }

        if (strlen($parameters->treeId) < MIN_TREE_ID_LENGTH) {
            return new JsonResponse(VOID_RESPONSE, 406);
        }

        if (isset ($parameters->destination) && isset ($parameters->syncIdentifier)) {

            $this->ioManager = $this->getIoManager();
            $treeFolder = $this->ioManager->absoluteUrl($parameters->treeId, '');

            if (isset ($treeFolder) && $this->ioManager->exists($treeFolder)) {

                $destination = $parameters->destination;
                $syncIdentifier = $parameters->syncIdentifier;
                $isAFolder = (substr($destination, -1) == "/");
                $d = $this->ioManager->absoluteUrl($parameters->treeId, $destination);

                if ($isAFolder == true) {

                    // We create directly the folder without the sync identifier
                    if ($this->ioManager->mkdir($d)) {
                        return new JsonResponse(VOID_RESPONSE, 201);
                    } else {
                        return new JsonResponse("Mkdir failure" . $destination, 417);
                    }

                } else {

                    // there is a source it should be a file.
                    $d = dirname($destination) . DIRECTORY_SEPARATOR . $syncIdentifier . basename($destination);
                    $destinationPath = $this->ioManager->absoluteUrl($parameters->treeId, $d);

                    // We create the folder if necessary.
                    $this->ioManager->mkdir(dirname($destinationPath));

                    ////////////////
                    // Use $_FILES
                    ////////////////

                    if (isset ($_FILES ['source'])) {
                        // URLSession do not set $_FILES
                        // But if a client populates  $_FILES it can be a relevant approach.
                        if ($this->ioManager->move_uploaded($_FILES ['source'] ['tmp_name'], $destinationPath)) {
                            return $this->_reponse($destinationPath);
                        }

                        // We prefer to resume on failure
                        // Lack of else is a choice
                    }

                    ////////////////////////
                    // USE a stream input.
                    ////////////////////////

                    // We prefer not to load the file in memory.
                    // direct stream handling without that requires less memory than
                    // $flow= $this->ioManager->get_contents("php://input");
                    // $this->ioManager->put_contents($destinationPath,$flow);

                    $flow = fopen("php://input", "r");
                    /* Open a file for writing */
                    $fp = fopen($destinationPath, "w");
                    /* Read the data 1 KB at a time and write to the file */
                    while ($data = fread($flow, 1024)) {
                        fwrite($fp, $data);
                    }
                    fclose($fp);
                    fclose($flow);

                    ////////////////////////
                    return $this->_reponse($destinationPath);
                }

            } else {
                return new JsonResponse('Unexisting tree id ' . $treeFolder, 417);
            }
        } else {
            return new JsonResponse('The components destination and syncIdentifier are required', 417);
        }
    }


    private  function _reponse($destinationPath){
        if ($this->ioManager->exists($destinationPath)) {
            return new JsonResponse(VOID_RESPONSE, 201);
        } else {
            return new JsonResponse('An error has occured the uploaded has not been created' . $destinationPath, 410);
        }
    }

}



#BMS#->{"filename":"README.md","checksum":3166715634,"relativePath":"BartlebySync\/README.md","size":17955}<-#BME#
# BartlebySync 1.0 

BartlebySync is a delta synchronizer for documents and data between devices.It allows to synchronizes local and distant grouped files tree.The standard synchronization topology relies on a client software and a light blind Restfull service, but can work locally and using P2P.


## Approach ##

- delegate as much as possible of the synchronization logic to the clients to distribute the load and to save server charge and bandwidth
- keep it as minimal and simple as possible
- do not focus on conflict resolution but on fault resilience (there is no transactional guarantee)
- allow very efficient caching and mem caching strategy (we will provide advanced implementation samples)
- support any encryption and cryptographic strategy
- allow advanced hashing strategy ( like : considering that a modified file should not be synchronized because the modification is not significant. e.g a metadata has changed.)

## HashMap  ##

For BartlebySync a **HashMap** is a dictionary with for a given folder the list of all its files relative path as a key and a Hash as a value or the inverse.

The master maintains one HashMap per root folder, the hash map is always crypted client side.


Json representation :

```javascript
	{
		 "hashToPath" : {
    		 "1952419745" : "47b2e7fb27643408f95f7c66d995fbe9.music",
    		 "2402594160" : "folder1/4fd6de231a723be15375552928c9c52a.track",
  		}
	}
```
## DeltaPathMap ##

A **DeltaPathMap** references the differences between two **HashMap** and furnish the logic to planify downloading or uploading command operations for clients according to their role.

Json representation :

```javascript
	{
		"createdPaths":[],
		"copiedPaths":["folder1/a.mp3","folder2/a.mp3"],
		"deletedPaths":[],
		"movedPaths":["x.txt","folder1/y.txt"],
		"updatedPaths":["folder1/4fd6de231a723be15375552928c9c52a.track"],
	}
```

## Synchronization process synopsis ##

With 1 Source client (Objc), 1 sync service(php), and n Destination clients(Objc)

1. Source -> downloads the **HashMap** (if there is no HashMap the delta will be the current local)
2. Source -> proceed to **DeltaPathMap**  creation and command provisionning
3. Source -> uploads files with a .<SyncID> prefix to the service
4. Source -> uploads the hasMap of the current root folder and finalize the transaction (un prefix the files, and call the sanitizing procedure =  removal of orpheans, **Optionaly** the synch server can send a push notification to the slave clients to force the step 5)
5. Destination -> downloads the current **HashMap** ( Or its HashMapView representation??)
6. Destination -> proceeds to **DeltaPathMap** creation and command provisionning
7. Destination -> downloads the files (on any missing file the task list is interrupted, the local hash map is recomputed and we step back to 5)
8. Destination -> on completion the synchronization is finalized. (We redownload the **HashMap** and compare to conclude if stepping back to 5 is required.)

# BartlebySync PHP #
A very simple PHP sync restfull service to use in conjonction with BartlebySync objc, swift client

### Status codes ###

* 1xx: Informational - Request received, continuing process
* 2xx: Success - The action was successfully received, understood, and accepted
* 3xx: Redirection - Further action must be taken in order to complete the request
* 4xx: Client Error - The request contains bad syntax or cannot be fulfilled
* 5xx: Server Error - The server failed to fulfill an apparently valid request

#### Notable client errors ####

* 401 => 'Unauthorized' : if auth is required
* 423 => 'Locked' : if locked

##### Status code references ####
[www.w3.org] (http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html), [www.ietf.org] (http://www.ietf.org/assignments/http-status-codes/http-status-codes.xml)

#### Commands  : ####

Any command is encoded in an array.
Json Encoded command [BCopy,<BDestination>,<BSource>] : [1,'a/a.caf','b/c/c.caf'] will copy the file from 'b/c/c.caf' to 'a/a.caf'

##### Sync CMD ####
```c
typedef NS_ENUM (NSUInteger,
                  BSyncCommand) {
    BCreate   = 0 , 
    BUpdate   = 1 ,
    BMove     = 2 , 
    BCopy     = 3 , 
    BDelete   = 4 
} ;


typedef NS_ENUM(NSUInteger,
                BSyncCMDParamRank) {
    BCommand     = 0,
    BDestination = 1,
    BSource      = 2
} ;

```



## Installation of BartlebySync PHP ## 

Prerequisite, you should have a deployed Bartleby's app.

### Copy the BartlebySync module folder

BartlebySync Module folder Should be installed beside Bartleby's folder.
By default the file repository will be located in a "files/" folder beside Bartleby's folder
Normally The Repository Folder "files/" should be allocated to the "www-data" user and the right  set to 711.

### BartlebySyncConfiguration.php

- Define the BARTLEBY_SYNC_CREATIVE_KEY and BARTLEBY_SYNC_SECRET_KEY
- Define if necessary BARTLEBY_SYNC_ROOT_PATH, REPOSITORY_HOST, REPOSITORY_WRITING_PATH 


### Bartleby's app Configuration.php

In getEndpointsSearchPaths() add the module's endpoint folder to the searchpaths
```php
    function getEndpointsSearchPaths() {
        $searchPaths = parent::getEndpointsSearchPaths();
        ...
        $searchPaths[]=dirname(dirname($this->_executionDirectory)).'/BartlebySync/EndPoints/';
        return $searchPaths;
    }
```

Add the persmission in _configure()

```php  
    ...
 
    // BartlebySync
    'BartlebySyncSupports->call'=>array('level' => PERMISSION_NO_RESTRICTION),
    'BartlebySyncInstall->call'=>array('level' => PERMISSION_BY_IDENTIFICATION),
    'BartlebySyncCreateTree->call'=>array('level' => PERMISSION_BY_IDENTIFICATION),
    'BartlebySyncTouchTree->call'=>array('level' => PERMISSION_BY_IDENTIFICATION),
    'BartlebySyncGetHashMap->call'=>array('level' => PERMISSION_BY_IDENTIFICATION),
    'BartlebySyncGetFile->call'=>array('level' => PERMISSION_BY_IDENTIFICATION),
    'BartlebySyncUploadFileTo->call'=>array('level' => PERMISSION_BY_IDENTIFICATION),
    'BartlebySyncFinalizeTransactionIn->call'=>array('level' => PERMISSION_BY_IDENTIFICATION),
    'BartlebySyncFinalizeTransactionIn->cleanUp'=>array('level' => PERMISSION_IS_GRANTED_TO_SUPER_ADMIN_ONLY),// May be suspended ( it is used on finalizeTransactionIn)
    'BartlebySyncRemoveGhosts->call'=>array('level' => PERMISSION_BY_IDENTIFICATION)
```

Add the routes aliases 

```php  
    protected function  _getEndPointsRouteAliases() {
        $routes = parent::_getEndPointsRouteAliases();
        $mapping = array(
            ... 
            // BartlebySync
            'GET:/BartlebySync/isSupported'=>array('BartlebySyncSupports','call'),
            'GET:/BartlebySync/reachable'=>array('Reachable','GET'),
            'POST:/BartlebySync/install'=>array('BartlebySyncInstall','call'),
            'POST:/BartlebySync/create/tree/{treeId}'=>array('BartlebySyncCreateTree','call'),
            'POST:/BartlebySync/touch/tree/{treeId}'=>array('BartlebySyncTouchTree','call'),
            'GET:/BartlebySync/tree/{treeId}'=>array('BartlebySyncTouchTree','call'),//touch alias
            'GET:/BartlebySync/hashMap/tree/{treeId}'=>array('BartlebySyncGetHashMap','call'),
            'GET:/BartlebySync/file/tree/{treeId}'=>array('BartlebySyncGetFile','call'),
            'POST:/BartlebySync/uploadFileTo/tree/{treeId}'=>array('BartlebySyncUploadFileTo','call'),
            'POST:/BartlebySync/finalizeTransactionIn/tree/{treeId}'=>array('BartlebySyncFinalizeTransactionIn','call'),
            'POST:/BartlebySync/cleanUp/tree/{treeId}'=>array('BartlebySyncFinalizeTransactionIn','cleanUp'), // May be suspended ( it is used on finalizeTransactionIn)
            'POST:/BartlebySync/removeGhosts'=>array('BartlebySyncRemoveGhosts','call')
        );
        $routes->addAliasesToMapping($mapping);
        return $routes;
    }
```



## "The ultimate" Commandline tutorial ##

Copy and paste the command line in your shell environment.

### 1 Prerequesite:"Install HTTPie" ###
You can install [HTTPie] (https://github.com/jkbrzt/httpie)

### 2 Test if BartlebySync is supported ###

Define the BASE_URL temp variable : 

```shell
    BASE_URL=http://yd.local/api/v1/
````

Test if BartlebySync is supported : 

```shell
     http GET ${BASE_URL}BartlebySync/isSupported    
```
Successful Response HTTP status code 200: 

```shell
    HTTP/1.1 200 OK
    Access-Control-Allow-Methods: *
    Access-Control-Allow-Origin: *
    Connection: Keep-Alive
    Content-Length: 17
    Content-Type: application/json
    Date: Tue, 29 Dec 2015 08:57:47 GMT
    Keep-Alive: timeout=5, max=100
    Server: Apache
    X-Powered-By: PHP/5.6.10
    
    {
        "version": "1.5"
    }
```

### 3 Call BartlebySync Reachability endpoint

```shell
    http GET ${BASE_URL}BartlebySync/reachable
```

Successful Response HTTP status code 200: 

```shell
    HTTP/1.1 200 OK
    Access-Control-Allow-Methods: *
    Access-Control-Allow-Origin: *
    Connection: Keep-Alive
    Content-Length: 4
    Content-Type: application/json
    Date: Tue, 29 Dec 2015 10:06:38 GMT
    Keep-Alive: timeout=5, max=100
    Server: Apache
    X-Powered-By: PHP/5.6.10
    
    "{}"
```

### 4 create local assets 

Create a Sample folder 

```shell
    mkdir ~/Desktop/Samples/
```

Create a Sample files  

```shell
    touch ~/Desktop/Samples/text1.txt
    echo "Eureka1" > ~/Desktop/Samples/text1.txt
    touch ~/Desktop/Samples/text2.txt
    echo "Eureka2" > ~/Desktop/Samples/text2.txt
    touch ~/Desktop/Samples/hashmap.data
    echo  "[]" > ~/Desktop/Samples/hashmap.data
````

### 5 install the repository 

```shell
    http -v -f POST ${BASE_URL}BartlebySync/install/
````

Successful Response HTTP status code 201: 

```shell
    HTTP/1.1 201 Created
    Access-Control-Allow-Methods: *
    Access-Control-Allow-Origin: *
    Connection: Keep-Alive
    Content-Length: 4
    Content-Type: application/json
    Date: Tue, 29 Dec 2015 10:08:09 GMT
    Keep-Alive: timeout=5, max=100
    Server: Apache
    X-Powered-By: PHP/5.6.10
    
    "{}"
```

### 5 creates trees 

```shell
    http -v -f POST  ${BASE_URL}BartlebySync/create/tree/1 
    http -v -f POST  ${BASE_URL}BartlebySync/create/tree/2
    http -v -f POST  ${BASE_URL}BartlebySync/create/tree/3
```

Successful Response HTTP status code 201: 
 
```shell
    HTTP/1.1 201 Created
    Access-Control-Allow-Methods: *
    Access-Control-Allow-Origin: *
    Connection: Keep-Alive
    Content-Length: 4
    Content-Type: application/json
    Date: Tue, 29 Dec 2015 10:15:27 GMT
    Keep-Alive: timeout=5, max=100
    Server: Apache
    X-Powered-By: PHP/5.6.10
    
    "{}"
```

### 5A delete the tree 3 

```shell
    http -v -f DELETE ${BASE_URL}BartlebySync/delete/tree/3
```

Successful Response HTTP status code 200

```shell
     HTTP/1.1 200 OK
     Access-Control-Allow-Methods: *
     Access-Control-Allow-Origin: *
     Connection: Keep-Alive
     Content-Length: 4
     Content-Type: application/json
     Date: Fri, 20 May 2016 07:32:36 GMT
     Keep-Alive: timeout=5, max=100
     Server: Apache
     X-Powered-By: PHP/5.6.10
     
     "{}"
```



    

### 5B touch the tree "1" to reset its public id, then try an unexisting ID

```shell
    http -v -f POST ${BASE_URL}BartlebySync/touch/tree/1
```
    
Successful Response HTTP status code 201

```shell 
    HTTP/1.1 201 Created
    Access-Control-Allow-Methods: *
    Access-Control-Allow-Origin: *
    Connection: Keep-Alive
    Content-Length: 4
    Content-Type: application/json
    Date: Tue, 29 Dec 2015 11:11:34 GMT
    Keep-Alive: timeout=5, max=100
    Server: Apache
    X-Powered-By: PHP/5.6.10
    
    "{}"
```
  
Try an unexisting ID

```shell
    http -v -f POST ${BASE_URL}BartlebySync/touch/tree/unexisting-tree
```

Should Respond HTTP status code 404

```shell
    HTTP/1.1 404 Not Found
    Access-Control-Allow-Methods: *
    Access-Control-Allow-Origin: *
    Connection: Keep-Alive
    Content-Length: 4
    Content-Type: application/json
    Date: Tue, 29 Dec 2015 11:13:32 GMT
    Keep-Alive: timeout=5, max=100
    Server: Apache
    X-Powered-By: PHP/5.6.10
    
    "{}"
```

### 6 try to Grab the hashmap that should not exists

```shell
    http -v GET  ${BASE_URL}BartlebySync/hashMap/tree/1/ redirect==true returnValue==false
```

Should Respond HTTP status code 404

```shell
    HTTP/1.1 404 Not Found
    Access-Control-Allow-Methods: *
    Access-Control-Allow-Origin: *
    Connection: Keep-Alive
    Content-Length: 4
    Content-Type: application/json
    Date: Tue, 29 Dec 2015 11:15:37 GMT
    Keep-Alive: timeout=5, max=100
    Server: Apache
    X-Powered-By: PHP/5.6.10
    
    "{}"
```

### 7 Upload the files
    
```shell
    SYNC_ID="my_sync_id_"
    http -v -f POST  ${BASE_URL}BartlebySync/uploadFileTo/tree/1/ destination='file1.txt' syncIdentifier=${SYNC_ID} source@~/Desktop/Samples/text1.txt
    http -v -f POST  ${BASE_URL}BartlebySync/uploadFileTo/tree/1/ destination='file2.txt' syncIdentifier=${SYNC_ID} source@~/Desktop/Samples/text2.txt
```
    
HTTPie details on successful upload should Respond HTTP status code 201 ("created")

```shell
    POST /api/v1/BartlebySync/uploadFileTo/tree/1/ HTTP/1.1
    Accept: */*
    Accept-Encoding: gzip, deflate
    Connection: keep-alive
    Content-Length: 364
    Content-Type: multipart/form-data; boundary=5d042e80f3f4472882d2a071d2806ce2
    Host: yd.local
    User-Agent: HTTPie/0.9.2
    
    --5d042e80f3f4472882d2a071d2806ce2
    Content-Disposition: form-data; name="destination"
    
    a/file1.txt
    --5d042e80f3f4472882d2a071d2806ce2
    Content-Disposition: form-data; name="syncIdentifier"
    
    my_sync_id_
    --5d042e80f3f4472882d2a071d2806ce2
    Content-Disposition: form-data; name="source"; filename="text1.txt"
    
    Eureka1
    
    --5d042e80f3f4472882d2a071d2806ce2--
    
    HTTP/1.1 201 Created
    Access-Control-Allow-Methods: *
    Access-Control-Allow-Origin: *
    Connection: Keep-Alive
    Content-Length: 4
    Content-Type: application/json
    Date: Tue, 29 Dec 2015 11:18:22 GMT
    Keep-Alive: timeout=5, max=100
    Server: Apache
    X-Powered-By: PHP/5.6.10
    
    "{}"
```

### 8 Finalize the upload session

To remain simple we donnot inject the real hash map data but a placeholder.

```shell

    http -v -f POST ${BASE_URL}BartlebySync/finalizeTransactionIn/tree/1/ commands='[[0 ,"file1.txt"],[0 ,"file2.txt"]]' syncIdentifier=${SYNC_ID} hashMap@~/Desktop/Samples/hashmap.data 

```

NB: You could manually inject a checksum via cksum

```shell
    cksum ~/Desktop/Samples/text1.txt
    1812593931 8 /Users/bpds/Desktop/Samples/text1.txt
    cksum ~/Desktop/Samples/text2.txt
    1851787394 8 /Users/bpds/Desktop/Samples/text2.txt
   
    Update the hashmap.data file 
    {
        "pthToH" :  {
            "text1.txt" : 1812593931,
            "text2.txt" : 1851787394,
        }
    }
```
    
OBJC and swift client are implementing the delta logic, and all the synchronization scenari.
    

### Down Stream samples 


Download a hashmap 

```shell
   http -v GET  ${BASE_URL}BartlebySync/hashMap/tree/1/ redirect==false returnValue==true
```



Download a file 
```shell
    http -v GET ${BASE_URL}BartlebySync/file/tree/1/ path=='file1.txt' redirect==false returnValue==true
```    
    
The response with redirect==true returnValue==false

```shell
   
    HTTP/1.1 200 OK
    Access-Control-Allow-Methods: *
    Access-Control-Allow-Origin: *
    Connection: Keep-Alive
    Content-Length: 13
    Content-Type: application/json
    Date: Tue, 29 Dec 2015 13:59:42 GMT
    Keep-Alive: timeout=5, max=100
    Server: Apache
    X-Powered-By: PHP/5.6.10
    
    [
        "Eureka1\n"
    ]
    
```    
    
The response with redirect==true 

```shell
    http -v GET ${BASE_URL}BartlebySync/file/tree/1/ path=='file1.txt' redirect==true
    
   
    GET /api/v1/BartlebySync/file/tree/1/?redirect=true&path=file1.txt HTTP/1.1
    Accept: */*
    Accept-Encoding: gzip, deflate
    Connection: keep-alive
    Host: yd.local
    User-Agent: HTTPie/0.9.2
    
            
    HTTP/1.1 307 Temporary Redirect
    Connection: Keep-Alive
    Content-Length: 0
    Content-Type: text/html; charset=UTF-8
    Date: Tue, 29 Dec 2015 14:01:19 GMT
    Keep-Alive: timeout=5, max=100
    Location: http://yd.repository.local:9999/70e441ffc22a069b927d8b3791256f52/file1.txt
    Server: Apache
    X-Powered-By: PHP/5.6.10
```

You can access directly to the file in a browser : http://yd.repository.local:9999/70e441ffc22a069b927d8b3791256f52/file1.txt

   
# Remove Ghosts 

Remove Ghosts ( in case of repository corruption e.g : manual deletion of assets or injection of files) 

```shell
    http -v -f POST ${BASE_URL}BartlebySync/removeGhosts 

    HTTP/1.1 201 Created
    Access-Control-Allow-Methods: *
    Access-Control-Allow-Origin: *
    Connection: Keep-Alive
    Content-Length: 418
    Content-Type: application/json
    Date: Tue, 29 Dec 2015 14:17:14 GMT
    Keep-Alive: timeout=5, max=100
    Server: Apache
    X-Powered-By: PHP/5.6.10
    
    {
        "deletedPath": [
            ".../files/.DS_Store", 
            ".../files/ok.txt"
        ], 
        "messages": [
            ".../files/.DS_Store is not a folder | ", 
            ".../files/ok.txt is not a folder | "
        ]
    }
```

# Native Clients #

- OSX Bsync commandline 
- OSX BsyncXPC services
- Bsync lib (iOS, tvOS, OSX)


# BartlebySync 1.0 #

- BartlebySync 1.0 supports hashMapView : A hashMapView file is a hasmap that is stored with the regular files that should be used  Master>Slave downstream only
- BartlebySync 1.0 supports  folder directives.json {"source":"http://...", "destination":"file://...","role":"<[slave,master,both]>","dataView":"<name of view none for global hashmap>","repositoryRelativePath":"/medias/"} 
- BartlebySync 1.0 supports Interruptibily per command (once a command has be executed on resume it is skipped) ?
- BartlebySync 1.0 and offers a Sync progress interface ?
#BMS#->{"filename":"destroy-repository.sh","checksum":350952541,"relativePath":"destroy-repository.sh","size":51}<-#BME#
#!/usr/bin/env bash

rm -Rf ./files/
mkdir ./files/#BMS#->{"filename":"GenerativeConstants.php","checksum":3576378709,"relativePath":"GenerativeConstants.php","size":673}<-#BME#
<?php

if (!defined('BARTLEBY_FLEXIONS_ENVIRONMENT')){

    define('BARTLEBY_FLEXIONS_ENVIRONMENT',true);

    // Define the absolutes xOS clients generative export path
    define('xOS_APP_EXPORT_PATH','AP_xOS_AEP');
    define('xOS_BARTLEBYS_COMMONS_EXPORT_PATH','AP_xOS_BCEP');

    // Define relative path from Bartleby's parent folder to the public App Root Folder
    // You adjust this relative path
    // The most current configuration is :
    //  /Bartleby/              <- Bartleby's framework
    //  /Barleby_xxx/           <- Bartleby's modules
    //  /www/                   <- Bartleby's app document root
    define('APP_PUBLIC_ROOT_FOLDER','AP_PRF');

}#BMS#->{"filename":"globalflexions.sh","checksum":1972561042,"relativePath":"globalflexions.sh","size":301}<-#BME#
#!/usr/bin/env bash



cd ./Bartleby/Commons.flexions/EndPointsFromDefinitions/
php -f run.php

cd ../../../

cd ./Bartleby/Commons.flexions/App/
php -f run.php

cd ../../../

cd ./YouDubApi.flexions/EndPointsFromDefinitions/
php -f run.php

cd ../../

cd ./App.flexions/App/
php -f run.php

cd ../../#BMS#->{"filename":".htaccess","checksum":2201738643,"relativePath":"html\/.htaccess","size":347}<-#BME#
<IfModule mod_rewrite.c>

RewriteEngine On

# Routes to API
RewriteCond %{REQUEST_FILENAME} !-f
RewriteCond %{REQUEST_FILENAME} !-d
RewriteRule ^api/v1/(.*)$ api/go.php?request=$1 [QSA,NC,L]

# Routes to Pages
RewriteCond %{REQUEST_FILENAME} !-f
RewriteCond %{REQUEST_FILENAME} !-d
RewriteRule (.*)$ Pages/go.php?request=$1 [QSA,NC,L]

</IfModule>#BMS#->{"filename":"go.php","checksum":2373792713,"relativePath":"html\/api\/go.php","size":713}<-#BME#
<?php

namespace Bartleby;

require_once dirname(__DIR__) . '/Configuration.php';
require_once BARTLEBY_ROOT_FOLDER . 'Core/Gateway.php';
require_once BARTLEBY_ROOT_FOLDER . 'Core/JsonResponse.php';

use Bartleby\Configuration;
use Bartleby\Core\Gateway;
use Bartleby\Core\Mode;
use Bartleby\Core\JsonResponse;

$currentDirectory=__DIR__.'/';
$configuration=new Configuration($currentDirectory,BARTLEBY_ROOT_FOLDER);
$gateway = new Gateway($configuration,Mode::API);

try {
    $gateway->getResponse();
} catch (\Exception $e) {
    $status = 500;
    $header = 'HTTP/1.1 ' . $status . ' ' . JsonResponse::getRequestStatus($status);
    header($header);
    echo json_encode(Array('error' => $e->getMessage()));
}#BMS#->{"filename":"Configuration.php","checksum":1049131074,"relativePath":"html\/Configuration.php","size":7961}<-#BME#
<?php

// SHARED CONFIGURATION BETWEEN THE API & MAIN PAGES

namespace Bartleby;

// Where is Bartleby?
$baseDirectory = (dirname(__DIR__));
define('BARTLEBY_ROOT_FOLDER', $baseDirectory . '/Bartleby/');
define('BARTLEBY_PUBLIC_FOLDER',__DIR__ .'/');

require_once BARTLEBY_ROOT_FOLDER . 'Core/RoutesAliases.php';
require_once BARTLEBY_ROOT_FOLDER . 'Commons/Filters/FilterEntityPasswordRemover.php';
require_once BARTLEBY_ROOT_FOLDER . 'Commons/Filters/FilterCollectionOfEntityPasswordsRemover.php';
require_once BARTLEBY_ROOT_FOLDER . 'Commons/Filters/FilterHookByClosure.php';
require_once BARTLEBY_ROOT_FOLDER . 'Core/KeyPath.php';
require_once BARTLEBY_ROOT_FOLDER . 'Core/Stages.php';

require_once __DIR__ . '/api/v1/_generated/GeneratedConfiguration.php';

use Bartleby\Core\Stages;
use Bartleby\GeneratedConfiguration;

class Configuration extends GeneratedConfiguration {

    ////////////////////
    // BEHAVIORAL CONSTS
    ///////////////////

    /*
     * Can be used during development to simplify the tests.
     */
    const BY_PASS_SALTED_TOKENS = false;

    /*
    * Should be used once to call destructive installer.
    */
    const ALLOW_DESTRUCTIVE_INSTALLER = false;

    /**
     * Used to get more verbose response on Core
     */
    const DEVELOPER_DEBUG_MODE = true;


    /**
     * If set to true on multiple creation attempts
     * The exception thrown by the creation will be catched
     */
    const IGNORE_MULTIPLE_CREATION_IN_CRUD_MODE = true;


    /**
     * @param string
     * @param string
     */
    public function __construct($executionDirectory, $bartlebyRootDirectory) {
        parent::__construct($executionDirectory, $bartlebyRootDirectory);
        $this->_configure();
    }


    private function _configure() {

        /////////////////////////
        // APP configuration
        /////////////////////////

        $this->_STAGE = Stages::DEVELOPMENT;
        $this->_VERSION = 'v1';
        $this->_SECRET_KEY = 'AP_SK'; // 32 Bytes min
        $this->_SHARED_SALT='AP_PSS'; // 32 Bytes min

        /////////////////////////
        // MONGO DB
        /////////////////////////

        $this->_MONGO_DB_NAME = 'AP_MDN';


        $this->_configurePermissions();

        /////////////////////////
        // PARSE parameters.json
        /////////////////////////

        try{
            $path=__DIR__.'/Protected/parameters.json';
            $string=file_get_contents($path);
            if(isset($string)){
                $conf=json_decode($string,true);
                if(is_array($conf)){
                    if (array_key_exists("superAdmins",$conf)){
                        $sAdmins=$conf["superAdmins"];
                        if (is_array($sAdmins)){
                            $this->addSuperAdminUIDs($sAdmins);
                        }
                    }
                }
            }
        }catch (\Exception $e){
            // Silent catch
        }
    }



    protected function _configurePermissions(){

        parent::_configurePermissions();
        $permissions = array(

            // Check the Generated configuration
            // All the calls are set by default to PERMISSION_BY_TOKEN
            // Including AUTHENTICATION

            // You can add or modify permissions here.
            // If you declare a rule it will replace the generated rule.

            // Un comment
            //'CreateUser->call'=>array('level' =>PERMISSION_NO_RESTRICTION),

            //SSE Time
            'SSETime->GET'=> array('level'=> PERMISSION_NO_RESTRICTION),

            // Pages
            'Start->GET'=>array('level' => PERMISSION_NO_RESTRICTION),
            'Time->GET'=>array('level' => PERMISSION_NO_RESTRICTION),

            // BartlebySync
            'BartlebySyncSupports->call'=>array('level' => PERMISSION_BY_IDENTIFICATION),
            'BartlebySyncInstall->call'=>array('level' => PERMISSION_BY_IDENTIFICATION),
            'BartlebySyncCreateTree->call'=>array('level' => PERMISSION_BY_IDENTIFICATION),
            'BartlebySyncTouchTree->call'=>array('level' => PERMISSION_BY_IDENTIFICATION),
            'BartlebySyncGetHashMap->call'=>array('level' => PERMISSION_BY_IDENTIFICATION),
            'BartlebySyncGetFile->call'=>array('level' => PERMISSION_BY_IDENTIFICATION),
            'BartlebySyncUploadFileTo->call'=>array('level' => PERMISSION_BY_IDENTIFICATION),
            'BartlebySyncFinalizeTransactionIn->call'=>array('level' => PERMISSION_BY_IDENTIFICATION),
            'BartlebySyncFinalizeTransactionIn->cleanUp'=>array('level' => PERMISSION_IS_GRANTED_TO_SUPER_ADMIN_ONLY),// May be suspended ( it is used on finalizeTransactionIn)
            'BartlebySyncRemoveGhosts->call'=>array('level' => PERMISSION_IS_GRANTED_TO_SUPER_ADMIN_ONLY)
        );
        $this->addPermissions($permissions);
    }



    /////////////////////////
    // Pages aliases
    /////////////////////////

    protected function _getPagesRouteAliases() {
        $routes = parent::_getPagesRouteAliases();
        $mapping = array(
            '' => 'Start',
            'time' => 'Time',
            '*' => 'NotFound'
        );
        $routes->addAliasesToMapping($mapping);
        return $routes;
    }

    /////////////////////////
    // End points aliases
    /////////////////////////
    protected function  _getEndPointsRouteAliases() {
        $routes = parent::_getEndPointsRouteAliases();
        $mapping = array(
            //'POST:/user/{userId}/comments'=>array('CommentsByUser','POST_method_for_demo'),
            //'DELETE:/user/{userId}/comments'=>array('CommentsByUser','DELETE'),
            'time' => 'SSETime', // A server sent event sample
            // BartlebySync
            'GET:/BartlebySync/isSupported'=>array('BartlebySyncSupports','call'),
            'GET:/BartlebySync/reachable'=>array('Reachable','GET'),
            'POST:/BartlebySync/install'=>array('BartlebySyncInstall','call'),
            'POST:/BartlebySync/create/tree/{treeId}'=>array('BartlebySyncCreateTree','call'),
            'POST:/BartlebySync/touch/tree/{treeId}'=>array('BartlebySyncTouchTree','call'),
            'GET:/BartlebySync/tree/{treeId}'=>array('BartlebySyncTouchTree','call'),//touch alias
            'GET:/BartlebySync/hashMap/tree/{treeId}'=>array('BartlebySyncGetHashMap','call'),
            'GET:/BartlebySync/file/tree/{treeId}'=>array('BartlebySyncGetFile','call'),
            'POST:/BartlebySync/uploadFileTo/tree/{treeId}'=>array('BartlebySyncUploadFileTo','call'),
            'POST:/BartlebySync/finalizeTransactionIn/tree/{treeId}'=>array('BartlebySyncFinalizeTransactionIn','call'),
            'POST:/BartlebySync/cleanUp/tree/{treeId}'=>array('BartlebySyncFinalizeTransactionIn','cleanUp'), // May be suspended ( it is used on finalizeTransactionIn)
            'POST:/BartlebySync/removeGhosts'=>array('BartlebySyncRemoveGhosts','call')
        );
        $routes->addAliasesToMapping($mapping);
        return $routes;
    }


    // ################
    // ### ADVANCED ###
    // ################


    /////////////////////////
    // SEARCH PATHS
    /////////////////////////

    function getEndpointsSearchPaths() {
        $searchPaths = parent::getEndpointsSearchPaths();
        // You can add your own search paths if necessary
        // The search paths are absolute.
        // BartlebySync
        $searchPaths[]=dirname(dirname($this->_executionDirectory)).'/BartlebySync/EndPoints/';
        return $searchPaths;
    }

    function getPagesSearchPaths() {
        $searchPaths = parent::getPagesSearchPaths();
        // You can add your own search paths if necessary
        // The search paths are absolute.
        return $searchPaths;
    }

    function getModelsSearchPaths() {
        $searchPaths = parent::getModelsSearchPaths();
        // You can add your own search paths if necessary
        // The search paths are absolute.
        return $searchPaths;
    }
}#BMS#->{"filename":"are-cookies-enabled.php","checksum":2784482050,"relativePath":"html\/Diagnostics\/are-cookies-enabled.php","size":307}<-#BME#
<?php
if (isset($_GET['cookiecheck'])) {
    if (isset($_COOKIE['testcookie'])) {
        print "Cookies are enabled";
    } else {
        print "Cookies are not enabled";
    }
} else {
    setcookie('testcookie', "testvalue");
    die(header("Location: " . $_SERVER['PHP_SELF'] . "?cookiecheck=1"));
}
?>#BMS#->{"filename":"is-mcrypt-supported.php","checksum":3067284155,"relativePath":"html\/Diagnostics\/is-mcrypt-supported.php","size":592}<-#BME#
<?php

require_once dirname(__DIR__).'/Configuration.php';
use Bartleby\Configuration;

$directory=dirname(__DIR__).'/';
$configuration=new Configuration($directory,BARTLEBY_ROOT_FOLDER);;

if(function_exists('mcrypt_encrypt')) {
    print '"mcrypt" is available. ';
}else{
    print '"mcrypt" is not available! ';
}
if ($configuration->encryptIdentificationValue('NO_BODY','NO_DOCUMENT')=='NO_DOCUMENT'){
    print "But the authentication engine is not able to use it. That's a minor security issue that exposes publicly the userID via a cookie.";
}else{
    print '"userId" is crypted!';
}
#BMS#->{"filename":"is-mongodb-available.php","checksum":2688709000,"relativePath":"html\/Diagnostics\/is-mongodb-available.php","size":635}<-#BME#
<?php

namespace Bartleby;

require_once dirname(__DIR__).'/Configuration.php';
use Bartleby\Configuration;

$directory=dirname(__DIR__).'/';
$configuration=new Configuration($directory,BARTLEBY_ROOT_FOLDER);;

use MongoClient;

if (class_exists('MongoClient')) {
    print "PHP Legacy Mongo client is Installed";
}
else {
    print "PHP Legacy Mongo  client is not Installed";
}



/*
use \MongoDB\Driver ;


if (class_exists('Driver')) {
    $client=new Driver;
    print "PHP MongoDB client is Installed";
}
else {
    print "PHP MongoDB client is not Installed";
}

print(' (You should may be start the daemon : sudo mongod)');

*/#BMS#->{"filename":"phpinfo.php","checksum":1981069917,"relativePath":"html\/Diagnostics\/phpinfo.php","size":19}<-#BME#
<?php phpinfo(); ?>#BMS#->{"filename":"index.php","checksum":952179748,"relativePath":"html\/index.php","size":43}<-#BME#
<?php
include_once __DIR__.'/Pages/go.php';#BMS#->{"filename":"go.php","checksum":2966910473,"relativePath":"html\/Pages\/go.php","size":705}<-#BME#
<?php

namespace Bartleby;

require_once dirname(__DIR__) . '/Configuration.php';
require_once BARTLEBY_ROOT_FOLDER . 'Core/Gateway.php';
require_once BARTLEBY_ROOT_FOLDER . 'Core/Response.php';

use Bartleby\Configuration;
use Bartleby\Core\Gateway;
use Bartleby\Core\Mode;
use bartleby\Core\Response;

$currentDirectory=__DIR__.'/';
$configuration=new Configuration($currentDirectory,BARTLEBY_ROOT_FOLDER);;
$gateway = new Gateway($configuration,Mode::PAGES);

try {
    $gateway->getResponse();
} catch (\Exception $e) {
    $status = 500;
    $header = 'HTTP/1.1 ' . $status . ' ' . Response::getRequestStatus($status);
    header($header);
    echo json_encode(Array('error' => $e->getMessage()));
}
#BMS#->{"filename":"BasePage.php","checksum":211058200,"relativePath":"html\/Pages\/v1\/Pages\/BasePage.php","size":504}<-#BME#
<?php

namespace Bartleby\Pages;

require_once BARTLEBY_ROOT_FOLDER . 'Mongo/MongoHTML5Page.php';

use Bartleby\Core\CallData;
use Bartleby\Mongo\MongoHTML5Page;


class BasePageCallData extends CallData {

}
class BasePage extends  MongoHTML5Page{

    protected function _copyleft(){
        return '<p>Powered by Bartleby | Authenticated:'.($this->isAuthenticated("xxxx")?'<a href="/api/v1/user/logout/?dID=xxxx" _target="_blank">With ID '.$this->getCurrentUserID("xxxx").'</a>':'No').'</p>';
    }

}#BMS#->{"filename":"NotFound.php","checksum":2671477027,"relativePath":"html\/Pages\/v1\/Pages\/NotFound.php","size":896}<-#BME#
<?php

namespace Bartleby\Pages;

require_once __DIR__.'/BasePage.php';

use Bartleby\Core\HTMLResponse;

final class NotFoundCallData extends BasePageCallData {

}

final class NotFound extends BasePage {

    function GET(NotFoundCallData $parameters) {
        return $this->getDocument();
    }


    function POST(NotFoundCallData $parameters) {
        return $this->getDocument();
    }


    /**
     * @return HTMLResponse
     */
    public function getDocument() {
        $r=new HTMLResponse();
		$r->statusCode=404;
        $r->document='<!DOCTYPE HTML>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<title>Default 404 page</title>
</head>
<body>
	<header>
		<nav><ul></ul></nav>
	</header>
	<section>
		<article>
			<p>Not found</p>
		</article>
	</section>
	<footer>'.$this->_copyleft().'</footer>
</body>
</html>';
        return $r;
    }

}#BMS#->{"filename":"Start.php","checksum":848963299,"relativePath":"html\/Pages\/v1\/Pages\/Start.php","size":925}<-#BME#
<?php

// DEMO CLASS FOR TEST PURPOSES

namespace Bartleby\Pages;

require_once __DIR__.'/BasePage.php';

use Bartleby\Core\HTMLResponse;

final class StartCallData extends BasePageCallData {

}

final class Start extends BasePage {

    function GET(StartCallData $parameters) {
        return $this->getDocument();
    }

    function POST(StartCallData $parameters) {
        return $this->getDocument();
    }

    /**
     * @return HTMLResponse
     */
    public function getDocument() {
        $r=new HTMLResponse();
        $r->statusCode=200;
        $r->document='<!DOCTYPE HTML>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<title>Default Start  page</title>
</head>
<body>
	<header>
		<nav><ul></ul></nav>
	</header>
	<section>
		<article>
			<p>Start page</p>
		</article>
	</section>
	<footer>'.$this->_copyleft().'</footer>
</body>
</html>';
        return $r;
    }

}#BMS#->{"filename":"Time.php","checksum":85329892,"relativePath":"html\/Pages\/v1\/Pages\/Time.php","size":1177}<-#BME#
<?php

// DEMO CLASS FOR TEST PURPOSES

namespace Bartleby\Pages;


require_once __DIR__.'/BasePage.php';

use Bartleby\Core\HTMLResponse;

final class TimeCallData extends BasePageCallData {

}

final class Time extends BasePage {

    function GET(TimeCallData $parameters) {
        $r=new HTMLResponse();
        $r->statusCode=200;
        $url=$this->getApiBaseURL().'time';
        $r->document='<!DOCTYPE HTML>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<title>Server Sent Event Time Sample</title>
</head>
<body>
	<header>
		<nav><ul></ul></nav>
	</header>
	<section>
		<article>
			<p id="output"></p>
		</article>
	</section>
	<footer>'.$this->_copyleft().' <a href="'.$url.'"> Time SSE </a> <em>'.$url.'</em></footer>
</body>
<script>
    var output = document.getElementById("output");
    var source = new EventSource("'.$url.'");
    var counter = 1;
    var lastLine ;
    source.addEventListener("tic",function(evt){
            var currentData=JSON.parse(evt.data)
            output.innerHTML=currentData.serverTime;
            counter++;
            return;
    })
</script>
</html>';
        return $r;
    }




}#BMS#->{"filename":"parameters.json","checksum":3308146688,"relativePath":"html\/parameters.json","size":18}<-#BME#
{"superAdmins":[]}#BMS#->{"filename":".htaccess","checksum":3862890224,"relativePath":"html\/Protected\/.htaccess","size":30}<-#BME#
Order Allow,Deny
Deny from all#BMS#->{"filename":"parameters.json","checksum":3308146688,"relativePath":"html\/Protected\/parameters.json","size":18}<-#BME#
{"superAdmins":[]}#BMS#->{"filename":"BartlebySyncConfiguration.php","checksum":3802132973,"relativePath":"Modules\/BartlebySyncConfiguration.php","size":2146}<-#BME#
<?php

if (!defined('BARTLEBY_SYNC_ROOT_PATH')) {

    define('BARTLEBY_SYNC_ROOT_PATH', dirname(__FILE__).'/');

    ///////////////////////
    // KEYS
    ///////////////////////

    
    define('BARTLEBY_SYNC_SECRET_KEY', 'AP_BS_SSK'); // Used create the data system folder

    ///////////////////////
    // REPOSITORY
    ///////////////////////


    // At this point $configuration is set
    $stage=$configuration->STAGE();

    if ($stage==Stages::DEVELOPMENT){
        define('BARTLEBY_SYNC_SECRET_KEY', 'AP_BS_SSK_LOCAL'); // Used create the data system folder
        define('REPOSITORY_BASE_URL','AP_BS_RH_DEVELOPMENT');
        define('REPOSITORY_WRITING_PATH', dirname(__DIR__) .DIRECTORY_SEPARATOR.'files'.DIRECTORY_SEPARATOR);
    }elseif($stage==Stages::PRODUCTION){
        define('BARTLEBY_SYNC_SECRET_KEY', 'AP_BS_SSK_PRODUCTION'); // Used create the data system folder
        define('REPOSITORY_BASE_URL','AP_BS_RH_PRODUCTION');
        define('REPOSITORY_WRITING_PATH', dirname(__DIR__) .DIRECTORY_SEPARATOR.'files'.DIRECTORY_SEPARATOR);
    }elseif($stage==Stages::ALTERNATIVE){
        define('BARTLEBY_SYNC_SECRET_KEY', 'AP_BS_SSK_ALTERNATIVE'); // Used create the data system folder
        define('REPOSITORY_BASE_URL','AP_BS_RH_ALTERNATIVE');
        define('REPOSITORY_WRITING_PATH', dirname(__DIR__) .DIRECTORY_SEPARATOR.'files'.DIRECTORY_SEPARATOR);
    }else{
        // It is local Stages::LOCAL
        define('BARTLEBY_SYNC_SECRET_KEY', 'AP_BS_SSK_LOCAL'); // Used create the data system folder
        define('REPOSITORY_BASE_URL','AP_BS_RH_LOCAL');
        define('REPOSITORY_WRITING_PATH', dirname(__DIR__) .DIRECTORY_SEPARATOR.'files'.DIRECTORY_SEPARATOR);
    }


    ///////////////////////
    // PERSITENCY
    ///////////////////////

    $a=BARTLEBY_SYNC_ROOT_PATH . 'Core/IOManagerFS.php';
    require_once BARTLEBY_SYNC_ROOT_PATH . 'Core/IOManagerFS.php';  // Default adapter
    define('PERSISTENCY_CLASSNAME', 'BartlebySync\Core\IOManagerFS');

    //////////////////////
    // MISC
    //////////////////////

    define('MIN_TREE_ID_LENGTH', 1);

    define('CLEAN_UP_ON_ERROR',false);


}