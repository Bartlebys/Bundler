<?php

require_once 'GenerativeHelper.php';
require_once FLEXIONS_MODULES_DIR . 'Languages/FlexionsSwiftLang.php';


class GenerativeHelperForSwift extends GenerativeHelper {


    static function getCurrentClassNameWithPrefix($d, $classesPrefix = "") {
        if (!$d) return '$d should be set in getCurrentClassFragment( )';
        if (property_exists($d, 'name')) {
            return $classesPrefix . $d->name;
        } else {
            return 'UNDEFINDED-CLASS-FRAGMENT';
        }
    }

    static function defaultHeader(Flexed $f, $d) {
        $swiftHeader = "//
//  $f->fileName
//  $f->projectName
//
";
        $willBePreserved = GenerativeHelper::flexedWillBePreserved($f);
        if ($willBePreserved == false) {
            $swiftHeader .= "// THIS FILE AS BEEN GENERATED BY BARTLEBYFLEXIONS for $f->author
// DO NOT MODIFY THIS FILE YOUR MODIFICATIONS WOULD BE ERASED ON NEXT GENERATION!
// WE TRY TO GENERATE ANY REPETITIVE CODE AND TO IMPROVE THE QUALITY ITERATIVELY
//
";
        }

        $swiftHeader .= "// Copyright (c) 2015  $f->company  All rights reserved.
//";
        return $swiftHeader;

    }


    static function getBaseClass($f, $d) {
        /* @var $d EntityRepresentation */
        /* @var $f Flexed */

        if (isset($d) && isset($d->instanceOf)) {
            return $d->instanceOf;
        } else {
            // Default base  for bartleby
            return GenerativeHelperForSwift::defaultBaseClass($d);
        }
    }

    static function defaultBaseClass($d){
        /* @var $d EntityRepresentation */
        if ($d->name==='BaseObject'){
            return 'JObject';
        }
         return 'BaseObject';
    }


    static function isAGeneratedSubClass($d){
        /* @var $d EntityRepresentation */
        return (isset($d) && isset($d->instanceOf));
    }

    //  NSCODING support

    /**
     * @param $d ActionRepresentation || EntityRepresentation
     * @param $increment integer
     */
    static function echoBodyOfInitWithCoder($d, $increment) {

        // NSCoding support for entities and parameters classes.
        // $d may be ActionRepresentation or EntityRepresentation
        $isEntity=($d instanceof EntityRepresentation);

        while ($isEntity?$d->iterateOnProperties():$d->iterateOnParameters() === true) {
            /* @var $property PropertyRepresentation */
            $property = $isEntity?$d->getProperty():$d->getParameter();
            if (!isset($property->customSerializationMapping)){
                GenerativeHelperForSwift::_echoPropertyForInitWithCoder($property,$increment);
            }else {
                // RECURSIVE CALL FOR CUSTOMSERIALIZATION
                foreach ($property->customSerializationMapping as $property) {
                    GenerativeHelperForSwift::_echoPropertyForInitWithCoder($property, $increment);
                }
            }
        }
    }

    /**
     * @param $property PropertyRepresentation
     * @param $increment integer
     */
    static private function _echoPropertyForInitWithCoder($property, $increment) {
        $name = $property->name;
        $flexionsType = $property->type;
        $asString=(($property->required || $property->default != NULL )? 'as!' : 'as?');
        $nativeType = FlexionsSwiftLang::nativeTypeFor($flexionsType);
        switch ($flexionsType) {
            case FlexionsTypes::STRING:
                echoIndentCR($name . '='.GenerativeHelperForSwift::_decodingFunctionFor($property,$name,$flexionsType) , $increment);
                break;
            case FlexionsTypes::INTEGER:
                echoIndentCR($name . '='.GenerativeHelperForSwift::_decodingFunctionFor($property,$name,$flexionsType) , $increment);
                break;
            case FlexionsTypes::BOOLEAN:
                echoIndentCR($name . '='.GenerativeHelperForSwift::_decodingFunctionFor($property,$name,$flexionsType) , $increment);
                break;
            case FlexionsTypes::OBJECT:
                echoIndentCR($name . '='.GenerativeHelperForSwift::_decodingFunctionFor($property,$name,$flexionsType), $increment);
                break;
            case FlexionsTypes::COLLECTION:
                echoIndentCR($name . '='.GenerativeHelperForSwift::_decodingFunctionFor($property,$name,$flexionsType) .$asString.' [' . ucfirst($property->instanceOf) . ']' , $increment);
                break;
            case FlexionsTypes::ENUM:
                echoIndentCR($name . '='.GenerativeHelperForSwift::_decodingFunctionFor($property,$name,$flexionsType), $increment);
                break;
            case FlexionsTypes::FILE:
                echoIndentCR($name . '='.GenerativeHelperForSwift::_decodingFunctionFor($property,$name,$flexionsType).$asString.' ' .$nativeType . '' , $increment);
                break;
            case FlexionsTypes::DICTIONARY:
                echoIndentCR($name . '='.GenerativeHelperForSwift::_decodingFunctionFor($property,$name,$flexionsType).$asString.' ' .$nativeType . '' , $increment);
                break;
            case FlexionsTypes::FLOAT:
                echoIndentCR($name . '='.GenerativeHelperForSwift::_decodingFunctionFor($property,$name,$flexionsType) , $increment);
                break;
            case FlexionsTypes::DOUBLE:
                echoIndentCR($name . '='.GenerativeHelperForSwift::_decodingFunctionFor($property,$name,$flexionsType) , $increment);
                break;
            case FlexionsTypes::BYTE:
                echoIndentCR('var ref' . ucfirst($name) . '=1;' , $increment);
                // ??
                echoIndentCR($name . '='.GenerativeHelperForSwift::_decodingFunctionFor($property,$name,$flexionsType).'("' . $name . '",&ref' . ucfirst($name) . ')' , $increment);
                break;
            case FlexionsTypes::DATETIME:
                echoIndentCR($name . '='.GenerativeHelperForSwift::_decodingFunctionFor($property,$name,$flexionsType) , $increment);
                break;
            case FlexionsTypes::URL:
                echoIndentCR($name . '='.GenerativeHelperForSwift::_decodingFunctionFor($property,$name,$flexionsType), $increment);
                break;
            case FlexionsTypes::NOT_SUPPORTED:
                echoIndentCR('//' . $name . 'is not supported' , $increment);
                break;
            default :
                echoIndentCR('//' . $name . ' HAS NOT BEEN GENERATED (GENERATIVE TEMPLATE NEEDS TO BE AMENDED)' , $increment);
                break;

        }
    }

    /**
     * @param $property PropertyRepresentation
     * @param $keyName string
     * @param $flexionsType string
     * @return string
     */
    private static function _decodingFunctionFor($property,$keyName,$flexionsType){
        $isNotOptionnal = ($property->required || $property->default != NULL );
        switch ($flexionsType) {
            case FlexionsTypes::STRING:
                if ($isNotOptionnal){
                    return 'String(decoder.decodeObjectOfClass(NSString.self, forKey: "'.$keyName.'")! as NSString)';
                }else{
                    return 'String(decoder.decodeObjectOfClass(NSString.self, forKey:"'.$keyName.'") as NSString?)';
                }
            case FlexionsTypes::INTEGER:
                return 'decoder.decodeIntegerForKey("'.$keyName.'") ';
            case FlexionsTypes::BOOLEAN:
                return 'decoder.decodeBoolForKey("'.$keyName.'") ';
            case FlexionsTypes::OBJECT:
                //return 'decodeObjectForKey("'.$keyName.'") ';
                return  'decoder.decodeObjectOfClass('.$property->instanceOf.'.self, forKey: "'.$keyName.'")'.($isNotOptionnal ?'! ':' ');
            case FlexionsTypes::COLLECTION:
                if ($property->instanceOf != FlexionsTypes::STRING){
                    return  'decoder.decodeObjectOfClasses(NSSet(array: [NSArray.classForCoder(),'.$property->instanceOf.'.classForCoder()]), forKey: "'.$keyName.'")'.($isNotOptionnal ?'! ':' ');
                }else{
                    return  'decoder.decodeObjectOfClasses(NSSet(array: [NSArray.classForCoder(),NSString.self]), forKey: "'.$keyName.'")'.($isNotOptionnal ?'! ':' ');
                }

            case FlexionsTypes::ENUM:
                // .$asString.' '. ucfirst($property->emumPreciseType)
                // User.Status(rawValue:String(decoder.decodeObjectOfClass(NSString.self, forKey: "status")! as NSString))!
                return $property->emumPreciseType.'(rawValue:'.GenerativeHelperForSwift::_decodingFunctionFor($property,$keyName,$property->instanceOf).')'.($isNotOptionnal ?'! ':' ');
            case FlexionsTypes::DICTIONARY;
                return  'decoder.decodeObjectOfClasses(NSSet(array: [NSDictionary.classForCoder(),NSString.classForCoder(),NSNumber.classForCoder(),NSObject.classForCoder(),NSSet.classForCoder()]), forKey: "'.$keyName.'")';
            case FlexionsTypes::FLOAT:
                return 'decoder.decodeFloatForKey("'.$keyName.'") ';
            case FlexionsTypes::DOUBLE:
                return 'decoder.decodeDoubleForKey("'.$keyName.'") ';
            case FlexionsTypes::BYTE:
                return 'decoder.decodeBytesForKey("'.$keyName.'") ';
            case FlexionsTypes::DATETIME:
                if ($isNotOptionnal){
                    return 'decoder.decodeObjectOfClass(NSDate.self, forKey: "'.$keyName.'")! as NSDate';
                }else{
                    return 'decoder.decodeObjectOfClass(NSDate.self, forKey:"'.$keyName.'") as NSDate?';
                }
            case FlexionsTypes::URL || FlexionsTypes::FILE :
                if ($isNotOptionnal){
                    return 'decoder.decodeObjectOfClass(NSURL.self, forKey: "'.$keyName.'")! as NSURL';
                }else{
                    return 'decoder.decodeObjectOfClass(NSURL.self, forKey:"'.$keyName.'") as NSURL?';
                }
            case FlexionsTypes::NOT_SUPPORTED:
                return FlexionsTypes::NOT_SUPPORTED;
                break;
            default :
                return FlexionsTypes::VOID;
                break;
        }
    }



    /**
     * @param $d ActionRepresentation || EntityRepresentation
     * @param $increment integer
     */
    static  function echoBodyOfEncodeWithCoder($d,$increment){

        // NSCoding support for entities and parameters classes.
        // $d may be ActionRepresentation or EntityRepresentation
        $isEntity=($d instanceof EntityRepresentation);

        while ($isEntity?$d->iterateOnProperties():$d->iterateOnParameters() === true) {

            /* @var $property PropertyRepresentation */
            $property = $isEntity?$d->getProperty():$d->getParameter();
            if (!isset($property->customSerializationMapping)){
                GenerativeHelperForSwift::_echoPropertyForEncodeWithCoder($property,$increment);
            }else {
                // RECURSIVE CALL FOR CUSTOMSERIALIZATION
                foreach ($property->customSerializationMapping as $property) {
                    GenerativeHelperForSwift::_echoPropertyForEncodeWithCoder($property, $increment);
                }
            }

        }
    }

    /**
     * @param $property PropertyRepresentation
     * @param $increment integer
     */
    static private function _echoPropertyForEncodeWithCoder($property, $increment) {
        $name = $property->name;
        $incrementPlusOne=$increment+1;
        $securizedName=$name;

        $shouldUseIfString=($property->required===false);
        if (isset($property->default) && $property->default!='' && $property->default!=' ' && $property->required==false ){
            $shouldUseIfString=false;
        }

        // We may enclose the encoding within a it let ... { ... } expression
        // to unwrap optionnals.

        if ($shouldUseIfString){
            $securizedName=str_replace(".","_",$name);
            $currentIncrement=$incrementPlusOne;
            echoIndentCR('if let '.$securizedName.' = self.'.$name.' {', $increment);
        }else{
            $currentIncrement=$increment;
        }
        $encodingFunction=NULL;
        if (!isset($property->type)){
            echoIndentCR('//' . $name . ' HAS NOT BEEN GENERATED (GENERATIVE TEMPLATE NEEDS TO BE AMENDED)' , $increment);
            return;
        }
        if ($property->type===FlexionsTypes::NOT_SUPPORTED){
            echoIndentCR('//'.$name .'is not supported' , $increment);
            return;
        }

        $keyToEncode=$securizedName;
        if ($property->type===FlexionsTypes::ENUM && $property->instanceOf===FlexionsTypes::STRING){
            //Casting is required
            $keyToEncode=$securizedName.'.rawValue ';
        }

        echoIndentCR('coder.'.GenerativeHelperForSwift::_encodingFunctionFor($property->type,$property->instanceOf).'('.$keyToEncode.',forKey:"'. $name .'")' , $currentIncrement);
        if ($shouldUseIfString){
            echoIndentCR('}', $increment);
        }
    }


    /**
     * @param $flexionsType
     * @param string $instanceOf
     * @return string
     */
    private static function _encodingFunctionFor($flexionsType,$instanceOf='UNDEFINED'){
        switch ($flexionsType) {
            case FlexionsTypes::STRING:
                return 'encodeObject';
            case FlexionsTypes::INTEGER:
                return 'encodeInteger';
            case FlexionsTypes::BOOLEAN:
                return 'encodeBool';
            case FlexionsTypes::OBJECT:
                return 'encodeObject';
            case FlexionsTypes::COLLECTION:
                return 'encodeObject';
            case FlexionsTypes::ENUM;
                // We have 3 levels :
                // When the type is an ENUM, you can specify its precise type
                // Swift enum can be typed. We want to be able to cast the enums.
                // E.g : property status type=enum, instanceOf=string , enumPreciseType=User.status
                return GenerativeHelperForSwift::_encodingFunctionFor($instanceOf);
            case FlexionsTypes::FILE:
                return 'encodeObject';
            case FlexionsTypes::DICTIONARY:
                return 'encodeObject';
            case FlexionsTypes::FLOAT:
                return 'encodeFloat';
            case FlexionsTypes::DOUBLE:
                return 'encodeDouble';
            case FlexionsTypes::BYTE:
                return 'encodeBytes';
            case FlexionsTypes::DATETIME:
                return 'encodeObject';
            case FlexionsTypes::URL:
                return 'encodeObject';
            case FlexionsTypes::NOT_SUPPORTED:
                return FlexionsTypes::NOT_SUPPORTED;
            default :
                return FlexionsTypes::VOID;
        }
    }

}

?>